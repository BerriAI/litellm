# -*- coding: utf-8 -*-
# code generated by Prisma. DO NOT EDIT.
# pyright: reportUnusedImport=false
# fmt: off
from __future__ import annotations

# global imports for type checking
from builtins import bool as _bool
from builtins import int as _int
from builtins import float as _float
from builtins import str as _str
import sys
import decimal
import datetime
from typing import (
    TYPE_CHECKING,
    Optional,
    Iterable,
    Iterator,
    Sequence,
    Callable,
    ClassVar,
    NoReturn,
    TypeVar,
    Generic,
    Mapping,
    Tuple,
    Union,
    List,
    Dict,
    Type,
    Any,
    Set,
    overload,
    cast,
)
from typing_extensions import TypedDict, Literal


LiteralString = str
# -- template actions.py.jinja --
from typing import TypeVar
import warnings

from . import types, errors, bases
from ._compat import model_parse

if TYPE_CHECKING:
    from .client import Client
    from .bases import _PrismaModel


_PrismaModelT = TypeVar('_PrismaModelT', bound='_PrismaModel')


class LiteLLM_BudgetTableActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: 'Client', model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.LiteLLM_BudgetTable]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await LiteLLM_BudgetTable.prisma().query_raw(
            'SELECT * FROM LiteLLM_BudgetTable WHERE budget_id = $1',
            'bbadfchfja',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.LiteLLM_BudgetTable
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await LiteLLM_BudgetTable.prisma().query_first(
            'SELECT * FROM LiteLLM_BudgetTable WHERE max_budget = $1',
            377401575.66282,
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.LiteLLM_BudgetTableCreateInput,
        include: Optional[types.LiteLLM_BudgetTableInclude] = None
    ) -> _PrismaModelT:
        """Create a new LiteLLM_BudgetTable record.

        Parameters
        ----------
        data
            LiteLLM_BudgetTable record data
        include
            Specifies which relations should be loaded on the returned LiteLLM_BudgetTable model

        Returns
        -------
        prisma.models.LiteLLM_BudgetTable
            The created LiteLLM_BudgetTable record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a LiteLLM_BudgetTable record from just the required fields
        litellm_budgettable = await LiteLLM_BudgetTable.prisma().create(
            data={
                # data to create a LiteLLM_BudgetTable record
                'created_by': 'bbehjachib',
                'updated_by': 'cadfabfehe',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.LiteLLM_BudgetTableCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple LiteLLM_BudgetTable records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of LiteLLM_BudgetTable record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await LiteLLM_BudgetTable.prisma().create_many(
            data=[
                {
                    # data to create a LiteLLM_BudgetTable record
                    'created_by': 'dgiiaaijj',
                    'updated_by': 'bfaiacjjfc',
                },
                {
                    # data to create a LiteLLM_BudgetTable record
                    'created_by': 'eigcfgbif',
                    'updated_by': 'bagcfbhiig',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.LiteLLM_BudgetTableWhereUniqueInput,
        include: Optional[types.LiteLLM_BudgetTableInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single LiteLLM_BudgetTable record.

        Parameters
        ----------
        where
            LiteLLM_BudgetTable filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned LiteLLM_BudgetTable model

        Returns
        -------
        prisma.models.LiteLLM_BudgetTable
            The deleted LiteLLM_BudgetTable record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        litellm_budgettable = await LiteLLM_BudgetTable.prisma().delete(
            where={
                'budget_id': 'cghideieh',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.LiteLLM_BudgetTableWhereUniqueInput,
        include: Optional[types.LiteLLM_BudgetTableInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique LiteLLM_BudgetTable record.

        Parameters
        ----------
        where
            LiteLLM_BudgetTable filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned LiteLLM_BudgetTable model

        Returns
        -------
        prisma.models.LiteLLM_BudgetTable
            The found LiteLLM_BudgetTable record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        litellm_budgettable = await LiteLLM_BudgetTable.prisma().find_unique(
            where={
                'budget_id': 'biabhbdai',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.LiteLLM_BudgetTableWhereUniqueInput,
        include: Optional[types.LiteLLM_BudgetTableInclude] = None
    ) -> _PrismaModelT:
        """Find a unique LiteLLM_BudgetTable record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            LiteLLM_BudgetTable filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned LiteLLM_BudgetTable model

        Returns
        -------
        prisma.models.LiteLLM_BudgetTable
            The found LiteLLM_BudgetTable record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        litellm_budgettable = await LiteLLM_BudgetTable.prisma().find_unique_or_raise(
            where={
                'budget_id': 'idghgaicb',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_BudgetTableWhereInput] = None,
        cursor: Optional[types.LiteLLM_BudgetTableWhereUniqueInput] = None,
        include: Optional[types.LiteLLM_BudgetTableInclude] = None,
        order: Optional[Union[types.LiteLLM_BudgetTableOrderByInput, List[types.LiteLLM_BudgetTableOrderByInput]]] = None,
        distinct: Optional[List[types.LiteLLM_BudgetTableScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple LiteLLM_BudgetTable records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of LiteLLM_BudgetTable records returned
        skip
            Ignore the first N results
        where
            LiteLLM_BudgetTable filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned LiteLLM_BudgetTable model
        order
            Order the returned LiteLLM_BudgetTable records by any field
        distinct
            Filter LiteLLM_BudgetTable records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.LiteLLM_BudgetTable]
            The list of all LiteLLM_BudgetTable records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 LiteLLM_BudgetTable records
        litellm_budgettables = await LiteLLM_BudgetTable.prisma().find_many(take=10)

        # find the first 5 LiteLLM_BudgetTable records ordered by the soft_budget field
        litellm_budgettables = await LiteLLM_BudgetTable.prisma().find_many(
            take=5,
            order={
                'soft_budget': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_BudgetTableWhereInput] = None,
        cursor: Optional[types.LiteLLM_BudgetTableWhereUniqueInput] = None,
        include: Optional[types.LiteLLM_BudgetTableInclude] = None,
        order: Optional[Union[types.LiteLLM_BudgetTableOrderByInput, List[types.LiteLLM_BudgetTableOrderByInput]]] = None,
        distinct: Optional[List[types.LiteLLM_BudgetTableScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single LiteLLM_BudgetTable record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            LiteLLM_BudgetTable filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned LiteLLM_BudgetTable model
        order
            Order the returned LiteLLM_BudgetTable records by any field
        distinct
            Filter LiteLLM_BudgetTable records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.LiteLLM_BudgetTable
            The first LiteLLM_BudgetTable record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second LiteLLM_BudgetTable record ordered by the max_parallel_requests field
        litellm_budgettable = await LiteLLM_BudgetTable.prisma().find_first(
            skip=1,
            order={
                'max_parallel_requests': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_BudgetTableWhereInput] = None,
        cursor: Optional[types.LiteLLM_BudgetTableWhereUniqueInput] = None,
        include: Optional[types.LiteLLM_BudgetTableInclude] = None,
        order: Optional[Union[types.LiteLLM_BudgetTableOrderByInput, List[types.LiteLLM_BudgetTableOrderByInput]]] = None,
        distinct: Optional[List[types.LiteLLM_BudgetTableScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single LiteLLM_BudgetTable record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            LiteLLM_BudgetTable filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned LiteLLM_BudgetTable model
        order
            Order the returned LiteLLM_BudgetTable records by any field
        distinct
            Filter LiteLLM_BudgetTable records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.LiteLLM_BudgetTable
            The first LiteLLM_BudgetTable record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second LiteLLM_BudgetTable record ordered by the tpm_limit field
        litellm_budgettable = await LiteLLM_BudgetTable.prisma().find_first_or_raise(
            skip=1,
            order={
                'tpm_limit': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.LiteLLM_BudgetTableUpdateInput,
        where: types.LiteLLM_BudgetTableWhereUniqueInput,
        include: Optional[types.LiteLLM_BudgetTableInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single LiteLLM_BudgetTable record.

        Parameters
        ----------
        data
            LiteLLM_BudgetTable record data specifying what to update
        where
            LiteLLM_BudgetTable filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned LiteLLM_BudgetTable model

        Returns
        -------
        prisma.models.LiteLLM_BudgetTable
            The updated LiteLLM_BudgetTable record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        litellm_budgettable = await LiteLLM_BudgetTable.prisma().update(
            where={
                'budget_id': 'fjfddhigg',
            },
            data={
                # data to update the LiteLLM_BudgetTable record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.LiteLLM_BudgetTableWhereUniqueInput,
        data: types.LiteLLM_BudgetTableUpsertInput,
        include: Optional[types.LiteLLM_BudgetTableInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            LiteLLM_BudgetTable filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned LiteLLM_BudgetTable model

        Returns
        -------
        prisma.models.LiteLLM_BudgetTable
            The created or updated LiteLLM_BudgetTable record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        litellm_budgettable = await LiteLLM_BudgetTable.prisma().upsert(
            where={
                'budget_id': 'hjaecfifb',
            },
            data={
                'create': {
                    'budget_id': 'hjaecfifb',
                    'created_by': 'eigcfgbif',
                    'updated_by': 'bagcfbhiig',
                },
                'update': {
                    'created_by': 'eigcfgbif',
                    'updated_by': 'bagcfbhiig',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.LiteLLM_BudgetTableUpdateManyMutationInput,
        where: types.LiteLLM_BudgetTableWhereInput,
    ) -> int:
        """Update multiple LiteLLM_BudgetTable records

        Parameters
        ----------
        data
            LiteLLM_BudgetTable data to update the selected LiteLLM_BudgetTable records to
        where
            Filter to select the LiteLLM_BudgetTable records to update

        Returns
        -------
        int
            The total number of LiteLLM_BudgetTable records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all LiteLLM_BudgetTable records
        total = await LiteLLM_BudgetTable.prisma().update_many(
            data={
                'rpm_limit': 25342983456
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_BudgetTableWhereInput] = None,
        cursor: Optional[types.LiteLLM_BudgetTableWhereUniqueInput] = None,
    ) -> int:
        """Count the number of LiteLLM_BudgetTable records present in the database

        Parameters
        ----------
        select
            Select the LiteLLM_BudgetTable fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            LiteLLM_BudgetTable filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.LiteLLM_BudgetTableCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await LiteLLM_BudgetTable.prisma().count()

        # results: prisma.types.LiteLLM_BudgetTableCountAggregateOutput
        results = await LiteLLM_BudgetTable.prisma().count(
            select={
                '_all': True,
                'model_max_budget': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.LiteLLM_BudgetTableCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_BudgetTableWhereInput] = None,
        cursor: Optional[types.LiteLLM_BudgetTableWhereUniqueInput] = None,
    ) -> types.LiteLLM_BudgetTableCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.LiteLLM_BudgetTableCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_BudgetTableWhereInput] = None,
        cursor: Optional[types.LiteLLM_BudgetTableWhereUniqueInput] = None,
    ) -> Union[int, types.LiteLLM_BudgetTableCountAggregateOutput]:
        """Count the number of LiteLLM_BudgetTable records present in the database

        Parameters
        ----------
        select
            Select the LiteLLM_BudgetTable fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            LiteLLM_BudgetTable filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.LiteLLM_BudgetTableCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await LiteLLM_BudgetTable.prisma().count()

        # results: prisma.types.LiteLLM_BudgetTableCountAggregateOutput
        results = await LiteLLM_BudgetTable.prisma().count(
            select={
                '_all': True,
                'budget_duration': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.LiteLLM_BudgetTableCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.LiteLLM_BudgetTableWhereInput] = None
    ) -> int:
        """Delete multiple LiteLLM_BudgetTable records.

        Parameters
        ----------
        where
            Optional LiteLLM_BudgetTable filter to find the records to be deleted

        Returns
        -------
        int
            The total number of LiteLLM_BudgetTable records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all LiteLLM_BudgetTable records
        total = await LiteLLM_BudgetTable.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.LiteLLM_BudgetTableScalarFieldKeys'],
        *,
        where: Optional['types.LiteLLM_BudgetTableWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.LiteLLM_BudgetTableAvgAggregateInput'] = None,
        sum: Optional['types.LiteLLM_BudgetTableSumAggregateInput'] = None,
        min: Optional['types.LiteLLM_BudgetTableMinAggregateInput'] = None,
        max: Optional['types.LiteLLM_BudgetTableMaxAggregateInput'] = None,
        having: Optional['types.LiteLLM_BudgetTableScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.LiteLLM_BudgetTableCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.LiteLLM_BudgetTableScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.LiteLLM_BudgetTableScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.LiteLLM_BudgetTableGroupByOutput']:
        """Group LiteLLM_BudgetTable records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar LiteLLM_BudgetTable fields to group records by
        where
            LiteLLM_BudgetTable filter to select records
        take
            Limit the maximum number of LiteLLM_BudgetTable records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.LiteLLM_BudgetTableGroupByOutput]
            A list of dictionaries representing the LiteLLM_BudgetTable record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group LiteLLM_BudgetTable records by budget_reset_at values
        # and count how many records are in each group
        results = await LiteLLM_BudgetTable.prisma().group_by(
            ['budget_reset_at'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class LiteLLM_CredentialsTableActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: 'Client', model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.LiteLLM_CredentialsTable]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await LiteLLM_CredentialsTable.prisma().query_raw(
            'SELECT * FROM LiteLLM_CredentialsTable WHERE credential_id = $1',
            'bbejhfidcb',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.LiteLLM_CredentialsTable
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await LiteLLM_CredentialsTable.prisma().query_first(
            'SELECT * FROM LiteLLM_CredentialsTable WHERE credential_name = $1',
            'bgeecijdgg',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.LiteLLM_CredentialsTableCreateInput,
        include: Optional[types.LiteLLM_CredentialsTableInclude] = None
    ) -> _PrismaModelT:
        """Create a new LiteLLM_CredentialsTable record.

        Parameters
        ----------
        data
            LiteLLM_CredentialsTable record data
        include
            Specifies which relations should be loaded on the returned LiteLLM_CredentialsTable model

        Returns
        -------
        prisma.models.LiteLLM_CredentialsTable
            The created LiteLLM_CredentialsTable record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a LiteLLM_CredentialsTable record from just the required fields
        litellm_credentialstable = await LiteLLM_CredentialsTable.prisma().create(
            data={
                # data to create a LiteLLM_CredentialsTable record
                'credential_name': 'bdiicjafbj',
                'credential_values': Json({'bgehebiafc': True}),
                'created_by': 'bghffegacj',
                'updated_by': 'bhghchehcc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.LiteLLM_CredentialsTableCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple LiteLLM_CredentialsTable records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of LiteLLM_CredentialsTable record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await LiteLLM_CredentialsTable.prisma().create_many(
            data=[
                {
                    # data to create a LiteLLM_CredentialsTable record
                    'credential_name': 'dcgchcbbf',
                    'credential_values': Json({'bdedcabahc': True}),
                    'created_by': 'ghfhiafcb',
                    'updated_by': 'heejgedji',
                },
                {
                    # data to create a LiteLLM_CredentialsTable record
                    'credential_name': 'bjgjgibgbf',
                    'credential_values': Json({'bbbgbhfjge': True}),
                    'created_by': 'igbehcbab',
                    'updated_by': 'bdadaadhag',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.LiteLLM_CredentialsTableWhereUniqueInput,
        include: Optional[types.LiteLLM_CredentialsTableInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single LiteLLM_CredentialsTable record.

        Parameters
        ----------
        where
            LiteLLM_CredentialsTable filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned LiteLLM_CredentialsTable model

        Returns
        -------
        prisma.models.LiteLLM_CredentialsTable
            The deleted LiteLLM_CredentialsTable record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        litellm_credentialstable = await LiteLLM_CredentialsTable.prisma().delete(
            where={
                'credential_id': 'bgiggdidbf',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.LiteLLM_CredentialsTableWhereUniqueInput,
        include: Optional[types.LiteLLM_CredentialsTableInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique LiteLLM_CredentialsTable record.

        Parameters
        ----------
        where
            LiteLLM_CredentialsTable filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned LiteLLM_CredentialsTable model

        Returns
        -------
        prisma.models.LiteLLM_CredentialsTable
            The found LiteLLM_CredentialsTable record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        litellm_credentialstable = await LiteLLM_CredentialsTable.prisma().find_unique(
            where={
                'credential_id': 'caaaedabfc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.LiteLLM_CredentialsTableWhereUniqueInput,
        include: Optional[types.LiteLLM_CredentialsTableInclude] = None
    ) -> _PrismaModelT:
        """Find a unique LiteLLM_CredentialsTable record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            LiteLLM_CredentialsTable filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned LiteLLM_CredentialsTable model

        Returns
        -------
        prisma.models.LiteLLM_CredentialsTable
            The found LiteLLM_CredentialsTable record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        litellm_credentialstable = await LiteLLM_CredentialsTable.prisma().find_unique_or_raise(
            where={
                'credential_id': 'bigibebcib',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_CredentialsTableWhereInput] = None,
        cursor: Optional[types.LiteLLM_CredentialsTableWhereUniqueInput] = None,
        include: Optional[types.LiteLLM_CredentialsTableInclude] = None,
        order: Optional[Union[types.LiteLLM_CredentialsTableOrderByInput, List[types.LiteLLM_CredentialsTableOrderByInput]]] = None,
        distinct: Optional[List[types.LiteLLM_CredentialsTableScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple LiteLLM_CredentialsTable records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of LiteLLM_CredentialsTable records returned
        skip
            Ignore the first N results
        where
            LiteLLM_CredentialsTable filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned LiteLLM_CredentialsTable model
        order
            Order the returned LiteLLM_CredentialsTable records by any field
        distinct
            Filter LiteLLM_CredentialsTable records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.LiteLLM_CredentialsTable]
            The list of all LiteLLM_CredentialsTable records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 LiteLLM_CredentialsTable records
        litellm_credentialstables = await LiteLLM_CredentialsTable.prisma().find_many(take=10)

        # find the first 5 LiteLLM_CredentialsTable records ordered by the credential_values field
        litellm_credentialstables = await LiteLLM_CredentialsTable.prisma().find_many(
            take=5,
            order={
                'credential_values': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_CredentialsTableWhereInput] = None,
        cursor: Optional[types.LiteLLM_CredentialsTableWhereUniqueInput] = None,
        include: Optional[types.LiteLLM_CredentialsTableInclude] = None,
        order: Optional[Union[types.LiteLLM_CredentialsTableOrderByInput, List[types.LiteLLM_CredentialsTableOrderByInput]]] = None,
        distinct: Optional[List[types.LiteLLM_CredentialsTableScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single LiteLLM_CredentialsTable record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            LiteLLM_CredentialsTable filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned LiteLLM_CredentialsTable model
        order
            Order the returned LiteLLM_CredentialsTable records by any field
        distinct
            Filter LiteLLM_CredentialsTable records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.LiteLLM_CredentialsTable
            The first LiteLLM_CredentialsTable record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second LiteLLM_CredentialsTable record ordered by the credential_info field
        litellm_credentialstable = await LiteLLM_CredentialsTable.prisma().find_first(
            skip=1,
            order={
                'credential_info': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_CredentialsTableWhereInput] = None,
        cursor: Optional[types.LiteLLM_CredentialsTableWhereUniqueInput] = None,
        include: Optional[types.LiteLLM_CredentialsTableInclude] = None,
        order: Optional[Union[types.LiteLLM_CredentialsTableOrderByInput, List[types.LiteLLM_CredentialsTableOrderByInput]]] = None,
        distinct: Optional[List[types.LiteLLM_CredentialsTableScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single LiteLLM_CredentialsTable record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            LiteLLM_CredentialsTable filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned LiteLLM_CredentialsTable model
        order
            Order the returned LiteLLM_CredentialsTable records by any field
        distinct
            Filter LiteLLM_CredentialsTable records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.LiteLLM_CredentialsTable
            The first LiteLLM_CredentialsTable record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second LiteLLM_CredentialsTable record ordered by the created_at field
        litellm_credentialstable = await LiteLLM_CredentialsTable.prisma().find_first_or_raise(
            skip=1,
            order={
                'created_at': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.LiteLLM_CredentialsTableUpdateInput,
        where: types.LiteLLM_CredentialsTableWhereUniqueInput,
        include: Optional[types.LiteLLM_CredentialsTableInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single LiteLLM_CredentialsTable record.

        Parameters
        ----------
        data
            LiteLLM_CredentialsTable record data specifying what to update
        where
            LiteLLM_CredentialsTable filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned LiteLLM_CredentialsTable model

        Returns
        -------
        prisma.models.LiteLLM_CredentialsTable
            The updated LiteLLM_CredentialsTable record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        litellm_credentialstable = await LiteLLM_CredentialsTable.prisma().update(
            where={
                'credential_id': 'bigaiehgcc',
            },
            data={
                # data to update the LiteLLM_CredentialsTable record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.LiteLLM_CredentialsTableWhereUniqueInput,
        data: types.LiteLLM_CredentialsTableUpsertInput,
        include: Optional[types.LiteLLM_CredentialsTableInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            LiteLLM_CredentialsTable filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned LiteLLM_CredentialsTable model

        Returns
        -------
        prisma.models.LiteLLM_CredentialsTable
            The created or updated LiteLLM_CredentialsTable record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        litellm_credentialstable = await LiteLLM_CredentialsTable.prisma().upsert(
            where={
                'credential_id': 'beeifcbebf',
            },
            data={
                'create': {
                    'credential_id': 'beeifcbebf',
                    'credential_name': 'bjgjgibgbf',
                    'credential_values': Json({'bbbgbhfjge': True}),
                    'created_by': 'igbehcbab',
                    'updated_by': 'bdadaadhag',
                },
                'update': {
                    'credential_name': 'bjgjgibgbf',
                    'credential_values': Json({'bbbgbhfjge': True}),
                    'created_by': 'igbehcbab',
                    'updated_by': 'bdadaadhag',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.LiteLLM_CredentialsTableUpdateManyMutationInput,
        where: types.LiteLLM_CredentialsTableWhereInput,
    ) -> int:
        """Update multiple LiteLLM_CredentialsTable records

        Parameters
        ----------
        data
            LiteLLM_CredentialsTable data to update the selected LiteLLM_CredentialsTable records to
        where
            Filter to select the LiteLLM_CredentialsTable records to update

        Returns
        -------
        int
            The total number of LiteLLM_CredentialsTable records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all LiteLLM_CredentialsTable records
        total = await LiteLLM_CredentialsTable.prisma().update_many(
            data={
                'created_by': 'bgcigfahea'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_CredentialsTableWhereInput] = None,
        cursor: Optional[types.LiteLLM_CredentialsTableWhereUniqueInput] = None,
    ) -> int:
        """Count the number of LiteLLM_CredentialsTable records present in the database

        Parameters
        ----------
        select
            Select the LiteLLM_CredentialsTable fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            LiteLLM_CredentialsTable filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.LiteLLM_CredentialsTableCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await LiteLLM_CredentialsTable.prisma().count()

        # results: prisma.types.LiteLLM_CredentialsTableCountAggregateOutput
        results = await LiteLLM_CredentialsTable.prisma().count(
            select={
                '_all': True,
                'updated_at': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.LiteLLM_CredentialsTableCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_CredentialsTableWhereInput] = None,
        cursor: Optional[types.LiteLLM_CredentialsTableWhereUniqueInput] = None,
    ) -> types.LiteLLM_CredentialsTableCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.LiteLLM_CredentialsTableCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_CredentialsTableWhereInput] = None,
        cursor: Optional[types.LiteLLM_CredentialsTableWhereUniqueInput] = None,
    ) -> Union[int, types.LiteLLM_CredentialsTableCountAggregateOutput]:
        """Count the number of LiteLLM_CredentialsTable records present in the database

        Parameters
        ----------
        select
            Select the LiteLLM_CredentialsTable fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            LiteLLM_CredentialsTable filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.LiteLLM_CredentialsTableCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await LiteLLM_CredentialsTable.prisma().count()

        # results: prisma.types.LiteLLM_CredentialsTableCountAggregateOutput
        results = await LiteLLM_CredentialsTable.prisma().count(
            select={
                '_all': True,
                'updated_by': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.LiteLLM_CredentialsTableCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.LiteLLM_CredentialsTableWhereInput] = None
    ) -> int:
        """Delete multiple LiteLLM_CredentialsTable records.

        Parameters
        ----------
        where
            Optional LiteLLM_CredentialsTable filter to find the records to be deleted

        Returns
        -------
        int
            The total number of LiteLLM_CredentialsTable records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all LiteLLM_CredentialsTable records
        total = await LiteLLM_CredentialsTable.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.LiteLLM_CredentialsTableScalarFieldKeys'],
        *,
        where: Optional['types.LiteLLM_CredentialsTableWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.LiteLLM_CredentialsTableAvgAggregateInput'] = None,
        sum: Optional['types.LiteLLM_CredentialsTableSumAggregateInput'] = None,
        min: Optional['types.LiteLLM_CredentialsTableMinAggregateInput'] = None,
        max: Optional['types.LiteLLM_CredentialsTableMaxAggregateInput'] = None,
        having: Optional['types.LiteLLM_CredentialsTableScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.LiteLLM_CredentialsTableCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.LiteLLM_CredentialsTableScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.LiteLLM_CredentialsTableScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.LiteLLM_CredentialsTableGroupByOutput']:
        """Group LiteLLM_CredentialsTable records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar LiteLLM_CredentialsTable fields to group records by
        where
            LiteLLM_CredentialsTable filter to select records
        take
            Limit the maximum number of LiteLLM_CredentialsTable records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.LiteLLM_CredentialsTableGroupByOutput]
            A list of dictionaries representing the LiteLLM_CredentialsTable record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group LiteLLM_CredentialsTable records by credential_id values
        # and count how many records are in each group
        results = await LiteLLM_CredentialsTable.prisma().group_by(
            ['credential_id'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class LiteLLM_ProxyModelTableActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: 'Client', model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.LiteLLM_ProxyModelTable]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await LiteLLM_ProxyModelTable.prisma().query_raw(
            'SELECT * FROM LiteLLM_ProxyModelTable WHERE model_id = $1',
            'bcejgaggif',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.LiteLLM_ProxyModelTable
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await LiteLLM_ProxyModelTable.prisma().query_first(
            'SELECT * FROM LiteLLM_ProxyModelTable WHERE model_name = $1',
            'idfjadbcc',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.LiteLLM_ProxyModelTableCreateInput,
        include: Optional[types.LiteLLM_ProxyModelTableInclude] = None
    ) -> _PrismaModelT:
        """Create a new LiteLLM_ProxyModelTable record.

        Parameters
        ----------
        data
            LiteLLM_ProxyModelTable record data
        include
            Specifies which relations should be loaded on the returned LiteLLM_ProxyModelTable model

        Returns
        -------
        prisma.models.LiteLLM_ProxyModelTable
            The created LiteLLM_ProxyModelTable record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a LiteLLM_ProxyModelTable record from just the required fields
        litellm_proxymodeltable = await LiteLLM_ProxyModelTable.prisma().create(
            data={
                # data to create a LiteLLM_ProxyModelTable record
                'model_name': 'hgdhbjhhj',
                'litellm_params': Json({'ecjjjfbae': True}),
                'created_by': 'bhhfibbigf',
                'updated_by': 'ijdbeffgg',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.LiteLLM_ProxyModelTableCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple LiteLLM_ProxyModelTable records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of LiteLLM_ProxyModelTable record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await LiteLLM_ProxyModelTable.prisma().create_many(
            data=[
                {
                    # data to create a LiteLLM_ProxyModelTable record
                    'model_name': 'jjfeafhfj',
                    'litellm_params': Json({'cbachdgfce': True}),
                    'created_by': 'chbfcacbd',
                    'updated_by': 'efggddide',
                },
                {
                    # data to create a LiteLLM_ProxyModelTable record
                    'model_name': 'caficfigfb',
                    'litellm_params': Json({'bfidgijfjc': True}),
                    'created_by': 'ihieecagf',
                    'updated_by': 'bghfciaafe',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.LiteLLM_ProxyModelTableWhereUniqueInput,
        include: Optional[types.LiteLLM_ProxyModelTableInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single LiteLLM_ProxyModelTable record.

        Parameters
        ----------
        where
            LiteLLM_ProxyModelTable filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned LiteLLM_ProxyModelTable model

        Returns
        -------
        prisma.models.LiteLLM_ProxyModelTable
            The deleted LiteLLM_ProxyModelTable record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        litellm_proxymodeltable = await LiteLLM_ProxyModelTable.prisma().delete(
            where={
                'model_id': 'bgchfhgceh',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.LiteLLM_ProxyModelTableWhereUniqueInput,
        include: Optional[types.LiteLLM_ProxyModelTableInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique LiteLLM_ProxyModelTable record.

        Parameters
        ----------
        where
            LiteLLM_ProxyModelTable filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned LiteLLM_ProxyModelTable model

        Returns
        -------
        prisma.models.LiteLLM_ProxyModelTable
            The found LiteLLM_ProxyModelTable record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        litellm_proxymodeltable = await LiteLLM_ProxyModelTable.prisma().find_unique(
            where={
                'model_id': 'cafeiaccbc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.LiteLLM_ProxyModelTableWhereUniqueInput,
        include: Optional[types.LiteLLM_ProxyModelTableInclude] = None
    ) -> _PrismaModelT:
        """Find a unique LiteLLM_ProxyModelTable record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            LiteLLM_ProxyModelTable filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned LiteLLM_ProxyModelTable model

        Returns
        -------
        prisma.models.LiteLLM_ProxyModelTable
            The found LiteLLM_ProxyModelTable record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        litellm_proxymodeltable = await LiteLLM_ProxyModelTable.prisma().find_unique_or_raise(
            where={
                'model_id': 'gaddfhfh',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_ProxyModelTableWhereInput] = None,
        cursor: Optional[types.LiteLLM_ProxyModelTableWhereUniqueInput] = None,
        include: Optional[types.LiteLLM_ProxyModelTableInclude] = None,
        order: Optional[Union[types.LiteLLM_ProxyModelTableOrderByInput, List[types.LiteLLM_ProxyModelTableOrderByInput]]] = None,
        distinct: Optional[List[types.LiteLLM_ProxyModelTableScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple LiteLLM_ProxyModelTable records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of LiteLLM_ProxyModelTable records returned
        skip
            Ignore the first N results
        where
            LiteLLM_ProxyModelTable filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned LiteLLM_ProxyModelTable model
        order
            Order the returned LiteLLM_ProxyModelTable records by any field
        distinct
            Filter LiteLLM_ProxyModelTable records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.LiteLLM_ProxyModelTable]
            The list of all LiteLLM_ProxyModelTable records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 LiteLLM_ProxyModelTable records
        litellm_proxymodeltables = await LiteLLM_ProxyModelTable.prisma().find_many(take=10)

        # find the first 5 LiteLLM_ProxyModelTable records ordered by the litellm_params field
        litellm_proxymodeltables = await LiteLLM_ProxyModelTable.prisma().find_many(
            take=5,
            order={
                'litellm_params': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_ProxyModelTableWhereInput] = None,
        cursor: Optional[types.LiteLLM_ProxyModelTableWhereUniqueInput] = None,
        include: Optional[types.LiteLLM_ProxyModelTableInclude] = None,
        order: Optional[Union[types.LiteLLM_ProxyModelTableOrderByInput, List[types.LiteLLM_ProxyModelTableOrderByInput]]] = None,
        distinct: Optional[List[types.LiteLLM_ProxyModelTableScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single LiteLLM_ProxyModelTable record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            LiteLLM_ProxyModelTable filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned LiteLLM_ProxyModelTable model
        order
            Order the returned LiteLLM_ProxyModelTable records by any field
        distinct
            Filter LiteLLM_ProxyModelTable records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.LiteLLM_ProxyModelTable
            The first LiteLLM_ProxyModelTable record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second LiteLLM_ProxyModelTable record ordered by the model_info field
        litellm_proxymodeltable = await LiteLLM_ProxyModelTable.prisma().find_first(
            skip=1,
            order={
                'model_info': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_ProxyModelTableWhereInput] = None,
        cursor: Optional[types.LiteLLM_ProxyModelTableWhereUniqueInput] = None,
        include: Optional[types.LiteLLM_ProxyModelTableInclude] = None,
        order: Optional[Union[types.LiteLLM_ProxyModelTableOrderByInput, List[types.LiteLLM_ProxyModelTableOrderByInput]]] = None,
        distinct: Optional[List[types.LiteLLM_ProxyModelTableScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single LiteLLM_ProxyModelTable record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            LiteLLM_ProxyModelTable filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned LiteLLM_ProxyModelTable model
        order
            Order the returned LiteLLM_ProxyModelTable records by any field
        distinct
            Filter LiteLLM_ProxyModelTable records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.LiteLLM_ProxyModelTable
            The first LiteLLM_ProxyModelTable record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second LiteLLM_ProxyModelTable record ordered by the created_at field
        litellm_proxymodeltable = await LiteLLM_ProxyModelTable.prisma().find_first_or_raise(
            skip=1,
            order={
                'created_at': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.LiteLLM_ProxyModelTableUpdateInput,
        where: types.LiteLLM_ProxyModelTableWhereUniqueInput,
        include: Optional[types.LiteLLM_ProxyModelTableInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single LiteLLM_ProxyModelTable record.

        Parameters
        ----------
        data
            LiteLLM_ProxyModelTable record data specifying what to update
        where
            LiteLLM_ProxyModelTable filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned LiteLLM_ProxyModelTable model

        Returns
        -------
        prisma.models.LiteLLM_ProxyModelTable
            The updated LiteLLM_ProxyModelTable record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        litellm_proxymodeltable = await LiteLLM_ProxyModelTable.prisma().update(
            where={
                'model_id': 'gieegcbeg',
            },
            data={
                # data to update the LiteLLM_ProxyModelTable record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.LiteLLM_ProxyModelTableWhereUniqueInput,
        data: types.LiteLLM_ProxyModelTableUpsertInput,
        include: Optional[types.LiteLLM_ProxyModelTableInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            LiteLLM_ProxyModelTable filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned LiteLLM_ProxyModelTable model

        Returns
        -------
        prisma.models.LiteLLM_ProxyModelTable
            The created or updated LiteLLM_ProxyModelTable record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        litellm_proxymodeltable = await LiteLLM_ProxyModelTable.prisma().upsert(
            where={
                'model_id': 'bgcffadich',
            },
            data={
                'create': {
                    'model_id': 'bgcffadich',
                    'model_name': 'caficfigfb',
                    'litellm_params': Json({'bfidgijfjc': True}),
                    'created_by': 'ihieecagf',
                    'updated_by': 'bghfciaafe',
                },
                'update': {
                    'model_name': 'caficfigfb',
                    'litellm_params': Json({'bfidgijfjc': True}),
                    'created_by': 'ihieecagf',
                    'updated_by': 'bghfciaafe',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.LiteLLM_ProxyModelTableUpdateManyMutationInput,
        where: types.LiteLLM_ProxyModelTableWhereInput,
    ) -> int:
        """Update multiple LiteLLM_ProxyModelTable records

        Parameters
        ----------
        data
            LiteLLM_ProxyModelTable data to update the selected LiteLLM_ProxyModelTable records to
        where
            Filter to select the LiteLLM_ProxyModelTable records to update

        Returns
        -------
        int
            The total number of LiteLLM_ProxyModelTable records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all LiteLLM_ProxyModelTable records
        total = await LiteLLM_ProxyModelTable.prisma().update_many(
            data={
                'created_by': 'fcbichhci'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_ProxyModelTableWhereInput] = None,
        cursor: Optional[types.LiteLLM_ProxyModelTableWhereUniqueInput] = None,
    ) -> int:
        """Count the number of LiteLLM_ProxyModelTable records present in the database

        Parameters
        ----------
        select
            Select the LiteLLM_ProxyModelTable fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            LiteLLM_ProxyModelTable filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.LiteLLM_ProxyModelTableCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await LiteLLM_ProxyModelTable.prisma().count()

        # results: prisma.types.LiteLLM_ProxyModelTableCountAggregateOutput
        results = await LiteLLM_ProxyModelTable.prisma().count(
            select={
                '_all': True,
                'updated_at': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.LiteLLM_ProxyModelTableCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_ProxyModelTableWhereInput] = None,
        cursor: Optional[types.LiteLLM_ProxyModelTableWhereUniqueInput] = None,
    ) -> types.LiteLLM_ProxyModelTableCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.LiteLLM_ProxyModelTableCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_ProxyModelTableWhereInput] = None,
        cursor: Optional[types.LiteLLM_ProxyModelTableWhereUniqueInput] = None,
    ) -> Union[int, types.LiteLLM_ProxyModelTableCountAggregateOutput]:
        """Count the number of LiteLLM_ProxyModelTable records present in the database

        Parameters
        ----------
        select
            Select the LiteLLM_ProxyModelTable fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            LiteLLM_ProxyModelTable filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.LiteLLM_ProxyModelTableCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await LiteLLM_ProxyModelTable.prisma().count()

        # results: prisma.types.LiteLLM_ProxyModelTableCountAggregateOutput
        results = await LiteLLM_ProxyModelTable.prisma().count(
            select={
                '_all': True,
                'updated_by': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.LiteLLM_ProxyModelTableCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.LiteLLM_ProxyModelTableWhereInput] = None
    ) -> int:
        """Delete multiple LiteLLM_ProxyModelTable records.

        Parameters
        ----------
        where
            Optional LiteLLM_ProxyModelTable filter to find the records to be deleted

        Returns
        -------
        int
            The total number of LiteLLM_ProxyModelTable records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all LiteLLM_ProxyModelTable records
        total = await LiteLLM_ProxyModelTable.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.LiteLLM_ProxyModelTableScalarFieldKeys'],
        *,
        where: Optional['types.LiteLLM_ProxyModelTableWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.LiteLLM_ProxyModelTableAvgAggregateInput'] = None,
        sum: Optional['types.LiteLLM_ProxyModelTableSumAggregateInput'] = None,
        min: Optional['types.LiteLLM_ProxyModelTableMinAggregateInput'] = None,
        max: Optional['types.LiteLLM_ProxyModelTableMaxAggregateInput'] = None,
        having: Optional['types.LiteLLM_ProxyModelTableScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.LiteLLM_ProxyModelTableCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.LiteLLM_ProxyModelTableScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.LiteLLM_ProxyModelTableScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.LiteLLM_ProxyModelTableGroupByOutput']:
        """Group LiteLLM_ProxyModelTable records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar LiteLLM_ProxyModelTable fields to group records by
        where
            LiteLLM_ProxyModelTable filter to select records
        take
            Limit the maximum number of LiteLLM_ProxyModelTable records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.LiteLLM_ProxyModelTableGroupByOutput]
            A list of dictionaries representing the LiteLLM_ProxyModelTable record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group LiteLLM_ProxyModelTable records by model_id values
        # and count how many records are in each group
        results = await LiteLLM_ProxyModelTable.prisma().group_by(
            ['model_id'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class LiteLLM_OrganizationTableActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: 'Client', model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.LiteLLM_OrganizationTable]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await LiteLLM_OrganizationTable.prisma().query_raw(
            'SELECT * FROM LiteLLM_OrganizationTable WHERE organization_id = $1',
            'bcggadccgf',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.LiteLLM_OrganizationTable
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await LiteLLM_OrganizationTable.prisma().query_first(
            'SELECT * FROM LiteLLM_OrganizationTable WHERE organization_alias = $1',
            'jdcfdcgc',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.LiteLLM_OrganizationTableCreateInput,
        include: Optional[types.LiteLLM_OrganizationTableInclude] = None
    ) -> _PrismaModelT:
        """Create a new LiteLLM_OrganizationTable record.

        Parameters
        ----------
        data
            LiteLLM_OrganizationTable record data
        include
            Specifies which relations should be loaded on the returned LiteLLM_OrganizationTable model

        Returns
        -------
        prisma.models.LiteLLM_OrganizationTable
            The created LiteLLM_OrganizationTable record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a LiteLLM_OrganizationTable record from just the required fields
        litellm_organizationtable = await LiteLLM_OrganizationTable.prisma().create(
            data={
                # data to create a LiteLLM_OrganizationTable record
                'organization_alias': 'cafdaehjid',
                'budget_id': 'gifdddbia',
                'created_by': 'bchehecef',
                'updated_by': 'jeijcbhfe',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.LiteLLM_OrganizationTableCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple LiteLLM_OrganizationTable records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of LiteLLM_OrganizationTable record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await LiteLLM_OrganizationTable.prisma().create_many(
            data=[
                {
                    # data to create a LiteLLM_OrganizationTable record
                    'organization_alias': 'bjgejjabff',
                    'budget_id': 'bcciijbibg',
                    'created_by': 'cffcachfd',
                    'updated_by': 'bccdfhdigc',
                },
                {
                    # data to create a LiteLLM_OrganizationTable record
                    'organization_alias': 'febcgjbfj',
                    'budget_id': 'bageiegghg',
                    'created_by': 'faidicegb',
                    'updated_by': 'bacecgfhbe',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.LiteLLM_OrganizationTableWhereUniqueInput,
        include: Optional[types.LiteLLM_OrganizationTableInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single LiteLLM_OrganizationTable record.

        Parameters
        ----------
        where
            LiteLLM_OrganizationTable filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned LiteLLM_OrganizationTable model

        Returns
        -------
        prisma.models.LiteLLM_OrganizationTable
            The deleted LiteLLM_OrganizationTable record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        litellm_organizationtable = await LiteLLM_OrganizationTable.prisma().delete(
            where={
                'organization_id': 'ihcahiead',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.LiteLLM_OrganizationTableWhereUniqueInput,
        include: Optional[types.LiteLLM_OrganizationTableInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique LiteLLM_OrganizationTable record.

        Parameters
        ----------
        where
            LiteLLM_OrganizationTable filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned LiteLLM_OrganizationTable model

        Returns
        -------
        prisma.models.LiteLLM_OrganizationTable
            The found LiteLLM_OrganizationTable record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        litellm_organizationtable = await LiteLLM_OrganizationTable.prisma().find_unique(
            where={
                'organization_id': 'biheheiajg',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.LiteLLM_OrganizationTableWhereUniqueInput,
        include: Optional[types.LiteLLM_OrganizationTableInclude] = None
    ) -> _PrismaModelT:
        """Find a unique LiteLLM_OrganizationTable record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            LiteLLM_OrganizationTable filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned LiteLLM_OrganizationTable model

        Returns
        -------
        prisma.models.LiteLLM_OrganizationTable
            The found LiteLLM_OrganizationTable record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        litellm_organizationtable = await LiteLLM_OrganizationTable.prisma().find_unique_or_raise(
            where={
                'organization_id': 'jbgijghgb',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_OrganizationTableWhereInput] = None,
        cursor: Optional[types.LiteLLM_OrganizationTableWhereUniqueInput] = None,
        include: Optional[types.LiteLLM_OrganizationTableInclude] = None,
        order: Optional[Union[types.LiteLLM_OrganizationTableOrderByInput, List[types.LiteLLM_OrganizationTableOrderByInput]]] = None,
        distinct: Optional[List[types.LiteLLM_OrganizationTableScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple LiteLLM_OrganizationTable records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of LiteLLM_OrganizationTable records returned
        skip
            Ignore the first N results
        where
            LiteLLM_OrganizationTable filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned LiteLLM_OrganizationTable model
        order
            Order the returned LiteLLM_OrganizationTable records by any field
        distinct
            Filter LiteLLM_OrganizationTable records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.LiteLLM_OrganizationTable]
            The list of all LiteLLM_OrganizationTable records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 LiteLLM_OrganizationTable records
        litellm_organizationtables = await LiteLLM_OrganizationTable.prisma().find_many(take=10)

        # find the first 5 LiteLLM_OrganizationTable records ordered by the budget_id field
        litellm_organizationtables = await LiteLLM_OrganizationTable.prisma().find_many(
            take=5,
            order={
                'budget_id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_OrganizationTableWhereInput] = None,
        cursor: Optional[types.LiteLLM_OrganizationTableWhereUniqueInput] = None,
        include: Optional[types.LiteLLM_OrganizationTableInclude] = None,
        order: Optional[Union[types.LiteLLM_OrganizationTableOrderByInput, List[types.LiteLLM_OrganizationTableOrderByInput]]] = None,
        distinct: Optional[List[types.LiteLLM_OrganizationTableScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single LiteLLM_OrganizationTable record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            LiteLLM_OrganizationTable filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned LiteLLM_OrganizationTable model
        order
            Order the returned LiteLLM_OrganizationTable records by any field
        distinct
            Filter LiteLLM_OrganizationTable records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.LiteLLM_OrganizationTable
            The first LiteLLM_OrganizationTable record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second LiteLLM_OrganizationTable record ordered by the metadata field
        litellm_organizationtable = await LiteLLM_OrganizationTable.prisma().find_first(
            skip=1,
            order={
                'metadata': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_OrganizationTableWhereInput] = None,
        cursor: Optional[types.LiteLLM_OrganizationTableWhereUniqueInput] = None,
        include: Optional[types.LiteLLM_OrganizationTableInclude] = None,
        order: Optional[Union[types.LiteLLM_OrganizationTableOrderByInput, List[types.LiteLLM_OrganizationTableOrderByInput]]] = None,
        distinct: Optional[List[types.LiteLLM_OrganizationTableScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single LiteLLM_OrganizationTable record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            LiteLLM_OrganizationTable filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned LiteLLM_OrganizationTable model
        order
            Order the returned LiteLLM_OrganizationTable records by any field
        distinct
            Filter LiteLLM_OrganizationTable records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.LiteLLM_OrganizationTable
            The first LiteLLM_OrganizationTable record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second LiteLLM_OrganizationTable record ordered by the models field
        litellm_organizationtable = await LiteLLM_OrganizationTable.prisma().find_first_or_raise(
            skip=1,
            order={
                'models': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.LiteLLM_OrganizationTableUpdateInput,
        where: types.LiteLLM_OrganizationTableWhereUniqueInput,
        include: Optional[types.LiteLLM_OrganizationTableInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single LiteLLM_OrganizationTable record.

        Parameters
        ----------
        data
            LiteLLM_OrganizationTable record data specifying what to update
        where
            LiteLLM_OrganizationTable filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned LiteLLM_OrganizationTable model

        Returns
        -------
        prisma.models.LiteLLM_OrganizationTable
            The updated LiteLLM_OrganizationTable record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        litellm_organizationtable = await LiteLLM_OrganizationTable.prisma().update(
            where={
                'organization_id': 'hgjcghfbi',
            },
            data={
                # data to update the LiteLLM_OrganizationTable record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.LiteLLM_OrganizationTableWhereUniqueInput,
        data: types.LiteLLM_OrganizationTableUpsertInput,
        include: Optional[types.LiteLLM_OrganizationTableInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            LiteLLM_OrganizationTable filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned LiteLLM_OrganizationTable model

        Returns
        -------
        prisma.models.LiteLLM_OrganizationTable
            The created or updated LiteLLM_OrganizationTable record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        litellm_organizationtable = await LiteLLM_OrganizationTable.prisma().upsert(
            where={
                'organization_id': 'icadbcehj',
            },
            data={
                'create': {
                    'organization_id': 'icadbcehj',
                    'organization_alias': 'febcgjbfj',
                    'budget_id': 'bageiegghg',
                    'created_by': 'faidicegb',
                    'updated_by': 'bacecgfhbe',
                },
                'update': {
                    'organization_alias': 'febcgjbfj',
                    'budget_id': 'bageiegghg',
                    'created_by': 'faidicegb',
                    'updated_by': 'bacecgfhbe',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.LiteLLM_OrganizationTableUpdateManyMutationInput,
        where: types.LiteLLM_OrganizationTableWhereInput,
    ) -> int:
        """Update multiple LiteLLM_OrganizationTable records

        Parameters
        ----------
        data
            LiteLLM_OrganizationTable data to update the selected LiteLLM_OrganizationTable records to
        where
            Filter to select the LiteLLM_OrganizationTable records to update

        Returns
        -------
        int
            The total number of LiteLLM_OrganizationTable records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all LiteLLM_OrganizationTable records
        total = await LiteLLM_OrganizationTable.prisma().update_many(
            data={
                'spend': 92728044.34485
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_OrganizationTableWhereInput] = None,
        cursor: Optional[types.LiteLLM_OrganizationTableWhereUniqueInput] = None,
    ) -> int:
        """Count the number of LiteLLM_OrganizationTable records present in the database

        Parameters
        ----------
        select
            Select the LiteLLM_OrganizationTable fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            LiteLLM_OrganizationTable filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.LiteLLM_OrganizationTableCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await LiteLLM_OrganizationTable.prisma().count()

        # results: prisma.types.LiteLLM_OrganizationTableCountAggregateOutput
        results = await LiteLLM_OrganizationTable.prisma().count(
            select={
                '_all': True,
                'model_spend': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.LiteLLM_OrganizationTableCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_OrganizationTableWhereInput] = None,
        cursor: Optional[types.LiteLLM_OrganizationTableWhereUniqueInput] = None,
    ) -> types.LiteLLM_OrganizationTableCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.LiteLLM_OrganizationTableCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_OrganizationTableWhereInput] = None,
        cursor: Optional[types.LiteLLM_OrganizationTableWhereUniqueInput] = None,
    ) -> Union[int, types.LiteLLM_OrganizationTableCountAggregateOutput]:
        """Count the number of LiteLLM_OrganizationTable records present in the database

        Parameters
        ----------
        select
            Select the LiteLLM_OrganizationTable fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            LiteLLM_OrganizationTable filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.LiteLLM_OrganizationTableCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await LiteLLM_OrganizationTable.prisma().count()

        # results: prisma.types.LiteLLM_OrganizationTableCountAggregateOutput
        results = await LiteLLM_OrganizationTable.prisma().count(
            select={
                '_all': True,
                'object_permission_id': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.LiteLLM_OrganizationTableCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.LiteLLM_OrganizationTableWhereInput] = None
    ) -> int:
        """Delete multiple LiteLLM_OrganizationTable records.

        Parameters
        ----------
        where
            Optional LiteLLM_OrganizationTable filter to find the records to be deleted

        Returns
        -------
        int
            The total number of LiteLLM_OrganizationTable records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all LiteLLM_OrganizationTable records
        total = await LiteLLM_OrganizationTable.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.LiteLLM_OrganizationTableScalarFieldKeys'],
        *,
        where: Optional['types.LiteLLM_OrganizationTableWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.LiteLLM_OrganizationTableAvgAggregateInput'] = None,
        sum: Optional['types.LiteLLM_OrganizationTableSumAggregateInput'] = None,
        min: Optional['types.LiteLLM_OrganizationTableMinAggregateInput'] = None,
        max: Optional['types.LiteLLM_OrganizationTableMaxAggregateInput'] = None,
        having: Optional['types.LiteLLM_OrganizationTableScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.LiteLLM_OrganizationTableCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.LiteLLM_OrganizationTableScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.LiteLLM_OrganizationTableScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.LiteLLM_OrganizationTableGroupByOutput']:
        """Group LiteLLM_OrganizationTable records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar LiteLLM_OrganizationTable fields to group records by
        where
            LiteLLM_OrganizationTable filter to select records
        take
            Limit the maximum number of LiteLLM_OrganizationTable records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.LiteLLM_OrganizationTableGroupByOutput]
            A list of dictionaries representing the LiteLLM_OrganizationTable record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group LiteLLM_OrganizationTable records by created_at values
        # and count how many records are in each group
        results = await LiteLLM_OrganizationTable.prisma().group_by(
            ['created_at'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class LiteLLM_ModelTableActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: 'Client', model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.LiteLLM_ModelTable]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await LiteLLM_ModelTable.prisma().query_raw(
            'SELECT * FROM LiteLLM_ModelTable WHERE id = $1',
            1121741130,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.LiteLLM_ModelTable
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await LiteLLM_ModelTable.prisma().query_first(
            'SELECT * FROM LiteLLM_ModelTable WHERE model_aliases = $1',
            Json({'bejfijgcfb': True}),
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.LiteLLM_ModelTableCreateInput,
        include: Optional[types.LiteLLM_ModelTableInclude] = None
    ) -> _PrismaModelT:
        """Create a new LiteLLM_ModelTable record.

        Parameters
        ----------
        data
            LiteLLM_ModelTable record data
        include
            Specifies which relations should be loaded on the returned LiteLLM_ModelTable model

        Returns
        -------
        prisma.models.LiteLLM_ModelTable
            The created LiteLLM_ModelTable record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a LiteLLM_ModelTable record from just the required fields
        litellm_modeltable = await LiteLLM_ModelTable.prisma().create(
            data={
                # data to create a LiteLLM_ModelTable record
                'created_by': 'caifcbgii',
                'updated_by': 'igaibbfgj',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.LiteLLM_ModelTableCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple LiteLLM_ModelTable records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of LiteLLM_ModelTable record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await LiteLLM_ModelTable.prisma().create_many(
            data=[
                {
                    # data to create a LiteLLM_ModelTable record
                    'created_by': 'bggajdcbbi',
                    'updated_by': 'fcfhgbjed',
                },
                {
                    # data to create a LiteLLM_ModelTable record
                    'created_by': 'hdgcajhjg',
                    'updated_by': 'ejdjahicb',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.LiteLLM_ModelTableWhereUniqueInput,
        include: Optional[types.LiteLLM_ModelTableInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single LiteLLM_ModelTable record.

        Parameters
        ----------
        where
            LiteLLM_ModelTable filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned LiteLLM_ModelTable model

        Returns
        -------
        prisma.models.LiteLLM_ModelTable
            The deleted LiteLLM_ModelTable record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        litellm_modeltable = await LiteLLM_ModelTable.prisma().delete(
            where={
                'id': 639686562,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.LiteLLM_ModelTableWhereUniqueInput,
        include: Optional[types.LiteLLM_ModelTableInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique LiteLLM_ModelTable record.

        Parameters
        ----------
        where
            LiteLLM_ModelTable filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned LiteLLM_ModelTable model

        Returns
        -------
        prisma.models.LiteLLM_ModelTable
            The found LiteLLM_ModelTable record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        litellm_modeltable = await LiteLLM_ModelTable.prisma().find_unique(
            where={
                'id': 654007347,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.LiteLLM_ModelTableWhereUniqueInput,
        include: Optional[types.LiteLLM_ModelTableInclude] = None
    ) -> _PrismaModelT:
        """Find a unique LiteLLM_ModelTable record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            LiteLLM_ModelTable filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned LiteLLM_ModelTable model

        Returns
        -------
        prisma.models.LiteLLM_ModelTable
            The found LiteLLM_ModelTable record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        litellm_modeltable = await LiteLLM_ModelTable.prisma().find_unique_or_raise(
            where={
                'id': 1905261552,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_ModelTableWhereInput] = None,
        cursor: Optional[types.LiteLLM_ModelTableWhereUniqueInput] = None,
        include: Optional[types.LiteLLM_ModelTableInclude] = None,
        order: Optional[Union[types.LiteLLM_ModelTableOrderByInput, List[types.LiteLLM_ModelTableOrderByInput]]] = None,
        distinct: Optional[List[types.LiteLLM_ModelTableScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple LiteLLM_ModelTable records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of LiteLLM_ModelTable records returned
        skip
            Ignore the first N results
        where
            LiteLLM_ModelTable filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned LiteLLM_ModelTable model
        order
            Order the returned LiteLLM_ModelTable records by any field
        distinct
            Filter LiteLLM_ModelTable records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.LiteLLM_ModelTable]
            The list of all LiteLLM_ModelTable records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 LiteLLM_ModelTable records
        litellm_modeltables = await LiteLLM_ModelTable.prisma().find_many(take=10)

        # find the first 5 LiteLLM_ModelTable records ordered by the created_at field
        litellm_modeltables = await LiteLLM_ModelTable.prisma().find_many(
            take=5,
            order={
                'created_at': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_ModelTableWhereInput] = None,
        cursor: Optional[types.LiteLLM_ModelTableWhereUniqueInput] = None,
        include: Optional[types.LiteLLM_ModelTableInclude] = None,
        order: Optional[Union[types.LiteLLM_ModelTableOrderByInput, List[types.LiteLLM_ModelTableOrderByInput]]] = None,
        distinct: Optional[List[types.LiteLLM_ModelTableScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single LiteLLM_ModelTable record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            LiteLLM_ModelTable filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned LiteLLM_ModelTable model
        order
            Order the returned LiteLLM_ModelTable records by any field
        distinct
            Filter LiteLLM_ModelTable records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.LiteLLM_ModelTable
            The first LiteLLM_ModelTable record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second LiteLLM_ModelTable record ordered by the created_by field
        litellm_modeltable = await LiteLLM_ModelTable.prisma().find_first(
            skip=1,
            order={
                'created_by': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_ModelTableWhereInput] = None,
        cursor: Optional[types.LiteLLM_ModelTableWhereUniqueInput] = None,
        include: Optional[types.LiteLLM_ModelTableInclude] = None,
        order: Optional[Union[types.LiteLLM_ModelTableOrderByInput, List[types.LiteLLM_ModelTableOrderByInput]]] = None,
        distinct: Optional[List[types.LiteLLM_ModelTableScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single LiteLLM_ModelTable record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            LiteLLM_ModelTable filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned LiteLLM_ModelTable model
        order
            Order the returned LiteLLM_ModelTable records by any field
        distinct
            Filter LiteLLM_ModelTable records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.LiteLLM_ModelTable
            The first LiteLLM_ModelTable record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second LiteLLM_ModelTable record ordered by the updated_at field
        litellm_modeltable = await LiteLLM_ModelTable.prisma().find_first_or_raise(
            skip=1,
            order={
                'updated_at': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.LiteLLM_ModelTableUpdateInput,
        where: types.LiteLLM_ModelTableWhereUniqueInput,
        include: Optional[types.LiteLLM_ModelTableInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single LiteLLM_ModelTable record.

        Parameters
        ----------
        data
            LiteLLM_ModelTable record data specifying what to update
        where
            LiteLLM_ModelTable filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned LiteLLM_ModelTable model

        Returns
        -------
        prisma.models.LiteLLM_ModelTable
            The updated LiteLLM_ModelTable record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        litellm_modeltable = await LiteLLM_ModelTable.prisma().update(
            where={
                'id': 78746985,
            },
            data={
                # data to update the LiteLLM_ModelTable record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.LiteLLM_ModelTableWhereUniqueInput,
        data: types.LiteLLM_ModelTableUpsertInput,
        include: Optional[types.LiteLLM_ModelTableInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            LiteLLM_ModelTable filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned LiteLLM_ModelTable model

        Returns
        -------
        prisma.models.LiteLLM_ModelTable
            The created or updated LiteLLM_ModelTable record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        litellm_modeltable = await LiteLLM_ModelTable.prisma().upsert(
            where={
                'id': 1398328302,
            },
            data={
                'create': {
                    'id': 1398328302,
                    'created_by': 'hdgcajhjg',
                    'updated_by': 'ejdjahicb',
                },
                'update': {
                    'created_by': 'hdgcajhjg',
                    'updated_by': 'ejdjahicb',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.LiteLLM_ModelTableUpdateManyMutationInput,
        where: types.LiteLLM_ModelTableWhereInput,
    ) -> int:
        """Update multiple LiteLLM_ModelTable records

        Parameters
        ----------
        data
            LiteLLM_ModelTable data to update the selected LiteLLM_ModelTable records to
        where
            Filter to select the LiteLLM_ModelTable records to update

        Returns
        -------
        int
            The total number of LiteLLM_ModelTable records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all LiteLLM_ModelTable records
        total = await LiteLLM_ModelTable.prisma().update_many(
            data={
                'updated_by': 'ifgaaagff'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_ModelTableWhereInput] = None,
        cursor: Optional[types.LiteLLM_ModelTableWhereUniqueInput] = None,
    ) -> int:
        """Count the number of LiteLLM_ModelTable records present in the database

        Parameters
        ----------
        select
            Select the LiteLLM_ModelTable fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            LiteLLM_ModelTable filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.LiteLLM_ModelTableCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await LiteLLM_ModelTable.prisma().count()

        # results: prisma.types.LiteLLM_ModelTableCountAggregateOutput
        results = await LiteLLM_ModelTable.prisma().count(
            select={
                '_all': True,
                'id': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.LiteLLM_ModelTableCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_ModelTableWhereInput] = None,
        cursor: Optional[types.LiteLLM_ModelTableWhereUniqueInput] = None,
    ) -> types.LiteLLM_ModelTableCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.LiteLLM_ModelTableCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_ModelTableWhereInput] = None,
        cursor: Optional[types.LiteLLM_ModelTableWhereUniqueInput] = None,
    ) -> Union[int, types.LiteLLM_ModelTableCountAggregateOutput]:
        """Count the number of LiteLLM_ModelTable records present in the database

        Parameters
        ----------
        select
            Select the LiteLLM_ModelTable fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            LiteLLM_ModelTable filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.LiteLLM_ModelTableCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await LiteLLM_ModelTable.prisma().count()

        # results: prisma.types.LiteLLM_ModelTableCountAggregateOutput
        results = await LiteLLM_ModelTable.prisma().count(
            select={
                '_all': True,
                'model_aliases': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.LiteLLM_ModelTableCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.LiteLLM_ModelTableWhereInput] = None
    ) -> int:
        """Delete multiple LiteLLM_ModelTable records.

        Parameters
        ----------
        where
            Optional LiteLLM_ModelTable filter to find the records to be deleted

        Returns
        -------
        int
            The total number of LiteLLM_ModelTable records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all LiteLLM_ModelTable records
        total = await LiteLLM_ModelTable.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.LiteLLM_ModelTableScalarFieldKeys'],
        *,
        where: Optional['types.LiteLLM_ModelTableWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.LiteLLM_ModelTableAvgAggregateInput'] = None,
        sum: Optional['types.LiteLLM_ModelTableSumAggregateInput'] = None,
        min: Optional['types.LiteLLM_ModelTableMinAggregateInput'] = None,
        max: Optional['types.LiteLLM_ModelTableMaxAggregateInput'] = None,
        having: Optional['types.LiteLLM_ModelTableScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.LiteLLM_ModelTableCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.LiteLLM_ModelTableScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.LiteLLM_ModelTableScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.LiteLLM_ModelTableGroupByOutput']:
        """Group LiteLLM_ModelTable records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar LiteLLM_ModelTable fields to group records by
        where
            LiteLLM_ModelTable filter to select records
        take
            Limit the maximum number of LiteLLM_ModelTable records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.LiteLLM_ModelTableGroupByOutput]
            A list of dictionaries representing the LiteLLM_ModelTable record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group LiteLLM_ModelTable records by created_at values
        # and count how many records are in each group
        results = await LiteLLM_ModelTable.prisma().group_by(
            ['created_at'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class LiteLLM_TeamTableActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: 'Client', model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.LiteLLM_TeamTable]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await LiteLLM_TeamTable.prisma().query_raw(
            'SELECT * FROM LiteLLM_TeamTable WHERE team_id = $1',
            'befcddgjce',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.LiteLLM_TeamTable
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await LiteLLM_TeamTable.prisma().query_first(
            'SELECT * FROM LiteLLM_TeamTable WHERE team_alias = $1',
            'bfhdbjjgfd',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.LiteLLM_TeamTableCreateInput,
        include: Optional[types.LiteLLM_TeamTableInclude] = None
    ) -> _PrismaModelT:
        """Create a new LiteLLM_TeamTable record.

        Parameters
        ----------
        data
            LiteLLM_TeamTable record data
        include
            Specifies which relations should be loaded on the returned LiteLLM_TeamTable model

        Returns
        -------
        prisma.models.LiteLLM_TeamTable
            The created LiteLLM_TeamTable record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a LiteLLM_TeamTable record from just the required fields
        litellm_teamtable = await LiteLLM_TeamTable.prisma().create(
            data={
                # data to create a LiteLLM_TeamTable record
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.LiteLLM_TeamTableCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple LiteLLM_TeamTable records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of LiteLLM_TeamTable record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await LiteLLM_TeamTable.prisma().create_many(
            data=[
                {
                    # data to create a LiteLLM_TeamTable record
                },
                {
                    # data to create a LiteLLM_TeamTable record
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.LiteLLM_TeamTableWhereUniqueInput,
        include: Optional[types.LiteLLM_TeamTableInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single LiteLLM_TeamTable record.

        Parameters
        ----------
        where
            LiteLLM_TeamTable filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned LiteLLM_TeamTable model

        Returns
        -------
        prisma.models.LiteLLM_TeamTable
            The deleted LiteLLM_TeamTable record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        litellm_teamtable = await LiteLLM_TeamTable.prisma().delete(
            where={
                'team_id': 'cabdjadaji',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.LiteLLM_TeamTableWhereUniqueInput,
        include: Optional[types.LiteLLM_TeamTableInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique LiteLLM_TeamTable record.

        Parameters
        ----------
        where
            LiteLLM_TeamTable filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned LiteLLM_TeamTable model

        Returns
        -------
        prisma.models.LiteLLM_TeamTable
            The found LiteLLM_TeamTable record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        litellm_teamtable = await LiteLLM_TeamTable.prisma().find_unique(
            where={
                'team_id': 'faajgfadf',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.LiteLLM_TeamTableWhereUniqueInput,
        include: Optional[types.LiteLLM_TeamTableInclude] = None
    ) -> _PrismaModelT:
        """Find a unique LiteLLM_TeamTable record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            LiteLLM_TeamTable filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned LiteLLM_TeamTable model

        Returns
        -------
        prisma.models.LiteLLM_TeamTable
            The found LiteLLM_TeamTable record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        litellm_teamtable = await LiteLLM_TeamTable.prisma().find_unique_or_raise(
            where={
                'team_id': 'biaagcedjc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_TeamTableWhereInput] = None,
        cursor: Optional[types.LiteLLM_TeamTableWhereUniqueInput] = None,
        include: Optional[types.LiteLLM_TeamTableInclude] = None,
        order: Optional[Union[types.LiteLLM_TeamTableOrderByInput, List[types.LiteLLM_TeamTableOrderByInput]]] = None,
        distinct: Optional[List[types.LiteLLM_TeamTableScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple LiteLLM_TeamTable records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of LiteLLM_TeamTable records returned
        skip
            Ignore the first N results
        where
            LiteLLM_TeamTable filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned LiteLLM_TeamTable model
        order
            Order the returned LiteLLM_TeamTable records by any field
        distinct
            Filter LiteLLM_TeamTable records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.LiteLLM_TeamTable]
            The list of all LiteLLM_TeamTable records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 LiteLLM_TeamTable records
        litellm_teamtables = await LiteLLM_TeamTable.prisma().find_many(take=10)

        # find the first 5 LiteLLM_TeamTable records ordered by the organization_id field
        litellm_teamtables = await LiteLLM_TeamTable.prisma().find_many(
            take=5,
            order={
                'organization_id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_TeamTableWhereInput] = None,
        cursor: Optional[types.LiteLLM_TeamTableWhereUniqueInput] = None,
        include: Optional[types.LiteLLM_TeamTableInclude] = None,
        order: Optional[Union[types.LiteLLM_TeamTableOrderByInput, List[types.LiteLLM_TeamTableOrderByInput]]] = None,
        distinct: Optional[List[types.LiteLLM_TeamTableScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single LiteLLM_TeamTable record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            LiteLLM_TeamTable filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned LiteLLM_TeamTable model
        order
            Order the returned LiteLLM_TeamTable records by any field
        distinct
            Filter LiteLLM_TeamTable records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.LiteLLM_TeamTable
            The first LiteLLM_TeamTable record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second LiteLLM_TeamTable record ordered by the object_permission_id field
        litellm_teamtable = await LiteLLM_TeamTable.prisma().find_first(
            skip=1,
            order={
                'object_permission_id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_TeamTableWhereInput] = None,
        cursor: Optional[types.LiteLLM_TeamTableWhereUniqueInput] = None,
        include: Optional[types.LiteLLM_TeamTableInclude] = None,
        order: Optional[Union[types.LiteLLM_TeamTableOrderByInput, List[types.LiteLLM_TeamTableOrderByInput]]] = None,
        distinct: Optional[List[types.LiteLLM_TeamTableScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single LiteLLM_TeamTable record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            LiteLLM_TeamTable filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned LiteLLM_TeamTable model
        order
            Order the returned LiteLLM_TeamTable records by any field
        distinct
            Filter LiteLLM_TeamTable records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.LiteLLM_TeamTable
            The first LiteLLM_TeamTable record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second LiteLLM_TeamTable record ordered by the admins field
        litellm_teamtable = await LiteLLM_TeamTable.prisma().find_first_or_raise(
            skip=1,
            order={
                'admins': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.LiteLLM_TeamTableUpdateInput,
        where: types.LiteLLM_TeamTableWhereUniqueInput,
        include: Optional[types.LiteLLM_TeamTableInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single LiteLLM_TeamTable record.

        Parameters
        ----------
        data
            LiteLLM_TeamTable record data specifying what to update
        where
            LiteLLM_TeamTable filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned LiteLLM_TeamTable model

        Returns
        -------
        prisma.models.LiteLLM_TeamTable
            The updated LiteLLM_TeamTable record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        litellm_teamtable = await LiteLLM_TeamTable.prisma().update(
            where={
                'team_id': 'cahhaghecf',
            },
            data={
                # data to update the LiteLLM_TeamTable record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.LiteLLM_TeamTableWhereUniqueInput,
        data: types.LiteLLM_TeamTableUpsertInput,
        include: Optional[types.LiteLLM_TeamTableInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            LiteLLM_TeamTable filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned LiteLLM_TeamTable model

        Returns
        -------
        prisma.models.LiteLLM_TeamTable
            The created or updated LiteLLM_TeamTable record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        litellm_teamtable = await LiteLLM_TeamTable.prisma().upsert(
            where={
                'team_id': 'bghcbbcidi',
            },
            data={
                'create': {
                    'team_id': 'bghcbbcidi',
                },
                'update': {
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.LiteLLM_TeamTableUpdateManyMutationInput,
        where: types.LiteLLM_TeamTableWhereInput,
    ) -> int:
        """Update multiple LiteLLM_TeamTable records

        Parameters
        ----------
        data
            LiteLLM_TeamTable data to update the selected LiteLLM_TeamTable records to
        where
            Filter to select the LiteLLM_TeamTable records to update

        Returns
        -------
        int
            The total number of LiteLLM_TeamTable records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all LiteLLM_TeamTable records
        total = await LiteLLM_TeamTable.prisma().update_many(
            data={
                'members': ['jcgghhgdj']
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_TeamTableWhereInput] = None,
        cursor: Optional[types.LiteLLM_TeamTableWhereUniqueInput] = None,
    ) -> int:
        """Count the number of LiteLLM_TeamTable records present in the database

        Parameters
        ----------
        select
            Select the LiteLLM_TeamTable fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            LiteLLM_TeamTable filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.LiteLLM_TeamTableCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await LiteLLM_TeamTable.prisma().count()

        # results: prisma.types.LiteLLM_TeamTableCountAggregateOutput
        results = await LiteLLM_TeamTable.prisma().count(
            select={
                '_all': True,
                'members_with_roles': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.LiteLLM_TeamTableCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_TeamTableWhereInput] = None,
        cursor: Optional[types.LiteLLM_TeamTableWhereUniqueInput] = None,
    ) -> types.LiteLLM_TeamTableCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.LiteLLM_TeamTableCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_TeamTableWhereInput] = None,
        cursor: Optional[types.LiteLLM_TeamTableWhereUniqueInput] = None,
    ) -> Union[int, types.LiteLLM_TeamTableCountAggregateOutput]:
        """Count the number of LiteLLM_TeamTable records present in the database

        Parameters
        ----------
        select
            Select the LiteLLM_TeamTable fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            LiteLLM_TeamTable filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.LiteLLM_TeamTableCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await LiteLLM_TeamTable.prisma().count()

        # results: prisma.types.LiteLLM_TeamTableCountAggregateOutput
        results = await LiteLLM_TeamTable.prisma().count(
            select={
                '_all': True,
                'metadata': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.LiteLLM_TeamTableCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.LiteLLM_TeamTableWhereInput] = None
    ) -> int:
        """Delete multiple LiteLLM_TeamTable records.

        Parameters
        ----------
        where
            Optional LiteLLM_TeamTable filter to find the records to be deleted

        Returns
        -------
        int
            The total number of LiteLLM_TeamTable records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all LiteLLM_TeamTable records
        total = await LiteLLM_TeamTable.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.LiteLLM_TeamTableScalarFieldKeys'],
        *,
        where: Optional['types.LiteLLM_TeamTableWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.LiteLLM_TeamTableAvgAggregateInput'] = None,
        sum: Optional['types.LiteLLM_TeamTableSumAggregateInput'] = None,
        min: Optional['types.LiteLLM_TeamTableMinAggregateInput'] = None,
        max: Optional['types.LiteLLM_TeamTableMaxAggregateInput'] = None,
        having: Optional['types.LiteLLM_TeamTableScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.LiteLLM_TeamTableCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.LiteLLM_TeamTableScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.LiteLLM_TeamTableScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.LiteLLM_TeamTableGroupByOutput']:
        """Group LiteLLM_TeamTable records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar LiteLLM_TeamTable fields to group records by
        where
            LiteLLM_TeamTable filter to select records
        take
            Limit the maximum number of LiteLLM_TeamTable records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.LiteLLM_TeamTableGroupByOutput]
            A list of dictionaries representing the LiteLLM_TeamTable record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group LiteLLM_TeamTable records by max_budget values
        # and count how many records are in each group
        results = await LiteLLM_TeamTable.prisma().group_by(
            ['max_budget'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class LiteLLM_UserTableActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: 'Client', model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.LiteLLM_UserTable]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await LiteLLM_UserTable.prisma().query_raw(
            'SELECT * FROM LiteLLM_UserTable WHERE user_id = $1',
            'beehgcebbg',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.LiteLLM_UserTable
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await LiteLLM_UserTable.prisma().query_first(
            'SELECT * FROM LiteLLM_UserTable WHERE user_alias = $1',
            'bhdiaidiaf',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.LiteLLM_UserTableCreateInput,
        include: Optional[types.LiteLLM_UserTableInclude] = None
    ) -> _PrismaModelT:
        """Create a new LiteLLM_UserTable record.

        Parameters
        ----------
        data
            LiteLLM_UserTable record data
        include
            Specifies which relations should be loaded on the returned LiteLLM_UserTable model

        Returns
        -------
        prisma.models.LiteLLM_UserTable
            The created LiteLLM_UserTable record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a LiteLLM_UserTable record from just the required fields
        litellm_usertable = await LiteLLM_UserTable.prisma().create(
            data={
                # data to create a LiteLLM_UserTable record
                'user_id': 'deajegcfi',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.LiteLLM_UserTableCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple LiteLLM_UserTable records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of LiteLLM_UserTable record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await LiteLLM_UserTable.prisma().create_many(
            data=[
                {
                    # data to create a LiteLLM_UserTable record
                    'user_id': 'gabahhhjf',
                },
                {
                    # data to create a LiteLLM_UserTable record
                    'user_id': 'cjagadcjg',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.LiteLLM_UserTableWhereUniqueInput,
        include: Optional[types.LiteLLM_UserTableInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single LiteLLM_UserTable record.

        Parameters
        ----------
        where
            LiteLLM_UserTable filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned LiteLLM_UserTable model

        Returns
        -------
        prisma.models.LiteLLM_UserTable
            The deleted LiteLLM_UserTable record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        litellm_usertable = await LiteLLM_UserTable.prisma().delete(
            where={
                'user_id': 'bifficggej',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.LiteLLM_UserTableWhereUniqueInput,
        include: Optional[types.LiteLLM_UserTableInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique LiteLLM_UserTable record.

        Parameters
        ----------
        where
            LiteLLM_UserTable filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned LiteLLM_UserTable model

        Returns
        -------
        prisma.models.LiteLLM_UserTable
            The found LiteLLM_UserTable record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        litellm_usertable = await LiteLLM_UserTable.prisma().find_unique(
            where={
                'user_id': 'bgbbaajbic',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.LiteLLM_UserTableWhereUniqueInput,
        include: Optional[types.LiteLLM_UserTableInclude] = None
    ) -> _PrismaModelT:
        """Find a unique LiteLLM_UserTable record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            LiteLLM_UserTable filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned LiteLLM_UserTable model

        Returns
        -------
        prisma.models.LiteLLM_UserTable
            The found LiteLLM_UserTable record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        litellm_usertable = await LiteLLM_UserTable.prisma().find_unique_or_raise(
            where={
                'user_id': 'eegghdhjb',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_UserTableWhereInput] = None,
        cursor: Optional[types.LiteLLM_UserTableWhereUniqueInput] = None,
        include: Optional[types.LiteLLM_UserTableInclude] = None,
        order: Optional[Union[types.LiteLLM_UserTableOrderByInput, List[types.LiteLLM_UserTableOrderByInput]]] = None,
        distinct: Optional[List[types.LiteLLM_UserTableScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple LiteLLM_UserTable records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of LiteLLM_UserTable records returned
        skip
            Ignore the first N results
        where
            LiteLLM_UserTable filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned LiteLLM_UserTable model
        order
            Order the returned LiteLLM_UserTable records by any field
        distinct
            Filter LiteLLM_UserTable records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.LiteLLM_UserTable]
            The list of all LiteLLM_UserTable records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 LiteLLM_UserTable records
        litellm_usertables = await LiteLLM_UserTable.prisma().find_many(take=10)

        # find the first 5 LiteLLM_UserTable records ordered by the team_id field
        litellm_usertables = await LiteLLM_UserTable.prisma().find_many(
            take=5,
            order={
                'team_id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_UserTableWhereInput] = None,
        cursor: Optional[types.LiteLLM_UserTableWhereUniqueInput] = None,
        include: Optional[types.LiteLLM_UserTableInclude] = None,
        order: Optional[Union[types.LiteLLM_UserTableOrderByInput, List[types.LiteLLM_UserTableOrderByInput]]] = None,
        distinct: Optional[List[types.LiteLLM_UserTableScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single LiteLLM_UserTable record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            LiteLLM_UserTable filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned LiteLLM_UserTable model
        order
            Order the returned LiteLLM_UserTable records by any field
        distinct
            Filter LiteLLM_UserTable records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.LiteLLM_UserTable
            The first LiteLLM_UserTable record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second LiteLLM_UserTable record ordered by the sso_user_id field
        litellm_usertable = await LiteLLM_UserTable.prisma().find_first(
            skip=1,
            order={
                'sso_user_id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_UserTableWhereInput] = None,
        cursor: Optional[types.LiteLLM_UserTableWhereUniqueInput] = None,
        include: Optional[types.LiteLLM_UserTableInclude] = None,
        order: Optional[Union[types.LiteLLM_UserTableOrderByInput, List[types.LiteLLM_UserTableOrderByInput]]] = None,
        distinct: Optional[List[types.LiteLLM_UserTableScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single LiteLLM_UserTable record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            LiteLLM_UserTable filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned LiteLLM_UserTable model
        order
            Order the returned LiteLLM_UserTable records by any field
        distinct
            Filter LiteLLM_UserTable records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.LiteLLM_UserTable
            The first LiteLLM_UserTable record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second LiteLLM_UserTable record ordered by the organization_id field
        litellm_usertable = await LiteLLM_UserTable.prisma().find_first_or_raise(
            skip=1,
            order={
                'organization_id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.LiteLLM_UserTableUpdateInput,
        where: types.LiteLLM_UserTableWhereUniqueInput,
        include: Optional[types.LiteLLM_UserTableInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single LiteLLM_UserTable record.

        Parameters
        ----------
        data
            LiteLLM_UserTable record data specifying what to update
        where
            LiteLLM_UserTable filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned LiteLLM_UserTable model

        Returns
        -------
        prisma.models.LiteLLM_UserTable
            The updated LiteLLM_UserTable record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        litellm_usertable = await LiteLLM_UserTable.prisma().update(
            where={
                'user_id': 'daafgidjg',
            },
            data={
                # data to update the LiteLLM_UserTable record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.LiteLLM_UserTableWhereUniqueInput,
        data: types.LiteLLM_UserTableUpsertInput,
        include: Optional[types.LiteLLM_UserTableInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            LiteLLM_UserTable filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned LiteLLM_UserTable model

        Returns
        -------
        prisma.models.LiteLLM_UserTable
            The created or updated LiteLLM_UserTable record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        litellm_usertable = await LiteLLM_UserTable.prisma().upsert(
            where={
                'user_id': 'gdcgcgagj',
            },
            data={
                'create': {
                    'user_id': 'gdcgcgagj',
                },
                'update': {
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.LiteLLM_UserTableUpdateManyMutationInput,
        where: types.LiteLLM_UserTableWhereInput,
    ) -> int:
        """Update multiple LiteLLM_UserTable records

        Parameters
        ----------
        data
            LiteLLM_UserTable data to update the selected LiteLLM_UserTable records to
        where
            Filter to select the LiteLLM_UserTable records to update

        Returns
        -------
        int
            The total number of LiteLLM_UserTable records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all LiteLLM_UserTable records
        total = await LiteLLM_UserTable.prisma().update_many(
            data={
                'object_permission_id': 'bhceabbgja'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_UserTableWhereInput] = None,
        cursor: Optional[types.LiteLLM_UserTableWhereUniqueInput] = None,
    ) -> int:
        """Count the number of LiteLLM_UserTable records present in the database

        Parameters
        ----------
        select
            Select the LiteLLM_UserTable fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            LiteLLM_UserTable filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.LiteLLM_UserTableCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await LiteLLM_UserTable.prisma().count()

        # results: prisma.types.LiteLLM_UserTableCountAggregateOutput
        results = await LiteLLM_UserTable.prisma().count(
            select={
                '_all': True,
                'password': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.LiteLLM_UserTableCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_UserTableWhereInput] = None,
        cursor: Optional[types.LiteLLM_UserTableWhereUniqueInput] = None,
    ) -> types.LiteLLM_UserTableCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.LiteLLM_UserTableCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_UserTableWhereInput] = None,
        cursor: Optional[types.LiteLLM_UserTableWhereUniqueInput] = None,
    ) -> Union[int, types.LiteLLM_UserTableCountAggregateOutput]:
        """Count the number of LiteLLM_UserTable records present in the database

        Parameters
        ----------
        select
            Select the LiteLLM_UserTable fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            LiteLLM_UserTable filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.LiteLLM_UserTableCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await LiteLLM_UserTable.prisma().count()

        # results: prisma.types.LiteLLM_UserTableCountAggregateOutput
        results = await LiteLLM_UserTable.prisma().count(
            select={
                '_all': True,
                'teams': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.LiteLLM_UserTableCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.LiteLLM_UserTableWhereInput] = None
    ) -> int:
        """Delete multiple LiteLLM_UserTable records.

        Parameters
        ----------
        where
            Optional LiteLLM_UserTable filter to find the records to be deleted

        Returns
        -------
        int
            The total number of LiteLLM_UserTable records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all LiteLLM_UserTable records
        total = await LiteLLM_UserTable.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.LiteLLM_UserTableScalarFieldKeys'],
        *,
        where: Optional['types.LiteLLM_UserTableWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.LiteLLM_UserTableAvgAggregateInput'] = None,
        sum: Optional['types.LiteLLM_UserTableSumAggregateInput'] = None,
        min: Optional['types.LiteLLM_UserTableMinAggregateInput'] = None,
        max: Optional['types.LiteLLM_UserTableMaxAggregateInput'] = None,
        having: Optional['types.LiteLLM_UserTableScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.LiteLLM_UserTableCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.LiteLLM_UserTableScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.LiteLLM_UserTableScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.LiteLLM_UserTableGroupByOutput']:
        """Group LiteLLM_UserTable records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar LiteLLM_UserTable fields to group records by
        where
            LiteLLM_UserTable filter to select records
        take
            Limit the maximum number of LiteLLM_UserTable records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.LiteLLM_UserTableGroupByOutput]
            A list of dictionaries representing the LiteLLM_UserTable record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group LiteLLM_UserTable records by user_role values
        # and count how many records are in each group
        results = await LiteLLM_UserTable.prisma().group_by(
            ['user_role'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class LiteLLM_ObjectPermissionTableActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: 'Client', model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.LiteLLM_ObjectPermissionTable]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await LiteLLM_ObjectPermissionTable.prisma().query_raw(
            'SELECT * FROM LiteLLM_ObjectPermissionTable WHERE object_permission_id = $1',
            'ehabfhegh',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.LiteLLM_ObjectPermissionTable
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await LiteLLM_ObjectPermissionTable.prisma().query_first(
            'SELECT * FROM LiteLLM_ObjectPermissionTable WHERE mcp_servers = $1',
            ['bcajcajjbc'],
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.LiteLLM_ObjectPermissionTableCreateInput,
        include: Optional[types.LiteLLM_ObjectPermissionTableInclude] = None
    ) -> _PrismaModelT:
        """Create a new LiteLLM_ObjectPermissionTable record.

        Parameters
        ----------
        data
            LiteLLM_ObjectPermissionTable record data
        include
            Specifies which relations should be loaded on the returned LiteLLM_ObjectPermissionTable model

        Returns
        -------
        prisma.models.LiteLLM_ObjectPermissionTable
            The created LiteLLM_ObjectPermissionTable record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a LiteLLM_ObjectPermissionTable record from just the required fields
        litellm_objectpermissiontable = await LiteLLM_ObjectPermissionTable.prisma().create(
            data={
                # data to create a LiteLLM_ObjectPermissionTable record
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.LiteLLM_ObjectPermissionTableCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple LiteLLM_ObjectPermissionTable records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of LiteLLM_ObjectPermissionTable record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await LiteLLM_ObjectPermissionTable.prisma().create_many(
            data=[
                {
                    # data to create a LiteLLM_ObjectPermissionTable record
                },
                {
                    # data to create a LiteLLM_ObjectPermissionTable record
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.LiteLLM_ObjectPermissionTableWhereUniqueInput,
        include: Optional[types.LiteLLM_ObjectPermissionTableInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single LiteLLM_ObjectPermissionTable record.

        Parameters
        ----------
        where
            LiteLLM_ObjectPermissionTable filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned LiteLLM_ObjectPermissionTable model

        Returns
        -------
        prisma.models.LiteLLM_ObjectPermissionTable
            The deleted LiteLLM_ObjectPermissionTable record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        litellm_objectpermissiontable = await LiteLLM_ObjectPermissionTable.prisma().delete(
            where={
                'object_permission_id': 'bfdgheeegf',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.LiteLLM_ObjectPermissionTableWhereUniqueInput,
        include: Optional[types.LiteLLM_ObjectPermissionTableInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique LiteLLM_ObjectPermissionTable record.

        Parameters
        ----------
        where
            LiteLLM_ObjectPermissionTable filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned LiteLLM_ObjectPermissionTable model

        Returns
        -------
        prisma.models.LiteLLM_ObjectPermissionTable
            The found LiteLLM_ObjectPermissionTable record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        litellm_objectpermissiontable = await LiteLLM_ObjectPermissionTable.prisma().find_unique(
            where={
                'object_permission_id': 'ececbijji',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.LiteLLM_ObjectPermissionTableWhereUniqueInput,
        include: Optional[types.LiteLLM_ObjectPermissionTableInclude] = None
    ) -> _PrismaModelT:
        """Find a unique LiteLLM_ObjectPermissionTable record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            LiteLLM_ObjectPermissionTable filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned LiteLLM_ObjectPermissionTable model

        Returns
        -------
        prisma.models.LiteLLM_ObjectPermissionTable
            The found LiteLLM_ObjectPermissionTable record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        litellm_objectpermissiontable = await LiteLLM_ObjectPermissionTable.prisma().find_unique_or_raise(
            where={
                'object_permission_id': 'cbcfgdcdhf',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_ObjectPermissionTableWhereInput] = None,
        cursor: Optional[types.LiteLLM_ObjectPermissionTableWhereUniqueInput] = None,
        include: Optional[types.LiteLLM_ObjectPermissionTableInclude] = None,
        order: Optional[Union[types.LiteLLM_ObjectPermissionTableOrderByInput, List[types.LiteLLM_ObjectPermissionTableOrderByInput]]] = None,
        distinct: Optional[List[types.LiteLLM_ObjectPermissionTableScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple LiteLLM_ObjectPermissionTable records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of LiteLLM_ObjectPermissionTable records returned
        skip
            Ignore the first N results
        where
            LiteLLM_ObjectPermissionTable filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned LiteLLM_ObjectPermissionTable model
        order
            Order the returned LiteLLM_ObjectPermissionTable records by any field
        distinct
            Filter LiteLLM_ObjectPermissionTable records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.LiteLLM_ObjectPermissionTable]
            The list of all LiteLLM_ObjectPermissionTable records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 LiteLLM_ObjectPermissionTable records
        litellm_objectpermissiontables = await LiteLLM_ObjectPermissionTable.prisma().find_many(take=10)

        # find the first 5 LiteLLM_ObjectPermissionTable records ordered by the mcp_access_groups field
        litellm_objectpermissiontables = await LiteLLM_ObjectPermissionTable.prisma().find_many(
            take=5,
            order={
                'mcp_access_groups': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_ObjectPermissionTableWhereInput] = None,
        cursor: Optional[types.LiteLLM_ObjectPermissionTableWhereUniqueInput] = None,
        include: Optional[types.LiteLLM_ObjectPermissionTableInclude] = None,
        order: Optional[Union[types.LiteLLM_ObjectPermissionTableOrderByInput, List[types.LiteLLM_ObjectPermissionTableOrderByInput]]] = None,
        distinct: Optional[List[types.LiteLLM_ObjectPermissionTableScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single LiteLLM_ObjectPermissionTable record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            LiteLLM_ObjectPermissionTable filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned LiteLLM_ObjectPermissionTable model
        order
            Order the returned LiteLLM_ObjectPermissionTable records by any field
        distinct
            Filter LiteLLM_ObjectPermissionTable records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.LiteLLM_ObjectPermissionTable
            The first LiteLLM_ObjectPermissionTable record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second LiteLLM_ObjectPermissionTable record ordered by the vector_stores field
        litellm_objectpermissiontable = await LiteLLM_ObjectPermissionTable.prisma().find_first(
            skip=1,
            order={
                'vector_stores': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_ObjectPermissionTableWhereInput] = None,
        cursor: Optional[types.LiteLLM_ObjectPermissionTableWhereUniqueInput] = None,
        include: Optional[types.LiteLLM_ObjectPermissionTableInclude] = None,
        order: Optional[Union[types.LiteLLM_ObjectPermissionTableOrderByInput, List[types.LiteLLM_ObjectPermissionTableOrderByInput]]] = None,
        distinct: Optional[List[types.LiteLLM_ObjectPermissionTableScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single LiteLLM_ObjectPermissionTable record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            LiteLLM_ObjectPermissionTable filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned LiteLLM_ObjectPermissionTable model
        order
            Order the returned LiteLLM_ObjectPermissionTable records by any field
        distinct
            Filter LiteLLM_ObjectPermissionTable records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.LiteLLM_ObjectPermissionTable
            The first LiteLLM_ObjectPermissionTable record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second LiteLLM_ObjectPermissionTable record ordered by the object_permission_id field
        litellm_objectpermissiontable = await LiteLLM_ObjectPermissionTable.prisma().find_first_or_raise(
            skip=1,
            order={
                'object_permission_id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.LiteLLM_ObjectPermissionTableUpdateInput,
        where: types.LiteLLM_ObjectPermissionTableWhereUniqueInput,
        include: Optional[types.LiteLLM_ObjectPermissionTableInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single LiteLLM_ObjectPermissionTable record.

        Parameters
        ----------
        data
            LiteLLM_ObjectPermissionTable record data specifying what to update
        where
            LiteLLM_ObjectPermissionTable filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned LiteLLM_ObjectPermissionTable model

        Returns
        -------
        prisma.models.LiteLLM_ObjectPermissionTable
            The updated LiteLLM_ObjectPermissionTable record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        litellm_objectpermissiontable = await LiteLLM_ObjectPermissionTable.prisma().update(
            where={
                'object_permission_id': 'fdgjfbhia',
            },
            data={
                # data to update the LiteLLM_ObjectPermissionTable record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.LiteLLM_ObjectPermissionTableWhereUniqueInput,
        data: types.LiteLLM_ObjectPermissionTableUpsertInput,
        include: Optional[types.LiteLLM_ObjectPermissionTableInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            LiteLLM_ObjectPermissionTable filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned LiteLLM_ObjectPermissionTable model

        Returns
        -------
        prisma.models.LiteLLM_ObjectPermissionTable
            The created or updated LiteLLM_ObjectPermissionTable record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        litellm_objectpermissiontable = await LiteLLM_ObjectPermissionTable.prisma().upsert(
            where={
                'object_permission_id': 'jcehcdchh',
            },
            data={
                'create': {
                    'object_permission_id': 'jcehcdchh',
                },
                'update': {
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.LiteLLM_ObjectPermissionTableUpdateManyMutationInput,
        where: types.LiteLLM_ObjectPermissionTableWhereInput,
    ) -> int:
        """Update multiple LiteLLM_ObjectPermissionTable records

        Parameters
        ----------
        data
            LiteLLM_ObjectPermissionTable data to update the selected LiteLLM_ObjectPermissionTable records to
        where
            Filter to select the LiteLLM_ObjectPermissionTable records to update

        Returns
        -------
        int
            The total number of LiteLLM_ObjectPermissionTable records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all LiteLLM_ObjectPermissionTable records
        total = await LiteLLM_ObjectPermissionTable.prisma().update_many(
            data={
                'mcp_servers': ['bgcbjdhjcc']
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_ObjectPermissionTableWhereInput] = None,
        cursor: Optional[types.LiteLLM_ObjectPermissionTableWhereUniqueInput] = None,
    ) -> int:
        """Count the number of LiteLLM_ObjectPermissionTable records present in the database

        Parameters
        ----------
        select
            Select the LiteLLM_ObjectPermissionTable fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            LiteLLM_ObjectPermissionTable filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.LiteLLM_ObjectPermissionTableCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await LiteLLM_ObjectPermissionTable.prisma().count()

        # results: prisma.types.LiteLLM_ObjectPermissionTableCountAggregateOutput
        results = await LiteLLM_ObjectPermissionTable.prisma().count(
            select={
                '_all': True,
                'mcp_access_groups': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.LiteLLM_ObjectPermissionTableCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_ObjectPermissionTableWhereInput] = None,
        cursor: Optional[types.LiteLLM_ObjectPermissionTableWhereUniqueInput] = None,
    ) -> types.LiteLLM_ObjectPermissionTableCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.LiteLLM_ObjectPermissionTableCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_ObjectPermissionTableWhereInput] = None,
        cursor: Optional[types.LiteLLM_ObjectPermissionTableWhereUniqueInput] = None,
    ) -> Union[int, types.LiteLLM_ObjectPermissionTableCountAggregateOutput]:
        """Count the number of LiteLLM_ObjectPermissionTable records present in the database

        Parameters
        ----------
        select
            Select the LiteLLM_ObjectPermissionTable fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            LiteLLM_ObjectPermissionTable filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.LiteLLM_ObjectPermissionTableCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await LiteLLM_ObjectPermissionTable.prisma().count()

        # results: prisma.types.LiteLLM_ObjectPermissionTableCountAggregateOutput
        results = await LiteLLM_ObjectPermissionTable.prisma().count(
            select={
                '_all': True,
                'vector_stores': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.LiteLLM_ObjectPermissionTableCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.LiteLLM_ObjectPermissionTableWhereInput] = None
    ) -> int:
        """Delete multiple LiteLLM_ObjectPermissionTable records.

        Parameters
        ----------
        where
            Optional LiteLLM_ObjectPermissionTable filter to find the records to be deleted

        Returns
        -------
        int
            The total number of LiteLLM_ObjectPermissionTable records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all LiteLLM_ObjectPermissionTable records
        total = await LiteLLM_ObjectPermissionTable.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.LiteLLM_ObjectPermissionTableScalarFieldKeys'],
        *,
        where: Optional['types.LiteLLM_ObjectPermissionTableWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.LiteLLM_ObjectPermissionTableAvgAggregateInput'] = None,
        sum: Optional['types.LiteLLM_ObjectPermissionTableSumAggregateInput'] = None,
        min: Optional['types.LiteLLM_ObjectPermissionTableMinAggregateInput'] = None,
        max: Optional['types.LiteLLM_ObjectPermissionTableMaxAggregateInput'] = None,
        having: Optional['types.LiteLLM_ObjectPermissionTableScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.LiteLLM_ObjectPermissionTableCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.LiteLLM_ObjectPermissionTableScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.LiteLLM_ObjectPermissionTableScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.LiteLLM_ObjectPermissionTableGroupByOutput']:
        """Group LiteLLM_ObjectPermissionTable records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar LiteLLM_ObjectPermissionTable fields to group records by
        where
            LiteLLM_ObjectPermissionTable filter to select records
        take
            Limit the maximum number of LiteLLM_ObjectPermissionTable records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.LiteLLM_ObjectPermissionTableGroupByOutput]
            A list of dictionaries representing the LiteLLM_ObjectPermissionTable record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group LiteLLM_ObjectPermissionTable records by object_permission_id values
        # and count how many records are in each group
        results = await LiteLLM_ObjectPermissionTable.prisma().group_by(
            ['object_permission_id'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class LiteLLM_MCPServerTableActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: 'Client', model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.LiteLLM_MCPServerTable]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await LiteLLM_MCPServerTable.prisma().query_raw(
            'SELECT * FROM LiteLLM_MCPServerTable WHERE server_id = $1',
            'bieiidcabj',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.LiteLLM_MCPServerTable
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await LiteLLM_MCPServerTable.prisma().query_first(
            'SELECT * FROM LiteLLM_MCPServerTable WHERE server_name = $1',
            'bjcbfcieaa',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.LiteLLM_MCPServerTableCreateInput,
        include: Optional[types.LiteLLM_MCPServerTableInclude] = None
    ) -> _PrismaModelT:
        """Create a new LiteLLM_MCPServerTable record.

        Parameters
        ----------
        data
            LiteLLM_MCPServerTable record data
        include
            Specifies which relations should be loaded on the returned LiteLLM_MCPServerTable model

        Returns
        -------
        prisma.models.LiteLLM_MCPServerTable
            The created LiteLLM_MCPServerTable record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a LiteLLM_MCPServerTable record from just the required fields
        litellm_mcpservertable = await LiteLLM_MCPServerTable.prisma().create(
            data={
                # data to create a LiteLLM_MCPServerTable record
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.LiteLLM_MCPServerTableCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple LiteLLM_MCPServerTable records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of LiteLLM_MCPServerTable record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await LiteLLM_MCPServerTable.prisma().create_many(
            data=[
                {
                    # data to create a LiteLLM_MCPServerTable record
                },
                {
                    # data to create a LiteLLM_MCPServerTable record
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.LiteLLM_MCPServerTableWhereUniqueInput,
        include: Optional[types.LiteLLM_MCPServerTableInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single LiteLLM_MCPServerTable record.

        Parameters
        ----------
        where
            LiteLLM_MCPServerTable filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned LiteLLM_MCPServerTable model

        Returns
        -------
        prisma.models.LiteLLM_MCPServerTable
            The deleted LiteLLM_MCPServerTable record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        litellm_mcpservertable = await LiteLLM_MCPServerTable.prisma().delete(
            where={
                'server_id': 'cbaaechiej',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.LiteLLM_MCPServerTableWhereUniqueInput,
        include: Optional[types.LiteLLM_MCPServerTableInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique LiteLLM_MCPServerTable record.

        Parameters
        ----------
        where
            LiteLLM_MCPServerTable filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned LiteLLM_MCPServerTable model

        Returns
        -------
        prisma.models.LiteLLM_MCPServerTable
            The found LiteLLM_MCPServerTable record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        litellm_mcpservertable = await LiteLLM_MCPServerTable.prisma().find_unique(
            where={
                'server_id': 'iejbeaaeg',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.LiteLLM_MCPServerTableWhereUniqueInput,
        include: Optional[types.LiteLLM_MCPServerTableInclude] = None
    ) -> _PrismaModelT:
        """Find a unique LiteLLM_MCPServerTable record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            LiteLLM_MCPServerTable filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned LiteLLM_MCPServerTable model

        Returns
        -------
        prisma.models.LiteLLM_MCPServerTable
            The found LiteLLM_MCPServerTable record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        litellm_mcpservertable = await LiteLLM_MCPServerTable.prisma().find_unique_or_raise(
            where={
                'server_id': 'jcibfcbhf',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_MCPServerTableWhereInput] = None,
        cursor: Optional[types.LiteLLM_MCPServerTableWhereUniqueInput] = None,
        include: Optional[types.LiteLLM_MCPServerTableInclude] = None,
        order: Optional[Union[types.LiteLLM_MCPServerTableOrderByInput, List[types.LiteLLM_MCPServerTableOrderByInput]]] = None,
        distinct: Optional[List[types.LiteLLM_MCPServerTableScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple LiteLLM_MCPServerTable records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of LiteLLM_MCPServerTable records returned
        skip
            Ignore the first N results
        where
            LiteLLM_MCPServerTable filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned LiteLLM_MCPServerTable model
        order
            Order the returned LiteLLM_MCPServerTable records by any field
        distinct
            Filter LiteLLM_MCPServerTable records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.LiteLLM_MCPServerTable]
            The list of all LiteLLM_MCPServerTable records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 LiteLLM_MCPServerTable records
        litellm_mcpservertables = await LiteLLM_MCPServerTable.prisma().find_many(take=10)

        # find the first 5 LiteLLM_MCPServerTable records ordered by the alias field
        litellm_mcpservertables = await LiteLLM_MCPServerTable.prisma().find_many(
            take=5,
            order={
                'alias': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_MCPServerTableWhereInput] = None,
        cursor: Optional[types.LiteLLM_MCPServerTableWhereUniqueInput] = None,
        include: Optional[types.LiteLLM_MCPServerTableInclude] = None,
        order: Optional[Union[types.LiteLLM_MCPServerTableOrderByInput, List[types.LiteLLM_MCPServerTableOrderByInput]]] = None,
        distinct: Optional[List[types.LiteLLM_MCPServerTableScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single LiteLLM_MCPServerTable record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            LiteLLM_MCPServerTable filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned LiteLLM_MCPServerTable model
        order
            Order the returned LiteLLM_MCPServerTable records by any field
        distinct
            Filter LiteLLM_MCPServerTable records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.LiteLLM_MCPServerTable
            The first LiteLLM_MCPServerTable record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second LiteLLM_MCPServerTable record ordered by the description field
        litellm_mcpservertable = await LiteLLM_MCPServerTable.prisma().find_first(
            skip=1,
            order={
                'description': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_MCPServerTableWhereInput] = None,
        cursor: Optional[types.LiteLLM_MCPServerTableWhereUniqueInput] = None,
        include: Optional[types.LiteLLM_MCPServerTableInclude] = None,
        order: Optional[Union[types.LiteLLM_MCPServerTableOrderByInput, List[types.LiteLLM_MCPServerTableOrderByInput]]] = None,
        distinct: Optional[List[types.LiteLLM_MCPServerTableScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single LiteLLM_MCPServerTable record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            LiteLLM_MCPServerTable filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned LiteLLM_MCPServerTable model
        order
            Order the returned LiteLLM_MCPServerTable records by any field
        distinct
            Filter LiteLLM_MCPServerTable records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.LiteLLM_MCPServerTable
            The first LiteLLM_MCPServerTable record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second LiteLLM_MCPServerTable record ordered by the url field
        litellm_mcpservertable = await LiteLLM_MCPServerTable.prisma().find_first_or_raise(
            skip=1,
            order={
                'url': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.LiteLLM_MCPServerTableUpdateInput,
        where: types.LiteLLM_MCPServerTableWhereUniqueInput,
        include: Optional[types.LiteLLM_MCPServerTableInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single LiteLLM_MCPServerTable record.

        Parameters
        ----------
        data
            LiteLLM_MCPServerTable record data specifying what to update
        where
            LiteLLM_MCPServerTable filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned LiteLLM_MCPServerTable model

        Returns
        -------
        prisma.models.LiteLLM_MCPServerTable
            The updated LiteLLM_MCPServerTable record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        litellm_mcpservertable = await LiteLLM_MCPServerTable.prisma().update(
            where={
                'server_id': 'chdadcaga',
            },
            data={
                # data to update the LiteLLM_MCPServerTable record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.LiteLLM_MCPServerTableWhereUniqueInput,
        data: types.LiteLLM_MCPServerTableUpsertInput,
        include: Optional[types.LiteLLM_MCPServerTableInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            LiteLLM_MCPServerTable filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned LiteLLM_MCPServerTable model

        Returns
        -------
        prisma.models.LiteLLM_MCPServerTable
            The created or updated LiteLLM_MCPServerTable record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        litellm_mcpservertable = await LiteLLM_MCPServerTable.prisma().upsert(
            where={
                'server_id': 'jicieifbh',
            },
            data={
                'create': {
                    'server_id': 'jicieifbh',
                },
                'update': {
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.LiteLLM_MCPServerTableUpdateManyMutationInput,
        where: types.LiteLLM_MCPServerTableWhereInput,
    ) -> int:
        """Update multiple LiteLLM_MCPServerTable records

        Parameters
        ----------
        data
            LiteLLM_MCPServerTable data to update the selected LiteLLM_MCPServerTable records to
        where
            Filter to select the LiteLLM_MCPServerTable records to update

        Returns
        -------
        int
            The total number of LiteLLM_MCPServerTable records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all LiteLLM_MCPServerTable records
        total = await LiteLLM_MCPServerTable.prisma().update_many(
            data={
                'transport': 'fbahdheji'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_MCPServerTableWhereInput] = None,
        cursor: Optional[types.LiteLLM_MCPServerTableWhereUniqueInput] = None,
    ) -> int:
        """Count the number of LiteLLM_MCPServerTable records present in the database

        Parameters
        ----------
        select
            Select the LiteLLM_MCPServerTable fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            LiteLLM_MCPServerTable filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.LiteLLM_MCPServerTableCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await LiteLLM_MCPServerTable.prisma().count()

        # results: prisma.types.LiteLLM_MCPServerTableCountAggregateOutput
        results = await LiteLLM_MCPServerTable.prisma().count(
            select={
                '_all': True,
                'spec_version': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.LiteLLM_MCPServerTableCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_MCPServerTableWhereInput] = None,
        cursor: Optional[types.LiteLLM_MCPServerTableWhereUniqueInput] = None,
    ) -> types.LiteLLM_MCPServerTableCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.LiteLLM_MCPServerTableCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_MCPServerTableWhereInput] = None,
        cursor: Optional[types.LiteLLM_MCPServerTableWhereUniqueInput] = None,
    ) -> Union[int, types.LiteLLM_MCPServerTableCountAggregateOutput]:
        """Count the number of LiteLLM_MCPServerTable records present in the database

        Parameters
        ----------
        select
            Select the LiteLLM_MCPServerTable fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            LiteLLM_MCPServerTable filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.LiteLLM_MCPServerTableCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await LiteLLM_MCPServerTable.prisma().count()

        # results: prisma.types.LiteLLM_MCPServerTableCountAggregateOutput
        results = await LiteLLM_MCPServerTable.prisma().count(
            select={
                '_all': True,
                'auth_type': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.LiteLLM_MCPServerTableCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.LiteLLM_MCPServerTableWhereInput] = None
    ) -> int:
        """Delete multiple LiteLLM_MCPServerTable records.

        Parameters
        ----------
        where
            Optional LiteLLM_MCPServerTable filter to find the records to be deleted

        Returns
        -------
        int
            The total number of LiteLLM_MCPServerTable records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all LiteLLM_MCPServerTable records
        total = await LiteLLM_MCPServerTable.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.LiteLLM_MCPServerTableScalarFieldKeys'],
        *,
        where: Optional['types.LiteLLM_MCPServerTableWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.LiteLLM_MCPServerTableAvgAggregateInput'] = None,
        sum: Optional['types.LiteLLM_MCPServerTableSumAggregateInput'] = None,
        min: Optional['types.LiteLLM_MCPServerTableMinAggregateInput'] = None,
        max: Optional['types.LiteLLM_MCPServerTableMaxAggregateInput'] = None,
        having: Optional['types.LiteLLM_MCPServerTableScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.LiteLLM_MCPServerTableCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.LiteLLM_MCPServerTableScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.LiteLLM_MCPServerTableScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.LiteLLM_MCPServerTableGroupByOutput']:
        """Group LiteLLM_MCPServerTable records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar LiteLLM_MCPServerTable fields to group records by
        where
            LiteLLM_MCPServerTable filter to select records
        take
            Limit the maximum number of LiteLLM_MCPServerTable records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.LiteLLM_MCPServerTableGroupByOutput]
            A list of dictionaries representing the LiteLLM_MCPServerTable record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group LiteLLM_MCPServerTable records by created_at values
        # and count how many records are in each group
        results = await LiteLLM_MCPServerTable.prisma().group_by(
            ['created_at'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class LiteLLM_VerificationTokenActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: 'Client', model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.LiteLLM_VerificationToken]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await LiteLLM_VerificationToken.prisma().query_raw(
            'SELECT * FROM LiteLLM_VerificationToken WHERE token = $1',
            'cbbheiicgh',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.LiteLLM_VerificationToken
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await LiteLLM_VerificationToken.prisma().query_first(
            'SELECT * FROM LiteLLM_VerificationToken WHERE key_name = $1',
            'beabjeejdg',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.LiteLLM_VerificationTokenCreateInput,
        include: Optional[types.LiteLLM_VerificationTokenInclude] = None
    ) -> _PrismaModelT:
        """Create a new LiteLLM_VerificationToken record.

        Parameters
        ----------
        data
            LiteLLM_VerificationToken record data
        include
            Specifies which relations should be loaded on the returned LiteLLM_VerificationToken model

        Returns
        -------
        prisma.models.LiteLLM_VerificationToken
            The created LiteLLM_VerificationToken record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a LiteLLM_VerificationToken record from just the required fields
        litellm_verificationtoken = await LiteLLM_VerificationToken.prisma().create(
            data={
                # data to create a LiteLLM_VerificationToken record
                'token': 'bcjhgahffd',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.LiteLLM_VerificationTokenCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple LiteLLM_VerificationToken records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of LiteLLM_VerificationToken record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await LiteLLM_VerificationToken.prisma().create_many(
            data=[
                {
                    # data to create a LiteLLM_VerificationToken record
                    'token': 'fbjeiiffa',
                },
                {
                    # data to create a LiteLLM_VerificationToken record
                    'token': 'jhgidcgbf',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.LiteLLM_VerificationTokenWhereUniqueInput,
        include: Optional[types.LiteLLM_VerificationTokenInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single LiteLLM_VerificationToken record.

        Parameters
        ----------
        where
            LiteLLM_VerificationToken filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned LiteLLM_VerificationToken model

        Returns
        -------
        prisma.models.LiteLLM_VerificationToken
            The deleted LiteLLM_VerificationToken record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        litellm_verificationtoken = await LiteLLM_VerificationToken.prisma().delete(
            where={
                'token': 'bgjgecfejc',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.LiteLLM_VerificationTokenWhereUniqueInput,
        include: Optional[types.LiteLLM_VerificationTokenInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique LiteLLM_VerificationToken record.

        Parameters
        ----------
        where
            LiteLLM_VerificationToken filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned LiteLLM_VerificationToken model

        Returns
        -------
        prisma.models.LiteLLM_VerificationToken
            The found LiteLLM_VerificationToken record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        litellm_verificationtoken = await LiteLLM_VerificationToken.prisma().find_unique(
            where={
                'token': 'bgjcgchib',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.LiteLLM_VerificationTokenWhereUniqueInput,
        include: Optional[types.LiteLLM_VerificationTokenInclude] = None
    ) -> _PrismaModelT:
        """Find a unique LiteLLM_VerificationToken record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            LiteLLM_VerificationToken filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned LiteLLM_VerificationToken model

        Returns
        -------
        prisma.models.LiteLLM_VerificationToken
            The found LiteLLM_VerificationToken record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        litellm_verificationtoken = await LiteLLM_VerificationToken.prisma().find_unique_or_raise(
            where={
                'token': 'bacdaibgfa',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_VerificationTokenWhereInput] = None,
        cursor: Optional[types.LiteLLM_VerificationTokenWhereUniqueInput] = None,
        include: Optional[types.LiteLLM_VerificationTokenInclude] = None,
        order: Optional[Union[types.LiteLLM_VerificationTokenOrderByInput, List[types.LiteLLM_VerificationTokenOrderByInput]]] = None,
        distinct: Optional[List[types.LiteLLM_VerificationTokenScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple LiteLLM_VerificationToken records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of LiteLLM_VerificationToken records returned
        skip
            Ignore the first N results
        where
            LiteLLM_VerificationToken filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned LiteLLM_VerificationToken model
        order
            Order the returned LiteLLM_VerificationToken records by any field
        distinct
            Filter LiteLLM_VerificationToken records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.LiteLLM_VerificationToken]
            The list of all LiteLLM_VerificationToken records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 LiteLLM_VerificationToken records
        litellm_verificationtokens = await LiteLLM_VerificationToken.prisma().find_many(take=10)

        # find the first 5 LiteLLM_VerificationToken records ordered by the key_alias field
        litellm_verificationtokens = await LiteLLM_VerificationToken.prisma().find_many(
            take=5,
            order={
                'key_alias': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_VerificationTokenWhereInput] = None,
        cursor: Optional[types.LiteLLM_VerificationTokenWhereUniqueInput] = None,
        include: Optional[types.LiteLLM_VerificationTokenInclude] = None,
        order: Optional[Union[types.LiteLLM_VerificationTokenOrderByInput, List[types.LiteLLM_VerificationTokenOrderByInput]]] = None,
        distinct: Optional[List[types.LiteLLM_VerificationTokenScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single LiteLLM_VerificationToken record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            LiteLLM_VerificationToken filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned LiteLLM_VerificationToken model
        order
            Order the returned LiteLLM_VerificationToken records by any field
        distinct
            Filter LiteLLM_VerificationToken records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.LiteLLM_VerificationToken
            The first LiteLLM_VerificationToken record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second LiteLLM_VerificationToken record ordered by the soft_budget_cooldown field
        litellm_verificationtoken = await LiteLLM_VerificationToken.prisma().find_first(
            skip=1,
            order={
                'soft_budget_cooldown': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_VerificationTokenWhereInput] = None,
        cursor: Optional[types.LiteLLM_VerificationTokenWhereUniqueInput] = None,
        include: Optional[types.LiteLLM_VerificationTokenInclude] = None,
        order: Optional[Union[types.LiteLLM_VerificationTokenOrderByInput, List[types.LiteLLM_VerificationTokenOrderByInput]]] = None,
        distinct: Optional[List[types.LiteLLM_VerificationTokenScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single LiteLLM_VerificationToken record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            LiteLLM_VerificationToken filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned LiteLLM_VerificationToken model
        order
            Order the returned LiteLLM_VerificationToken records by any field
        distinct
            Filter LiteLLM_VerificationToken records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.LiteLLM_VerificationToken
            The first LiteLLM_VerificationToken record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second LiteLLM_VerificationToken record ordered by the spend field
        litellm_verificationtoken = await LiteLLM_VerificationToken.prisma().find_first_or_raise(
            skip=1,
            order={
                'spend': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.LiteLLM_VerificationTokenUpdateInput,
        where: types.LiteLLM_VerificationTokenWhereUniqueInput,
        include: Optional[types.LiteLLM_VerificationTokenInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single LiteLLM_VerificationToken record.

        Parameters
        ----------
        data
            LiteLLM_VerificationToken record data specifying what to update
        where
            LiteLLM_VerificationToken filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned LiteLLM_VerificationToken model

        Returns
        -------
        prisma.models.LiteLLM_VerificationToken
            The updated LiteLLM_VerificationToken record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        litellm_verificationtoken = await LiteLLM_VerificationToken.prisma().update(
            where={
                'token': 'dchgibach',
            },
            data={
                # data to update the LiteLLM_VerificationToken record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.LiteLLM_VerificationTokenWhereUniqueInput,
        data: types.LiteLLM_VerificationTokenUpsertInput,
        include: Optional[types.LiteLLM_VerificationTokenInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            LiteLLM_VerificationToken filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned LiteLLM_VerificationToken model

        Returns
        -------
        prisma.models.LiteLLM_VerificationToken
            The created or updated LiteLLM_VerificationToken record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        litellm_verificationtoken = await LiteLLM_VerificationToken.prisma().upsert(
            where={
                'token': 'fchheijjc',
            },
            data={
                'create': {
                    'token': 'fchheijjc',
                },
                'update': {
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.LiteLLM_VerificationTokenUpdateManyMutationInput,
        where: types.LiteLLM_VerificationTokenWhereInput,
    ) -> int:
        """Update multiple LiteLLM_VerificationToken records

        Parameters
        ----------
        data
            LiteLLM_VerificationToken data to update the selected LiteLLM_VerificationToken records to
        where
            Filter to select the LiteLLM_VerificationToken records to update

        Returns
        -------
        int
            The total number of LiteLLM_VerificationToken records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all LiteLLM_VerificationToken records
        total = await LiteLLM_VerificationToken.prisma().update_many(
            data={
                'expires': datetime.datetime.utcnow()
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_VerificationTokenWhereInput] = None,
        cursor: Optional[types.LiteLLM_VerificationTokenWhereUniqueInput] = None,
    ) -> int:
        """Count the number of LiteLLM_VerificationToken records present in the database

        Parameters
        ----------
        select
            Select the LiteLLM_VerificationToken fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            LiteLLM_VerificationToken filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.LiteLLM_VerificationTokenCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await LiteLLM_VerificationToken.prisma().count()

        # results: prisma.types.LiteLLM_VerificationTokenCountAggregateOutput
        results = await LiteLLM_VerificationToken.prisma().count(
            select={
                '_all': True,
                'models': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.LiteLLM_VerificationTokenCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_VerificationTokenWhereInput] = None,
        cursor: Optional[types.LiteLLM_VerificationTokenWhereUniqueInput] = None,
    ) -> types.LiteLLM_VerificationTokenCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.LiteLLM_VerificationTokenCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_VerificationTokenWhereInput] = None,
        cursor: Optional[types.LiteLLM_VerificationTokenWhereUniqueInput] = None,
    ) -> Union[int, types.LiteLLM_VerificationTokenCountAggregateOutput]:
        """Count the number of LiteLLM_VerificationToken records present in the database

        Parameters
        ----------
        select
            Select the LiteLLM_VerificationToken fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            LiteLLM_VerificationToken filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.LiteLLM_VerificationTokenCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await LiteLLM_VerificationToken.prisma().count()

        # results: prisma.types.LiteLLM_VerificationTokenCountAggregateOutput
        results = await LiteLLM_VerificationToken.prisma().count(
            select={
                '_all': True,
                'aliases': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.LiteLLM_VerificationTokenCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.LiteLLM_VerificationTokenWhereInput] = None
    ) -> int:
        """Delete multiple LiteLLM_VerificationToken records.

        Parameters
        ----------
        where
            Optional LiteLLM_VerificationToken filter to find the records to be deleted

        Returns
        -------
        int
            The total number of LiteLLM_VerificationToken records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all LiteLLM_VerificationToken records
        total = await LiteLLM_VerificationToken.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.LiteLLM_VerificationTokenScalarFieldKeys'],
        *,
        where: Optional['types.LiteLLM_VerificationTokenWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.LiteLLM_VerificationTokenAvgAggregateInput'] = None,
        sum: Optional['types.LiteLLM_VerificationTokenSumAggregateInput'] = None,
        min: Optional['types.LiteLLM_VerificationTokenMinAggregateInput'] = None,
        max: Optional['types.LiteLLM_VerificationTokenMaxAggregateInput'] = None,
        having: Optional['types.LiteLLM_VerificationTokenScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.LiteLLM_VerificationTokenCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.LiteLLM_VerificationTokenScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.LiteLLM_VerificationTokenScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.LiteLLM_VerificationTokenGroupByOutput']:
        """Group LiteLLM_VerificationToken records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar LiteLLM_VerificationToken fields to group records by
        where
            LiteLLM_VerificationToken filter to select records
        take
            Limit the maximum number of LiteLLM_VerificationToken records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.LiteLLM_VerificationTokenGroupByOutput]
            A list of dictionaries representing the LiteLLM_VerificationToken record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group LiteLLM_VerificationToken records by config values
        # and count how many records are in each group
        results = await LiteLLM_VerificationToken.prisma().group_by(
            ['config'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class LiteLLM_EndUserTableActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: 'Client', model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.LiteLLM_EndUserTable]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await LiteLLM_EndUserTable.prisma().query_raw(
            'SELECT * FROM LiteLLM_EndUserTable WHERE user_id = $1',
            'cacjdfhejh',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.LiteLLM_EndUserTable
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await LiteLLM_EndUserTable.prisma().query_first(
            'SELECT * FROM LiteLLM_EndUserTable WHERE alias = $1',
            'bdbifjhbbi',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.LiteLLM_EndUserTableCreateInput,
        include: Optional[types.LiteLLM_EndUserTableInclude] = None
    ) -> _PrismaModelT:
        """Create a new LiteLLM_EndUserTable record.

        Parameters
        ----------
        data
            LiteLLM_EndUserTable record data
        include
            Specifies which relations should be loaded on the returned LiteLLM_EndUserTable model

        Returns
        -------
        prisma.models.LiteLLM_EndUserTable
            The created LiteLLM_EndUserTable record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a LiteLLM_EndUserTable record from just the required fields
        litellm_endusertable = await LiteLLM_EndUserTable.prisma().create(
            data={
                # data to create a LiteLLM_EndUserTable record
                'user_id': 'cbccbbcdfb',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.LiteLLM_EndUserTableCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple LiteLLM_EndUserTable records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of LiteLLM_EndUserTable record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await LiteLLM_EndUserTable.prisma().create_many(
            data=[
                {
                    # data to create a LiteLLM_EndUserTable record
                    'user_id': 'bacejedaca',
                },
                {
                    # data to create a LiteLLM_EndUserTable record
                    'user_id': 'bhbhdahfaj',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.LiteLLM_EndUserTableWhereUniqueInput,
        include: Optional[types.LiteLLM_EndUserTableInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single LiteLLM_EndUserTable record.

        Parameters
        ----------
        where
            LiteLLM_EndUserTable filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned LiteLLM_EndUserTable model

        Returns
        -------
        prisma.models.LiteLLM_EndUserTable
            The deleted LiteLLM_EndUserTable record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        litellm_endusertable = await LiteLLM_EndUserTable.prisma().delete(
            where={
                'user_id': 'bfjibceaec',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.LiteLLM_EndUserTableWhereUniqueInput,
        include: Optional[types.LiteLLM_EndUserTableInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique LiteLLM_EndUserTable record.

        Parameters
        ----------
        where
            LiteLLM_EndUserTable filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned LiteLLM_EndUserTable model

        Returns
        -------
        prisma.models.LiteLLM_EndUserTable
            The found LiteLLM_EndUserTable record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        litellm_endusertable = await LiteLLM_EndUserTable.prisma().find_unique(
            where={
                'user_id': 'ibhgcdbgd',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.LiteLLM_EndUserTableWhereUniqueInput,
        include: Optional[types.LiteLLM_EndUserTableInclude] = None
    ) -> _PrismaModelT:
        """Find a unique LiteLLM_EndUserTable record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            LiteLLM_EndUserTable filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned LiteLLM_EndUserTable model

        Returns
        -------
        prisma.models.LiteLLM_EndUserTable
            The found LiteLLM_EndUserTable record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        litellm_endusertable = await LiteLLM_EndUserTable.prisma().find_unique_or_raise(
            where={
                'user_id': 'badaffhddg',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_EndUserTableWhereInput] = None,
        cursor: Optional[types.LiteLLM_EndUserTableWhereUniqueInput] = None,
        include: Optional[types.LiteLLM_EndUserTableInclude] = None,
        order: Optional[Union[types.LiteLLM_EndUserTableOrderByInput, List[types.LiteLLM_EndUserTableOrderByInput]]] = None,
        distinct: Optional[List[types.LiteLLM_EndUserTableScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple LiteLLM_EndUserTable records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of LiteLLM_EndUserTable records returned
        skip
            Ignore the first N results
        where
            LiteLLM_EndUserTable filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned LiteLLM_EndUserTable model
        order
            Order the returned LiteLLM_EndUserTable records by any field
        distinct
            Filter LiteLLM_EndUserTable records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.LiteLLM_EndUserTable]
            The list of all LiteLLM_EndUserTable records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 LiteLLM_EndUserTable records
        litellm_endusertables = await LiteLLM_EndUserTable.prisma().find_many(take=10)

        # find the first 5 LiteLLM_EndUserTable records ordered by the spend field
        litellm_endusertables = await LiteLLM_EndUserTable.prisma().find_many(
            take=5,
            order={
                'spend': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_EndUserTableWhereInput] = None,
        cursor: Optional[types.LiteLLM_EndUserTableWhereUniqueInput] = None,
        include: Optional[types.LiteLLM_EndUserTableInclude] = None,
        order: Optional[Union[types.LiteLLM_EndUserTableOrderByInput, List[types.LiteLLM_EndUserTableOrderByInput]]] = None,
        distinct: Optional[List[types.LiteLLM_EndUserTableScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single LiteLLM_EndUserTable record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            LiteLLM_EndUserTable filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned LiteLLM_EndUserTable model
        order
            Order the returned LiteLLM_EndUserTable records by any field
        distinct
            Filter LiteLLM_EndUserTable records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.LiteLLM_EndUserTable
            The first LiteLLM_EndUserTable record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second LiteLLM_EndUserTable record ordered by the allowed_model_region field
        litellm_endusertable = await LiteLLM_EndUserTable.prisma().find_first(
            skip=1,
            order={
                'allowed_model_region': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_EndUserTableWhereInput] = None,
        cursor: Optional[types.LiteLLM_EndUserTableWhereUniqueInput] = None,
        include: Optional[types.LiteLLM_EndUserTableInclude] = None,
        order: Optional[Union[types.LiteLLM_EndUserTableOrderByInput, List[types.LiteLLM_EndUserTableOrderByInput]]] = None,
        distinct: Optional[List[types.LiteLLM_EndUserTableScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single LiteLLM_EndUserTable record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            LiteLLM_EndUserTable filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned LiteLLM_EndUserTable model
        order
            Order the returned LiteLLM_EndUserTable records by any field
        distinct
            Filter LiteLLM_EndUserTable records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.LiteLLM_EndUserTable
            The first LiteLLM_EndUserTable record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second LiteLLM_EndUserTable record ordered by the default_model field
        litellm_endusertable = await LiteLLM_EndUserTable.prisma().find_first_or_raise(
            skip=1,
            order={
                'default_model': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.LiteLLM_EndUserTableUpdateInput,
        where: types.LiteLLM_EndUserTableWhereUniqueInput,
        include: Optional[types.LiteLLM_EndUserTableInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single LiteLLM_EndUserTable record.

        Parameters
        ----------
        data
            LiteLLM_EndUserTable record data specifying what to update
        where
            LiteLLM_EndUserTable filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned LiteLLM_EndUserTable model

        Returns
        -------
        prisma.models.LiteLLM_EndUserTable
            The updated LiteLLM_EndUserTable record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        litellm_endusertable = await LiteLLM_EndUserTable.prisma().update(
            where={
                'user_id': 'bbdbfcfihd',
            },
            data={
                # data to update the LiteLLM_EndUserTable record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.LiteLLM_EndUserTableWhereUniqueInput,
        data: types.LiteLLM_EndUserTableUpsertInput,
        include: Optional[types.LiteLLM_EndUserTableInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            LiteLLM_EndUserTable filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned LiteLLM_EndUserTable model

        Returns
        -------
        prisma.models.LiteLLM_EndUserTable
            The created or updated LiteLLM_EndUserTable record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        litellm_endusertable = await LiteLLM_EndUserTable.prisma().upsert(
            where={
                'user_id': 'cbagggbji',
            },
            data={
                'create': {
                    'user_id': 'cbagggbji',
                },
                'update': {
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.LiteLLM_EndUserTableUpdateManyMutationInput,
        where: types.LiteLLM_EndUserTableWhereInput,
    ) -> int:
        """Update multiple LiteLLM_EndUserTable records

        Parameters
        ----------
        data
            LiteLLM_EndUserTable data to update the selected LiteLLM_EndUserTable records to
        where
            Filter to select the LiteLLM_EndUserTable records to update

        Returns
        -------
        int
            The total number of LiteLLM_EndUserTable records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all LiteLLM_EndUserTable records
        total = await LiteLLM_EndUserTable.prisma().update_many(
            data={
                'budget_id': 'bchgafhjed'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_EndUserTableWhereInput] = None,
        cursor: Optional[types.LiteLLM_EndUserTableWhereUniqueInput] = None,
    ) -> int:
        """Count the number of LiteLLM_EndUserTable records present in the database

        Parameters
        ----------
        select
            Select the LiteLLM_EndUserTable fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            LiteLLM_EndUserTable filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.LiteLLM_EndUserTableCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await LiteLLM_EndUserTable.prisma().count()

        # results: prisma.types.LiteLLM_EndUserTableCountAggregateOutput
        results = await LiteLLM_EndUserTable.prisma().count(
            select={
                '_all': True,
                'blocked': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.LiteLLM_EndUserTableCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_EndUserTableWhereInput] = None,
        cursor: Optional[types.LiteLLM_EndUserTableWhereUniqueInput] = None,
    ) -> types.LiteLLM_EndUserTableCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.LiteLLM_EndUserTableCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_EndUserTableWhereInput] = None,
        cursor: Optional[types.LiteLLM_EndUserTableWhereUniqueInput] = None,
    ) -> Union[int, types.LiteLLM_EndUserTableCountAggregateOutput]:
        """Count the number of LiteLLM_EndUserTable records present in the database

        Parameters
        ----------
        select
            Select the LiteLLM_EndUserTable fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            LiteLLM_EndUserTable filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.LiteLLM_EndUserTableCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await LiteLLM_EndUserTable.prisma().count()

        # results: prisma.types.LiteLLM_EndUserTableCountAggregateOutput
        results = await LiteLLM_EndUserTable.prisma().count(
            select={
                '_all': True,
                'user_id': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.LiteLLM_EndUserTableCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.LiteLLM_EndUserTableWhereInput] = None
    ) -> int:
        """Delete multiple LiteLLM_EndUserTable records.

        Parameters
        ----------
        where
            Optional LiteLLM_EndUserTable filter to find the records to be deleted

        Returns
        -------
        int
            The total number of LiteLLM_EndUserTable records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all LiteLLM_EndUserTable records
        total = await LiteLLM_EndUserTable.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.LiteLLM_EndUserTableScalarFieldKeys'],
        *,
        where: Optional['types.LiteLLM_EndUserTableWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.LiteLLM_EndUserTableAvgAggregateInput'] = None,
        sum: Optional['types.LiteLLM_EndUserTableSumAggregateInput'] = None,
        min: Optional['types.LiteLLM_EndUserTableMinAggregateInput'] = None,
        max: Optional['types.LiteLLM_EndUserTableMaxAggregateInput'] = None,
        having: Optional['types.LiteLLM_EndUserTableScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.LiteLLM_EndUserTableCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.LiteLLM_EndUserTableScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.LiteLLM_EndUserTableScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.LiteLLM_EndUserTableGroupByOutput']:
        """Group LiteLLM_EndUserTable records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar LiteLLM_EndUserTable fields to group records by
        where
            LiteLLM_EndUserTable filter to select records
        take
            Limit the maximum number of LiteLLM_EndUserTable records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.LiteLLM_EndUserTableGroupByOutput]
            A list of dictionaries representing the LiteLLM_EndUserTable record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group LiteLLM_EndUserTable records by alias values
        # and count how many records are in each group
        results = await LiteLLM_EndUserTable.prisma().group_by(
            ['alias'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class LiteLLM_ConfigActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: 'Client', model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.LiteLLM_Config]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await LiteLLM_Config.prisma().query_raw(
            'SELECT * FROM LiteLLM_Config WHERE param_name = $1',
            'heffgjdei',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.LiteLLM_Config
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await LiteLLM_Config.prisma().query_first(
            'SELECT * FROM LiteLLM_Config WHERE param_value = $1',
            Json({'dahihgbeb': True}),
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.LiteLLM_ConfigCreateInput,
        include: Optional[types.LiteLLM_ConfigInclude] = None
    ) -> _PrismaModelT:
        """Create a new LiteLLM_Config record.

        Parameters
        ----------
        data
            LiteLLM_Config record data
        include
            Specifies which relations should be loaded on the returned LiteLLM_Config model

        Returns
        -------
        prisma.models.LiteLLM_Config
            The created LiteLLM_Config record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a LiteLLM_Config record from just the required fields
        litellm_config = await LiteLLM_Config.prisma().create(
            data={
                # data to create a LiteLLM_Config record
                'param_name': 'bgheaejbcc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.LiteLLM_ConfigCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple LiteLLM_Config records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of LiteLLM_Config record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await LiteLLM_Config.prisma().create_many(
            data=[
                {
                    # data to create a LiteLLM_Config record
                    'param_name': 'bfcgifeged',
                },
                {
                    # data to create a LiteLLM_Config record
                    'param_name': 'jfiahhbae',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.LiteLLM_ConfigWhereUniqueInput,
        include: Optional[types.LiteLLM_ConfigInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single LiteLLM_Config record.

        Parameters
        ----------
        where
            LiteLLM_Config filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned LiteLLM_Config model

        Returns
        -------
        prisma.models.LiteLLM_Config
            The deleted LiteLLM_Config record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        litellm_config = await LiteLLM_Config.prisma().delete(
            where={
                'param_name': 'bfbdafajcb',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.LiteLLM_ConfigWhereUniqueInput,
        include: Optional[types.LiteLLM_ConfigInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique LiteLLM_Config record.

        Parameters
        ----------
        where
            LiteLLM_Config filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned LiteLLM_Config model

        Returns
        -------
        prisma.models.LiteLLM_Config
            The found LiteLLM_Config record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        litellm_config = await LiteLLM_Config.prisma().find_unique(
            where={
                'param_name': 'caeghehde',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.LiteLLM_ConfigWhereUniqueInput,
        include: Optional[types.LiteLLM_ConfigInclude] = None
    ) -> _PrismaModelT:
        """Find a unique LiteLLM_Config record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            LiteLLM_Config filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned LiteLLM_Config model

        Returns
        -------
        prisma.models.LiteLLM_Config
            The found LiteLLM_Config record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        litellm_config = await LiteLLM_Config.prisma().find_unique_or_raise(
            where={
                'param_name': 'caghgfbggd',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_ConfigWhereInput] = None,
        cursor: Optional[types.LiteLLM_ConfigWhereUniqueInput] = None,
        include: Optional[types.LiteLLM_ConfigInclude] = None,
        order: Optional[Union[types.LiteLLM_ConfigOrderByInput, List[types.LiteLLM_ConfigOrderByInput]]] = None,
        distinct: Optional[List[types.LiteLLM_ConfigScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple LiteLLM_Config records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of LiteLLM_Config records returned
        skip
            Ignore the first N results
        where
            LiteLLM_Config filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned LiteLLM_Config model
        order
            Order the returned LiteLLM_Config records by any field
        distinct
            Filter LiteLLM_Config records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.LiteLLM_Config]
            The list of all LiteLLM_Config records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 LiteLLM_Config records
        litellm_configs = await LiteLLM_Config.prisma().find_many(take=10)

        # find the first 5 LiteLLM_Config records ordered by the param_name field
        litellm_configs = await LiteLLM_Config.prisma().find_many(
            take=5,
            order={
                'param_name': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_ConfigWhereInput] = None,
        cursor: Optional[types.LiteLLM_ConfigWhereUniqueInput] = None,
        include: Optional[types.LiteLLM_ConfigInclude] = None,
        order: Optional[Union[types.LiteLLM_ConfigOrderByInput, List[types.LiteLLM_ConfigOrderByInput]]] = None,
        distinct: Optional[List[types.LiteLLM_ConfigScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single LiteLLM_Config record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            LiteLLM_Config filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned LiteLLM_Config model
        order
            Order the returned LiteLLM_Config records by any field
        distinct
            Filter LiteLLM_Config records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.LiteLLM_Config
            The first LiteLLM_Config record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second LiteLLM_Config record ordered by the param_value field
        litellm_config = await LiteLLM_Config.prisma().find_first(
            skip=1,
            order={
                'param_value': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_ConfigWhereInput] = None,
        cursor: Optional[types.LiteLLM_ConfigWhereUniqueInput] = None,
        include: Optional[types.LiteLLM_ConfigInclude] = None,
        order: Optional[Union[types.LiteLLM_ConfigOrderByInput, List[types.LiteLLM_ConfigOrderByInput]]] = None,
        distinct: Optional[List[types.LiteLLM_ConfigScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single LiteLLM_Config record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            LiteLLM_Config filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned LiteLLM_Config model
        order
            Order the returned LiteLLM_Config records by any field
        distinct
            Filter LiteLLM_Config records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.LiteLLM_Config
            The first LiteLLM_Config record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second LiteLLM_Config record ordered by the param_name field
        litellm_config = await LiteLLM_Config.prisma().find_first_or_raise(
            skip=1,
            order={
                'param_name': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.LiteLLM_ConfigUpdateInput,
        where: types.LiteLLM_ConfigWhereUniqueInput,
        include: Optional[types.LiteLLM_ConfigInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single LiteLLM_Config record.

        Parameters
        ----------
        data
            LiteLLM_Config record data specifying what to update
        where
            LiteLLM_Config filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned LiteLLM_Config model

        Returns
        -------
        prisma.models.LiteLLM_Config
            The updated LiteLLM_Config record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        litellm_config = await LiteLLM_Config.prisma().update(
            where={
                'param_name': 'bbidjbbjaa',
            },
            data={
                # data to update the LiteLLM_Config record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.LiteLLM_ConfigWhereUniqueInput,
        data: types.LiteLLM_ConfigUpsertInput,
        include: Optional[types.LiteLLM_ConfigInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            LiteLLM_Config filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned LiteLLM_Config model

        Returns
        -------
        prisma.models.LiteLLM_Config
            The created or updated LiteLLM_Config record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        litellm_config = await LiteLLM_Config.prisma().upsert(
            where={
                'param_name': 'bfijhaejdd',
            },
            data={
                'create': {
                    'param_name': 'bfijhaejdd',
                },
                'update': {
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.LiteLLM_ConfigUpdateManyMutationInput,
        where: types.LiteLLM_ConfigWhereInput,
    ) -> int:
        """Update multiple LiteLLM_Config records

        Parameters
        ----------
        data
            LiteLLM_Config data to update the selected LiteLLM_Config records to
        where
            Filter to select the LiteLLM_Config records to update

        Returns
        -------
        int
            The total number of LiteLLM_Config records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all LiteLLM_Config records
        total = await LiteLLM_Config.prisma().update_many(
            data={
                'param_value': Json({'bcedehfiji': True})
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_ConfigWhereInput] = None,
        cursor: Optional[types.LiteLLM_ConfigWhereUniqueInput] = None,
    ) -> int:
        """Count the number of LiteLLM_Config records present in the database

        Parameters
        ----------
        select
            Select the LiteLLM_Config fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            LiteLLM_Config filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.LiteLLM_ConfigCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await LiteLLM_Config.prisma().count()

        # results: prisma.types.LiteLLM_ConfigCountAggregateOutput
        results = await LiteLLM_Config.prisma().count(
            select={
                '_all': True,
                'param_name': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.LiteLLM_ConfigCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_ConfigWhereInput] = None,
        cursor: Optional[types.LiteLLM_ConfigWhereUniqueInput] = None,
    ) -> types.LiteLLM_ConfigCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.LiteLLM_ConfigCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_ConfigWhereInput] = None,
        cursor: Optional[types.LiteLLM_ConfigWhereUniqueInput] = None,
    ) -> Union[int, types.LiteLLM_ConfigCountAggregateOutput]:
        """Count the number of LiteLLM_Config records present in the database

        Parameters
        ----------
        select
            Select the LiteLLM_Config fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            LiteLLM_Config filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.LiteLLM_ConfigCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await LiteLLM_Config.prisma().count()

        # results: prisma.types.LiteLLM_ConfigCountAggregateOutput
        results = await LiteLLM_Config.prisma().count(
            select={
                '_all': True,
                'param_value': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.LiteLLM_ConfigCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.LiteLLM_ConfigWhereInput] = None
    ) -> int:
        """Delete multiple LiteLLM_Config records.

        Parameters
        ----------
        where
            Optional LiteLLM_Config filter to find the records to be deleted

        Returns
        -------
        int
            The total number of LiteLLM_Config records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all LiteLLM_Config records
        total = await LiteLLM_Config.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.LiteLLM_ConfigScalarFieldKeys'],
        *,
        where: Optional['types.LiteLLM_ConfigWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.LiteLLM_ConfigAvgAggregateInput'] = None,
        sum: Optional['types.LiteLLM_ConfigSumAggregateInput'] = None,
        min: Optional['types.LiteLLM_ConfigMinAggregateInput'] = None,
        max: Optional['types.LiteLLM_ConfigMaxAggregateInput'] = None,
        having: Optional['types.LiteLLM_ConfigScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.LiteLLM_ConfigCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.LiteLLM_ConfigScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.LiteLLM_ConfigScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.LiteLLM_ConfigGroupByOutput']:
        """Group LiteLLM_Config records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar LiteLLM_Config fields to group records by
        where
            LiteLLM_Config filter to select records
        take
            Limit the maximum number of LiteLLM_Config records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.LiteLLM_ConfigGroupByOutput]
            A list of dictionaries representing the LiteLLM_Config record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group LiteLLM_Config records by param_name values
        # and count how many records are in each group
        results = await LiteLLM_Config.prisma().group_by(
            ['param_name'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class LiteLLM_SpendLogsActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: 'Client', model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.LiteLLM_SpendLogs]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await LiteLLM_SpendLogs.prisma().query_raw(
            'SELECT * FROM LiteLLM_SpendLogs WHERE request_id = $1',
            'bdgjicijhb',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.LiteLLM_SpendLogs
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await LiteLLM_SpendLogs.prisma().query_first(
            'SELECT * FROM LiteLLM_SpendLogs WHERE call_type = $1',
            'bghifjdeia',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.LiteLLM_SpendLogsCreateInput,
        include: Optional[types.LiteLLM_SpendLogsInclude] = None
    ) -> _PrismaModelT:
        """Create a new LiteLLM_SpendLogs record.

        Parameters
        ----------
        data
            LiteLLM_SpendLogs record data
        include
            Specifies which relations should be loaded on the returned LiteLLM_SpendLogs model

        Returns
        -------
        prisma.models.LiteLLM_SpendLogs
            The created LiteLLM_SpendLogs record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a LiteLLM_SpendLogs record from just the required fields
        litellm_spendlogs = await LiteLLM_SpendLogs.prisma().create(
            data={
                # data to create a LiteLLM_SpendLogs record
                'request_id': 'eadfcbbcb',
                'call_type': 'geihgahba',
                'startTime': datetime.datetime.utcnow(),
                'endTime': datetime.datetime.utcnow(),
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.LiteLLM_SpendLogsCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple LiteLLM_SpendLogs records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of LiteLLM_SpendLogs record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await LiteLLM_SpendLogs.prisma().create_many(
            data=[
                {
                    # data to create a LiteLLM_SpendLogs record
                    'request_id': 'gahdcdhbj',
                    'call_type': 'begiijahea',
                    'startTime': datetime.datetime.utcnow(),
                    'endTime': datetime.datetime.utcnow(),
                },
                {
                    # data to create a LiteLLM_SpendLogs record
                    'request_id': 'gcjadjaaf',
                    'call_type': 'bcbebgiaic',
                    'startTime': datetime.datetime.utcnow(),
                    'endTime': datetime.datetime.utcnow(),
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.LiteLLM_SpendLogsWhereUniqueInput,
        include: Optional[types.LiteLLM_SpendLogsInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single LiteLLM_SpendLogs record.

        Parameters
        ----------
        where
            LiteLLM_SpendLogs filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned LiteLLM_SpendLogs model

        Returns
        -------
        prisma.models.LiteLLM_SpendLogs
            The deleted LiteLLM_SpendLogs record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        litellm_spendlogs = await LiteLLM_SpendLogs.prisma().delete(
            where={
                'request_id': 'ijigbdcbj',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.LiteLLM_SpendLogsWhereUniqueInput,
        include: Optional[types.LiteLLM_SpendLogsInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique LiteLLM_SpendLogs record.

        Parameters
        ----------
        where
            LiteLLM_SpendLogs filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned LiteLLM_SpendLogs model

        Returns
        -------
        prisma.models.LiteLLM_SpendLogs
            The found LiteLLM_SpendLogs record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        litellm_spendlogs = await LiteLLM_SpendLogs.prisma().find_unique(
            where={
                'request_id': 'gfidhicai',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.LiteLLM_SpendLogsWhereUniqueInput,
        include: Optional[types.LiteLLM_SpendLogsInclude] = None
    ) -> _PrismaModelT:
        """Find a unique LiteLLM_SpendLogs record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            LiteLLM_SpendLogs filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned LiteLLM_SpendLogs model

        Returns
        -------
        prisma.models.LiteLLM_SpendLogs
            The found LiteLLM_SpendLogs record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        litellm_spendlogs = await LiteLLM_SpendLogs.prisma().find_unique_or_raise(
            where={
                'request_id': 'jfegcaafh',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_SpendLogsWhereInput] = None,
        cursor: Optional[types.LiteLLM_SpendLogsWhereUniqueInput] = None,
        include: Optional[types.LiteLLM_SpendLogsInclude] = None,
        order: Optional[Union[types.LiteLLM_SpendLogsOrderByInput, List[types.LiteLLM_SpendLogsOrderByInput]]] = None,
        distinct: Optional[List[types.LiteLLM_SpendLogsScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple LiteLLM_SpendLogs records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of LiteLLM_SpendLogs records returned
        skip
            Ignore the first N results
        where
            LiteLLM_SpendLogs filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned LiteLLM_SpendLogs model
        order
            Order the returned LiteLLM_SpendLogs records by any field
        distinct
            Filter LiteLLM_SpendLogs records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.LiteLLM_SpendLogs]
            The list of all LiteLLM_SpendLogs records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 LiteLLM_SpendLogs records
        litellm_spendlogs = await LiteLLM_SpendLogs.prisma().find_many(take=10)

        # find the first 5 LiteLLM_SpendLogs records ordered by the api_key field
        litellm_spendlogs = await LiteLLM_SpendLogs.prisma().find_many(
            take=5,
            order={
                'api_key': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_SpendLogsWhereInput] = None,
        cursor: Optional[types.LiteLLM_SpendLogsWhereUniqueInput] = None,
        include: Optional[types.LiteLLM_SpendLogsInclude] = None,
        order: Optional[Union[types.LiteLLM_SpendLogsOrderByInput, List[types.LiteLLM_SpendLogsOrderByInput]]] = None,
        distinct: Optional[List[types.LiteLLM_SpendLogsScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single LiteLLM_SpendLogs record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            LiteLLM_SpendLogs filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned LiteLLM_SpendLogs model
        order
            Order the returned LiteLLM_SpendLogs records by any field
        distinct
            Filter LiteLLM_SpendLogs records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.LiteLLM_SpendLogs
            The first LiteLLM_SpendLogs record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second LiteLLM_SpendLogs record ordered by the spend field
        litellm_spendlogs = await LiteLLM_SpendLogs.prisma().find_first(
            skip=1,
            order={
                'spend': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_SpendLogsWhereInput] = None,
        cursor: Optional[types.LiteLLM_SpendLogsWhereUniqueInput] = None,
        include: Optional[types.LiteLLM_SpendLogsInclude] = None,
        order: Optional[Union[types.LiteLLM_SpendLogsOrderByInput, List[types.LiteLLM_SpendLogsOrderByInput]]] = None,
        distinct: Optional[List[types.LiteLLM_SpendLogsScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single LiteLLM_SpendLogs record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            LiteLLM_SpendLogs filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned LiteLLM_SpendLogs model
        order
            Order the returned LiteLLM_SpendLogs records by any field
        distinct
            Filter LiteLLM_SpendLogs records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.LiteLLM_SpendLogs
            The first LiteLLM_SpendLogs record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second LiteLLM_SpendLogs record ordered by the total_tokens field
        litellm_spendlogs = await LiteLLM_SpendLogs.prisma().find_first_or_raise(
            skip=1,
            order={
                'total_tokens': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.LiteLLM_SpendLogsUpdateInput,
        where: types.LiteLLM_SpendLogsWhereUniqueInput,
        include: Optional[types.LiteLLM_SpendLogsInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single LiteLLM_SpendLogs record.

        Parameters
        ----------
        data
            LiteLLM_SpendLogs record data specifying what to update
        where
            LiteLLM_SpendLogs filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned LiteLLM_SpendLogs model

        Returns
        -------
        prisma.models.LiteLLM_SpendLogs
            The updated LiteLLM_SpendLogs record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        litellm_spendlogs = await LiteLLM_SpendLogs.prisma().update(
            where={
                'request_id': 'bcbeiajjfa',
            },
            data={
                # data to update the LiteLLM_SpendLogs record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.LiteLLM_SpendLogsWhereUniqueInput,
        data: types.LiteLLM_SpendLogsUpsertInput,
        include: Optional[types.LiteLLM_SpendLogsInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            LiteLLM_SpendLogs filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned LiteLLM_SpendLogs model

        Returns
        -------
        prisma.models.LiteLLM_SpendLogs
            The created or updated LiteLLM_SpendLogs record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        litellm_spendlogs = await LiteLLM_SpendLogs.prisma().upsert(
            where={
                'request_id': 'baehicaajf',
            },
            data={
                'create': {
                    'request_id': 'baehicaajf',
                    'call_type': 'bcbebgiaic',
                    'startTime': datetime.datetime.utcnow(),
                    'endTime': datetime.datetime.utcnow(),
                },
                'update': {
                    'call_type': 'bcbebgiaic',
                    'startTime': datetime.datetime.utcnow(),
                    'endTime': datetime.datetime.utcnow(),
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.LiteLLM_SpendLogsUpdateManyMutationInput,
        where: types.LiteLLM_SpendLogsWhereInput,
    ) -> int:
        """Update multiple LiteLLM_SpendLogs records

        Parameters
        ----------
        data
            LiteLLM_SpendLogs data to update the selected LiteLLM_SpendLogs records to
        where
            Filter to select the LiteLLM_SpendLogs records to update

        Returns
        -------
        int
            The total number of LiteLLM_SpendLogs records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all LiteLLM_SpendLogs records
        total = await LiteLLM_SpendLogs.prisma().update_many(
            data={
                'prompt_tokens': 1302734860
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_SpendLogsWhereInput] = None,
        cursor: Optional[types.LiteLLM_SpendLogsWhereUniqueInput] = None,
    ) -> int:
        """Count the number of LiteLLM_SpendLogs records present in the database

        Parameters
        ----------
        select
            Select the LiteLLM_SpendLogs fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            LiteLLM_SpendLogs filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.LiteLLM_SpendLogsCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await LiteLLM_SpendLogs.prisma().count()

        # results: prisma.types.LiteLLM_SpendLogsCountAggregateOutput
        results = await LiteLLM_SpendLogs.prisma().count(
            select={
                '_all': True,
                'completion_tokens': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.LiteLLM_SpendLogsCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_SpendLogsWhereInput] = None,
        cursor: Optional[types.LiteLLM_SpendLogsWhereUniqueInput] = None,
    ) -> types.LiteLLM_SpendLogsCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.LiteLLM_SpendLogsCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_SpendLogsWhereInput] = None,
        cursor: Optional[types.LiteLLM_SpendLogsWhereUniqueInput] = None,
    ) -> Union[int, types.LiteLLM_SpendLogsCountAggregateOutput]:
        """Count the number of LiteLLM_SpendLogs records present in the database

        Parameters
        ----------
        select
            Select the LiteLLM_SpendLogs fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            LiteLLM_SpendLogs filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.LiteLLM_SpendLogsCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await LiteLLM_SpendLogs.prisma().count()

        # results: prisma.types.LiteLLM_SpendLogsCountAggregateOutput
        results = await LiteLLM_SpendLogs.prisma().count(
            select={
                '_all': True,
                'startTime': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.LiteLLM_SpendLogsCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.LiteLLM_SpendLogsWhereInput] = None
    ) -> int:
        """Delete multiple LiteLLM_SpendLogs records.

        Parameters
        ----------
        where
            Optional LiteLLM_SpendLogs filter to find the records to be deleted

        Returns
        -------
        int
            The total number of LiteLLM_SpendLogs records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all LiteLLM_SpendLogs records
        total = await LiteLLM_SpendLogs.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.LiteLLM_SpendLogsScalarFieldKeys'],
        *,
        where: Optional['types.LiteLLM_SpendLogsWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.LiteLLM_SpendLogsAvgAggregateInput'] = None,
        sum: Optional['types.LiteLLM_SpendLogsSumAggregateInput'] = None,
        min: Optional['types.LiteLLM_SpendLogsMinAggregateInput'] = None,
        max: Optional['types.LiteLLM_SpendLogsMaxAggregateInput'] = None,
        having: Optional['types.LiteLLM_SpendLogsScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.LiteLLM_SpendLogsCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.LiteLLM_SpendLogsScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.LiteLLM_SpendLogsScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.LiteLLM_SpendLogsGroupByOutput']:
        """Group LiteLLM_SpendLogs records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar LiteLLM_SpendLogs fields to group records by
        where
            LiteLLM_SpendLogs filter to select records
        take
            Limit the maximum number of LiteLLM_SpendLogs records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.LiteLLM_SpendLogsGroupByOutput]
            A list of dictionaries representing the LiteLLM_SpendLogs record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group LiteLLM_SpendLogs records by endTime values
        # and count how many records are in each group
        results = await LiteLLM_SpendLogs.prisma().group_by(
            ['endTime'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class LiteLLM_ErrorLogsActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: 'Client', model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.LiteLLM_ErrorLogs]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await LiteLLM_ErrorLogs.prisma().query_raw(
            'SELECT * FROM LiteLLM_ErrorLogs WHERE request_id = $1',
            'ijdafccef',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.LiteLLM_ErrorLogs
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await LiteLLM_ErrorLogs.prisma().query_first(
            'SELECT * FROM LiteLLM_ErrorLogs WHERE startTime = $1',
            datetime.datetime.utcnow(),
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.LiteLLM_ErrorLogsCreateInput,
        include: Optional[types.LiteLLM_ErrorLogsInclude] = None
    ) -> _PrismaModelT:
        """Create a new LiteLLM_ErrorLogs record.

        Parameters
        ----------
        data
            LiteLLM_ErrorLogs record data
        include
            Specifies which relations should be loaded on the returned LiteLLM_ErrorLogs model

        Returns
        -------
        prisma.models.LiteLLM_ErrorLogs
            The created LiteLLM_ErrorLogs record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a LiteLLM_ErrorLogs record from just the required fields
        litellm_errorlogs = await LiteLLM_ErrorLogs.prisma().create(
            data={
                # data to create a LiteLLM_ErrorLogs record
                'startTime': datetime.datetime.utcnow(),
                'endTime': datetime.datetime.utcnow(),
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.LiteLLM_ErrorLogsCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple LiteLLM_ErrorLogs records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of LiteLLM_ErrorLogs record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await LiteLLM_ErrorLogs.prisma().create_many(
            data=[
                {
                    # data to create a LiteLLM_ErrorLogs record
                    'startTime': datetime.datetime.utcnow(),
                    'endTime': datetime.datetime.utcnow(),
                },
                {
                    # data to create a LiteLLM_ErrorLogs record
                    'startTime': datetime.datetime.utcnow(),
                    'endTime': datetime.datetime.utcnow(),
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.LiteLLM_ErrorLogsWhereUniqueInput,
        include: Optional[types.LiteLLM_ErrorLogsInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single LiteLLM_ErrorLogs record.

        Parameters
        ----------
        where
            LiteLLM_ErrorLogs filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned LiteLLM_ErrorLogs model

        Returns
        -------
        prisma.models.LiteLLM_ErrorLogs
            The deleted LiteLLM_ErrorLogs record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        litellm_errorlogs = await LiteLLM_ErrorLogs.prisma().delete(
            where={
                'request_id': 'ciaaiddag',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.LiteLLM_ErrorLogsWhereUniqueInput,
        include: Optional[types.LiteLLM_ErrorLogsInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique LiteLLM_ErrorLogs record.

        Parameters
        ----------
        where
            LiteLLM_ErrorLogs filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned LiteLLM_ErrorLogs model

        Returns
        -------
        prisma.models.LiteLLM_ErrorLogs
            The found LiteLLM_ErrorLogs record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        litellm_errorlogs = await LiteLLM_ErrorLogs.prisma().find_unique(
            where={
                'request_id': 'fejggijff',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.LiteLLM_ErrorLogsWhereUniqueInput,
        include: Optional[types.LiteLLM_ErrorLogsInclude] = None
    ) -> _PrismaModelT:
        """Find a unique LiteLLM_ErrorLogs record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            LiteLLM_ErrorLogs filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned LiteLLM_ErrorLogs model

        Returns
        -------
        prisma.models.LiteLLM_ErrorLogs
            The found LiteLLM_ErrorLogs record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        litellm_errorlogs = await LiteLLM_ErrorLogs.prisma().find_unique_or_raise(
            where={
                'request_id': 'hghjaaai',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_ErrorLogsWhereInput] = None,
        cursor: Optional[types.LiteLLM_ErrorLogsWhereUniqueInput] = None,
        include: Optional[types.LiteLLM_ErrorLogsInclude] = None,
        order: Optional[Union[types.LiteLLM_ErrorLogsOrderByInput, List[types.LiteLLM_ErrorLogsOrderByInput]]] = None,
        distinct: Optional[List[types.LiteLLM_ErrorLogsScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple LiteLLM_ErrorLogs records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of LiteLLM_ErrorLogs records returned
        skip
            Ignore the first N results
        where
            LiteLLM_ErrorLogs filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned LiteLLM_ErrorLogs model
        order
            Order the returned LiteLLM_ErrorLogs records by any field
        distinct
            Filter LiteLLM_ErrorLogs records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.LiteLLM_ErrorLogs]
            The list of all LiteLLM_ErrorLogs records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 LiteLLM_ErrorLogs records
        litellm_errorlogs = await LiteLLM_ErrorLogs.prisma().find_many(take=10)

        # find the first 5 LiteLLM_ErrorLogs records ordered by the endTime field
        litellm_errorlogs = await LiteLLM_ErrorLogs.prisma().find_many(
            take=5,
            order={
                'endTime': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_ErrorLogsWhereInput] = None,
        cursor: Optional[types.LiteLLM_ErrorLogsWhereUniqueInput] = None,
        include: Optional[types.LiteLLM_ErrorLogsInclude] = None,
        order: Optional[Union[types.LiteLLM_ErrorLogsOrderByInput, List[types.LiteLLM_ErrorLogsOrderByInput]]] = None,
        distinct: Optional[List[types.LiteLLM_ErrorLogsScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single LiteLLM_ErrorLogs record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            LiteLLM_ErrorLogs filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned LiteLLM_ErrorLogs model
        order
            Order the returned LiteLLM_ErrorLogs records by any field
        distinct
            Filter LiteLLM_ErrorLogs records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.LiteLLM_ErrorLogs
            The first LiteLLM_ErrorLogs record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second LiteLLM_ErrorLogs record ordered by the api_base field
        litellm_errorlogs = await LiteLLM_ErrorLogs.prisma().find_first(
            skip=1,
            order={
                'api_base': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_ErrorLogsWhereInput] = None,
        cursor: Optional[types.LiteLLM_ErrorLogsWhereUniqueInput] = None,
        include: Optional[types.LiteLLM_ErrorLogsInclude] = None,
        order: Optional[Union[types.LiteLLM_ErrorLogsOrderByInput, List[types.LiteLLM_ErrorLogsOrderByInput]]] = None,
        distinct: Optional[List[types.LiteLLM_ErrorLogsScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single LiteLLM_ErrorLogs record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            LiteLLM_ErrorLogs filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned LiteLLM_ErrorLogs model
        order
            Order the returned LiteLLM_ErrorLogs records by any field
        distinct
            Filter LiteLLM_ErrorLogs records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.LiteLLM_ErrorLogs
            The first LiteLLM_ErrorLogs record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second LiteLLM_ErrorLogs record ordered by the model_group field
        litellm_errorlogs = await LiteLLM_ErrorLogs.prisma().find_first_or_raise(
            skip=1,
            order={
                'model_group': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.LiteLLM_ErrorLogsUpdateInput,
        where: types.LiteLLM_ErrorLogsWhereUniqueInput,
        include: Optional[types.LiteLLM_ErrorLogsInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single LiteLLM_ErrorLogs record.

        Parameters
        ----------
        data
            LiteLLM_ErrorLogs record data specifying what to update
        where
            LiteLLM_ErrorLogs filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned LiteLLM_ErrorLogs model

        Returns
        -------
        prisma.models.LiteLLM_ErrorLogs
            The updated LiteLLM_ErrorLogs record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        litellm_errorlogs = await LiteLLM_ErrorLogs.prisma().update(
            where={
                'request_id': 'cajicjjdef',
            },
            data={
                # data to update the LiteLLM_ErrorLogs record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.LiteLLM_ErrorLogsWhereUniqueInput,
        data: types.LiteLLM_ErrorLogsUpsertInput,
        include: Optional[types.LiteLLM_ErrorLogsInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            LiteLLM_ErrorLogs filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned LiteLLM_ErrorLogs model

        Returns
        -------
        prisma.models.LiteLLM_ErrorLogs
            The created or updated LiteLLM_ErrorLogs record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        litellm_errorlogs = await LiteLLM_ErrorLogs.prisma().upsert(
            where={
                'request_id': 'cefjaadec',
            },
            data={
                'create': {
                    'request_id': 'cefjaadec',
                    'startTime': datetime.datetime.utcnow(),
                    'endTime': datetime.datetime.utcnow(),
                },
                'update': {
                    'startTime': datetime.datetime.utcnow(),
                    'endTime': datetime.datetime.utcnow(),
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.LiteLLM_ErrorLogsUpdateManyMutationInput,
        where: types.LiteLLM_ErrorLogsWhereInput,
    ) -> int:
        """Update multiple LiteLLM_ErrorLogs records

        Parameters
        ----------
        data
            LiteLLM_ErrorLogs data to update the selected LiteLLM_ErrorLogs records to
        where
            Filter to select the LiteLLM_ErrorLogs records to update

        Returns
        -------
        int
            The total number of LiteLLM_ErrorLogs records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all LiteLLM_ErrorLogs records
        total = await LiteLLM_ErrorLogs.prisma().update_many(
            data={
                'litellm_model_name': 'ibbigdigd'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_ErrorLogsWhereInput] = None,
        cursor: Optional[types.LiteLLM_ErrorLogsWhereUniqueInput] = None,
    ) -> int:
        """Count the number of LiteLLM_ErrorLogs records present in the database

        Parameters
        ----------
        select
            Select the LiteLLM_ErrorLogs fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            LiteLLM_ErrorLogs filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.LiteLLM_ErrorLogsCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await LiteLLM_ErrorLogs.prisma().count()

        # results: prisma.types.LiteLLM_ErrorLogsCountAggregateOutput
        results = await LiteLLM_ErrorLogs.prisma().count(
            select={
                '_all': True,
                'model_id': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.LiteLLM_ErrorLogsCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_ErrorLogsWhereInput] = None,
        cursor: Optional[types.LiteLLM_ErrorLogsWhereUniqueInput] = None,
    ) -> types.LiteLLM_ErrorLogsCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.LiteLLM_ErrorLogsCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_ErrorLogsWhereInput] = None,
        cursor: Optional[types.LiteLLM_ErrorLogsWhereUniqueInput] = None,
    ) -> Union[int, types.LiteLLM_ErrorLogsCountAggregateOutput]:
        """Count the number of LiteLLM_ErrorLogs records present in the database

        Parameters
        ----------
        select
            Select the LiteLLM_ErrorLogs fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            LiteLLM_ErrorLogs filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.LiteLLM_ErrorLogsCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await LiteLLM_ErrorLogs.prisma().count()

        # results: prisma.types.LiteLLM_ErrorLogsCountAggregateOutput
        results = await LiteLLM_ErrorLogs.prisma().count(
            select={
                '_all': True,
                'request_kwargs': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.LiteLLM_ErrorLogsCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.LiteLLM_ErrorLogsWhereInput] = None
    ) -> int:
        """Delete multiple LiteLLM_ErrorLogs records.

        Parameters
        ----------
        where
            Optional LiteLLM_ErrorLogs filter to find the records to be deleted

        Returns
        -------
        int
            The total number of LiteLLM_ErrorLogs records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all LiteLLM_ErrorLogs records
        total = await LiteLLM_ErrorLogs.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.LiteLLM_ErrorLogsScalarFieldKeys'],
        *,
        where: Optional['types.LiteLLM_ErrorLogsWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.LiteLLM_ErrorLogsAvgAggregateInput'] = None,
        sum: Optional['types.LiteLLM_ErrorLogsSumAggregateInput'] = None,
        min: Optional['types.LiteLLM_ErrorLogsMinAggregateInput'] = None,
        max: Optional['types.LiteLLM_ErrorLogsMaxAggregateInput'] = None,
        having: Optional['types.LiteLLM_ErrorLogsScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.LiteLLM_ErrorLogsCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.LiteLLM_ErrorLogsScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.LiteLLM_ErrorLogsScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.LiteLLM_ErrorLogsGroupByOutput']:
        """Group LiteLLM_ErrorLogs records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar LiteLLM_ErrorLogs fields to group records by
        where
            LiteLLM_ErrorLogs filter to select records
        take
            Limit the maximum number of LiteLLM_ErrorLogs records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.LiteLLM_ErrorLogsGroupByOutput]
            A list of dictionaries representing the LiteLLM_ErrorLogs record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group LiteLLM_ErrorLogs records by exception_type values
        # and count how many records are in each group
        results = await LiteLLM_ErrorLogs.prisma().group_by(
            ['exception_type'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class LiteLLM_UserNotificationsActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: 'Client', model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.LiteLLM_UserNotifications]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await LiteLLM_UserNotifications.prisma().query_raw(
            'SELECT * FROM LiteLLM_UserNotifications WHERE request_id = $1',
            'bdiiiabbii',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.LiteLLM_UserNotifications
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await LiteLLM_UserNotifications.prisma().query_first(
            'SELECT * FROM LiteLLM_UserNotifications WHERE user_id = $1',
            'hfcfhhadh',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.LiteLLM_UserNotificationsCreateInput,
        include: Optional[types.LiteLLM_UserNotificationsInclude] = None
    ) -> _PrismaModelT:
        """Create a new LiteLLM_UserNotifications record.

        Parameters
        ----------
        data
            LiteLLM_UserNotifications record data
        include
            Specifies which relations should be loaded on the returned LiteLLM_UserNotifications model

        Returns
        -------
        prisma.models.LiteLLM_UserNotifications
            The created LiteLLM_UserNotifications record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a LiteLLM_UserNotifications record from just the required fields
        litellm_usernotifications = await LiteLLM_UserNotifications.prisma().create(
            data={
                # data to create a LiteLLM_UserNotifications record
                'request_id': 'bbihggdcji',
                'user_id': 'hgjgibdgd',
                'justification': 'bcbecjfice',
                'status': 'bacbebhjjd',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.LiteLLM_UserNotificationsCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple LiteLLM_UserNotifications records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of LiteLLM_UserNotifications record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await LiteLLM_UserNotifications.prisma().create_many(
            data=[
                {
                    # data to create a LiteLLM_UserNotifications record
                    'request_id': 'dfbfaddhe',
                    'user_id': 'bdcbbieibf',
                    'justification': 'dgjhdcggi',
                    'status': 'bbjbcdfabd',
                },
                {
                    # data to create a LiteLLM_UserNotifications record
                    'request_id': 'gchfgbcec',
                    'user_id': 'bihcjfcjah',
                    'justification': 'bhjdcicaii',
                    'status': 'bibedjhcej',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.LiteLLM_UserNotificationsWhereUniqueInput,
        include: Optional[types.LiteLLM_UserNotificationsInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single LiteLLM_UserNotifications record.

        Parameters
        ----------
        where
            LiteLLM_UserNotifications filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned LiteLLM_UserNotifications model

        Returns
        -------
        prisma.models.LiteLLM_UserNotifications
            The deleted LiteLLM_UserNotifications record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        litellm_usernotifications = await LiteLLM_UserNotifications.prisma().delete(
            where={
                'request_id': 'bjcdajabfa',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.LiteLLM_UserNotificationsWhereUniqueInput,
        include: Optional[types.LiteLLM_UserNotificationsInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique LiteLLM_UserNotifications record.

        Parameters
        ----------
        where
            LiteLLM_UserNotifications filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned LiteLLM_UserNotifications model

        Returns
        -------
        prisma.models.LiteLLM_UserNotifications
            The found LiteLLM_UserNotifications record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        litellm_usernotifications = await LiteLLM_UserNotifications.prisma().find_unique(
            where={
                'request_id': 'bchhceeeff',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.LiteLLM_UserNotificationsWhereUniqueInput,
        include: Optional[types.LiteLLM_UserNotificationsInclude] = None
    ) -> _PrismaModelT:
        """Find a unique LiteLLM_UserNotifications record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            LiteLLM_UserNotifications filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned LiteLLM_UserNotifications model

        Returns
        -------
        prisma.models.LiteLLM_UserNotifications
            The found LiteLLM_UserNotifications record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        litellm_usernotifications = await LiteLLM_UserNotifications.prisma().find_unique_or_raise(
            where={
                'request_id': 'bbgaifhdaa',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_UserNotificationsWhereInput] = None,
        cursor: Optional[types.LiteLLM_UserNotificationsWhereUniqueInput] = None,
        include: Optional[types.LiteLLM_UserNotificationsInclude] = None,
        order: Optional[Union[types.LiteLLM_UserNotificationsOrderByInput, List[types.LiteLLM_UserNotificationsOrderByInput]]] = None,
        distinct: Optional[List[types.LiteLLM_UserNotificationsScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple LiteLLM_UserNotifications records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of LiteLLM_UserNotifications records returned
        skip
            Ignore the first N results
        where
            LiteLLM_UserNotifications filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned LiteLLM_UserNotifications model
        order
            Order the returned LiteLLM_UserNotifications records by any field
        distinct
            Filter LiteLLM_UserNotifications records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.LiteLLM_UserNotifications]
            The list of all LiteLLM_UserNotifications records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 LiteLLM_UserNotifications records
        litellm_usernotifications = await LiteLLM_UserNotifications.prisma().find_many(take=10)

        # find the first 5 LiteLLM_UserNotifications records ordered by the models field
        litellm_usernotifications = await LiteLLM_UserNotifications.prisma().find_many(
            take=5,
            order={
                'models': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_UserNotificationsWhereInput] = None,
        cursor: Optional[types.LiteLLM_UserNotificationsWhereUniqueInput] = None,
        include: Optional[types.LiteLLM_UserNotificationsInclude] = None,
        order: Optional[Union[types.LiteLLM_UserNotificationsOrderByInput, List[types.LiteLLM_UserNotificationsOrderByInput]]] = None,
        distinct: Optional[List[types.LiteLLM_UserNotificationsScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single LiteLLM_UserNotifications record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            LiteLLM_UserNotifications filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned LiteLLM_UserNotifications model
        order
            Order the returned LiteLLM_UserNotifications records by any field
        distinct
            Filter LiteLLM_UserNotifications records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.LiteLLM_UserNotifications
            The first LiteLLM_UserNotifications record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second LiteLLM_UserNotifications record ordered by the justification field
        litellm_usernotifications = await LiteLLM_UserNotifications.prisma().find_first(
            skip=1,
            order={
                'justification': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_UserNotificationsWhereInput] = None,
        cursor: Optional[types.LiteLLM_UserNotificationsWhereUniqueInput] = None,
        include: Optional[types.LiteLLM_UserNotificationsInclude] = None,
        order: Optional[Union[types.LiteLLM_UserNotificationsOrderByInput, List[types.LiteLLM_UserNotificationsOrderByInput]]] = None,
        distinct: Optional[List[types.LiteLLM_UserNotificationsScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single LiteLLM_UserNotifications record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            LiteLLM_UserNotifications filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned LiteLLM_UserNotifications model
        order
            Order the returned LiteLLM_UserNotifications records by any field
        distinct
            Filter LiteLLM_UserNotifications records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.LiteLLM_UserNotifications
            The first LiteLLM_UserNotifications record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second LiteLLM_UserNotifications record ordered by the status field
        litellm_usernotifications = await LiteLLM_UserNotifications.prisma().find_first_or_raise(
            skip=1,
            order={
                'status': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.LiteLLM_UserNotificationsUpdateInput,
        where: types.LiteLLM_UserNotificationsWhereUniqueInput,
        include: Optional[types.LiteLLM_UserNotificationsInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single LiteLLM_UserNotifications record.

        Parameters
        ----------
        data
            LiteLLM_UserNotifications record data specifying what to update
        where
            LiteLLM_UserNotifications filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned LiteLLM_UserNotifications model

        Returns
        -------
        prisma.models.LiteLLM_UserNotifications
            The updated LiteLLM_UserNotifications record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        litellm_usernotifications = await LiteLLM_UserNotifications.prisma().update(
            where={
                'request_id': 'dgbcdaegb',
            },
            data={
                # data to update the LiteLLM_UserNotifications record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.LiteLLM_UserNotificationsWhereUniqueInput,
        data: types.LiteLLM_UserNotificationsUpsertInput,
        include: Optional[types.LiteLLM_UserNotificationsInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            LiteLLM_UserNotifications filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned LiteLLM_UserNotifications model

        Returns
        -------
        prisma.models.LiteLLM_UserNotifications
            The created or updated LiteLLM_UserNotifications record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        litellm_usernotifications = await LiteLLM_UserNotifications.prisma().upsert(
            where={
                'request_id': 'beagfbbjig',
            },
            data={
                'create': {
                    'request_id': 'beagfbbjig',
                    'user_id': 'bihcjfcjah',
                    'justification': 'bhjdcicaii',
                    'status': 'bibedjhcej',
                },
                'update': {
                    'user_id': 'bihcjfcjah',
                    'justification': 'bhjdcicaii',
                    'status': 'bibedjhcej',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.LiteLLM_UserNotificationsUpdateManyMutationInput,
        where: types.LiteLLM_UserNotificationsWhereInput,
    ) -> int:
        """Update multiple LiteLLM_UserNotifications records

        Parameters
        ----------
        data
            LiteLLM_UserNotifications data to update the selected LiteLLM_UserNotifications records to
        where
            Filter to select the LiteLLM_UserNotifications records to update

        Returns
        -------
        int
            The total number of LiteLLM_UserNotifications records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all LiteLLM_UserNotifications records
        total = await LiteLLM_UserNotifications.prisma().update_many(
            data={
                'request_id': 'beicihhijb'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_UserNotificationsWhereInput] = None,
        cursor: Optional[types.LiteLLM_UserNotificationsWhereUniqueInput] = None,
    ) -> int:
        """Count the number of LiteLLM_UserNotifications records present in the database

        Parameters
        ----------
        select
            Select the LiteLLM_UserNotifications fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            LiteLLM_UserNotifications filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.LiteLLM_UserNotificationsCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await LiteLLM_UserNotifications.prisma().count()

        # results: prisma.types.LiteLLM_UserNotificationsCountAggregateOutput
        results = await LiteLLM_UserNotifications.prisma().count(
            select={
                '_all': True,
                'user_id': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.LiteLLM_UserNotificationsCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_UserNotificationsWhereInput] = None,
        cursor: Optional[types.LiteLLM_UserNotificationsWhereUniqueInput] = None,
    ) -> types.LiteLLM_UserNotificationsCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.LiteLLM_UserNotificationsCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_UserNotificationsWhereInput] = None,
        cursor: Optional[types.LiteLLM_UserNotificationsWhereUniqueInput] = None,
    ) -> Union[int, types.LiteLLM_UserNotificationsCountAggregateOutput]:
        """Count the number of LiteLLM_UserNotifications records present in the database

        Parameters
        ----------
        select
            Select the LiteLLM_UserNotifications fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            LiteLLM_UserNotifications filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.LiteLLM_UserNotificationsCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await LiteLLM_UserNotifications.prisma().count()

        # results: prisma.types.LiteLLM_UserNotificationsCountAggregateOutput
        results = await LiteLLM_UserNotifications.prisma().count(
            select={
                '_all': True,
                'models': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.LiteLLM_UserNotificationsCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.LiteLLM_UserNotificationsWhereInput] = None
    ) -> int:
        """Delete multiple LiteLLM_UserNotifications records.

        Parameters
        ----------
        where
            Optional LiteLLM_UserNotifications filter to find the records to be deleted

        Returns
        -------
        int
            The total number of LiteLLM_UserNotifications records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all LiteLLM_UserNotifications records
        total = await LiteLLM_UserNotifications.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.LiteLLM_UserNotificationsScalarFieldKeys'],
        *,
        where: Optional['types.LiteLLM_UserNotificationsWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.LiteLLM_UserNotificationsAvgAggregateInput'] = None,
        sum: Optional['types.LiteLLM_UserNotificationsSumAggregateInput'] = None,
        min: Optional['types.LiteLLM_UserNotificationsMinAggregateInput'] = None,
        max: Optional['types.LiteLLM_UserNotificationsMaxAggregateInput'] = None,
        having: Optional['types.LiteLLM_UserNotificationsScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.LiteLLM_UserNotificationsCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.LiteLLM_UserNotificationsScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.LiteLLM_UserNotificationsScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.LiteLLM_UserNotificationsGroupByOutput']:
        """Group LiteLLM_UserNotifications records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar LiteLLM_UserNotifications fields to group records by
        where
            LiteLLM_UserNotifications filter to select records
        take
            Limit the maximum number of LiteLLM_UserNotifications records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.LiteLLM_UserNotificationsGroupByOutput]
            A list of dictionaries representing the LiteLLM_UserNotifications record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group LiteLLM_UserNotifications records by justification values
        # and count how many records are in each group
        results = await LiteLLM_UserNotifications.prisma().group_by(
            ['justification'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class LiteLLM_TeamMembershipActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: 'Client', model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.LiteLLM_TeamMembership]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await LiteLLM_TeamMembership.prisma().query_raw(
            'SELECT * FROM LiteLLM_TeamMembership WHERE user_id = $1',
            'fgggcdcjg',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.LiteLLM_TeamMembership
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await LiteLLM_TeamMembership.prisma().query_first(
            'SELECT * FROM LiteLLM_TeamMembership WHERE team_id = $1',
            'ccjbbjigf',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.LiteLLM_TeamMembershipCreateInput,
        include: Optional[types.LiteLLM_TeamMembershipInclude] = None
    ) -> _PrismaModelT:
        """Create a new LiteLLM_TeamMembership record.

        Parameters
        ----------
        data
            LiteLLM_TeamMembership record data
        include
            Specifies which relations should be loaded on the returned LiteLLM_TeamMembership model

        Returns
        -------
        prisma.models.LiteLLM_TeamMembership
            The created LiteLLM_TeamMembership record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a LiteLLM_TeamMembership record from just the required fields
        litellm_teammembership = await LiteLLM_TeamMembership.prisma().create(
            data={
                # data to create a LiteLLM_TeamMembership record
                'user_id': 'bhfaabbaha',
                'team_id': 'ebajedhhf',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.LiteLLM_TeamMembershipCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple LiteLLM_TeamMembership records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of LiteLLM_TeamMembership record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await LiteLLM_TeamMembership.prisma().create_many(
            data=[
                {
                    # data to create a LiteLLM_TeamMembership record
                    'user_id': 'jajacedge',
                    'team_id': 'hffgbabgf',
                },
                {
                    # data to create a LiteLLM_TeamMembership record
                    'user_id': 'biacbiieja',
                    'team_id': 'cjejbgbff',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.LiteLLM_TeamMembershipWhereUniqueInput,
        include: Optional[types.LiteLLM_TeamMembershipInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single LiteLLM_TeamMembership record.

        Parameters
        ----------
        where
            LiteLLM_TeamMembership filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned LiteLLM_TeamMembership model

        Returns
        -------
        prisma.models.LiteLLM_TeamMembership
            The deleted LiteLLM_TeamMembership record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        litellm_teammembership = await LiteLLM_TeamMembership.prisma().delete(
            where={
                # LiteLLM_TeamMembership where unique filter

            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.LiteLLM_TeamMembershipWhereUniqueInput,
        include: Optional[types.LiteLLM_TeamMembershipInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique LiteLLM_TeamMembership record.

        Parameters
        ----------
        where
            LiteLLM_TeamMembership filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned LiteLLM_TeamMembership model

        Returns
        -------
        prisma.models.LiteLLM_TeamMembership
            The found LiteLLM_TeamMembership record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        litellm_teammembership = await LiteLLM_TeamMembership.prisma().find_unique(
            where={
                # LiteLLM_TeamMembership where unique filter

            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.LiteLLM_TeamMembershipWhereUniqueInput,
        include: Optional[types.LiteLLM_TeamMembershipInclude] = None
    ) -> _PrismaModelT:
        """Find a unique LiteLLM_TeamMembership record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            LiteLLM_TeamMembership filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned LiteLLM_TeamMembership model

        Returns
        -------
        prisma.models.LiteLLM_TeamMembership
            The found LiteLLM_TeamMembership record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        litellm_teammembership = await LiteLLM_TeamMembership.prisma().find_unique_or_raise(
            where={
                # LiteLLM_TeamMembership where unique filter

            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_TeamMembershipWhereInput] = None,
        cursor: Optional[types.LiteLLM_TeamMembershipWhereUniqueInput] = None,
        include: Optional[types.LiteLLM_TeamMembershipInclude] = None,
        order: Optional[Union[types.LiteLLM_TeamMembershipOrderByInput, List[types.LiteLLM_TeamMembershipOrderByInput]]] = None,
        distinct: Optional[List[types.LiteLLM_TeamMembershipScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple LiteLLM_TeamMembership records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of LiteLLM_TeamMembership records returned
        skip
            Ignore the first N results
        where
            LiteLLM_TeamMembership filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned LiteLLM_TeamMembership model
        order
            Order the returned LiteLLM_TeamMembership records by any field
        distinct
            Filter LiteLLM_TeamMembership records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.LiteLLM_TeamMembership]
            The list of all LiteLLM_TeamMembership records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 LiteLLM_TeamMembership records
        litellm_teammemberships = await LiteLLM_TeamMembership.prisma().find_many(take=10)

        # find the first 5 LiteLLM_TeamMembership records ordered by the spend field
        litellm_teammemberships = await LiteLLM_TeamMembership.prisma().find_many(
            take=5,
            order={
                'spend': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_TeamMembershipWhereInput] = None,
        cursor: Optional[types.LiteLLM_TeamMembershipWhereUniqueInput] = None,
        include: Optional[types.LiteLLM_TeamMembershipInclude] = None,
        order: Optional[Union[types.LiteLLM_TeamMembershipOrderByInput, List[types.LiteLLM_TeamMembershipOrderByInput]]] = None,
        distinct: Optional[List[types.LiteLLM_TeamMembershipScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single LiteLLM_TeamMembership record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            LiteLLM_TeamMembership filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned LiteLLM_TeamMembership model
        order
            Order the returned LiteLLM_TeamMembership records by any field
        distinct
            Filter LiteLLM_TeamMembership records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.LiteLLM_TeamMembership
            The first LiteLLM_TeamMembership record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second LiteLLM_TeamMembership record ordered by the budget_id field
        litellm_teammembership = await LiteLLM_TeamMembership.prisma().find_first(
            skip=1,
            order={
                'budget_id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_TeamMembershipWhereInput] = None,
        cursor: Optional[types.LiteLLM_TeamMembershipWhereUniqueInput] = None,
        include: Optional[types.LiteLLM_TeamMembershipInclude] = None,
        order: Optional[Union[types.LiteLLM_TeamMembershipOrderByInput, List[types.LiteLLM_TeamMembershipOrderByInput]]] = None,
        distinct: Optional[List[types.LiteLLM_TeamMembershipScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single LiteLLM_TeamMembership record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            LiteLLM_TeamMembership filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned LiteLLM_TeamMembership model
        order
            Order the returned LiteLLM_TeamMembership records by any field
        distinct
            Filter LiteLLM_TeamMembership records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.LiteLLM_TeamMembership
            The first LiteLLM_TeamMembership record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second LiteLLM_TeamMembership record ordered by the user_id field
        litellm_teammembership = await LiteLLM_TeamMembership.prisma().find_first_or_raise(
            skip=1,
            order={
                'user_id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.LiteLLM_TeamMembershipUpdateInput,
        where: types.LiteLLM_TeamMembershipWhereUniqueInput,
        include: Optional[types.LiteLLM_TeamMembershipInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single LiteLLM_TeamMembership record.

        Parameters
        ----------
        data
            LiteLLM_TeamMembership record data specifying what to update
        where
            LiteLLM_TeamMembership filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned LiteLLM_TeamMembership model

        Returns
        -------
        prisma.models.LiteLLM_TeamMembership
            The updated LiteLLM_TeamMembership record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        litellm_teammembership = await LiteLLM_TeamMembership.prisma().update(
            where={
                # LiteLLM_TeamMembership where unique filter

            },
            data={
                # data to update the LiteLLM_TeamMembership record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.LiteLLM_TeamMembershipWhereUniqueInput,
        data: types.LiteLLM_TeamMembershipUpsertInput,
        include: Optional[types.LiteLLM_TeamMembershipInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            LiteLLM_TeamMembership filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned LiteLLM_TeamMembership model

        Returns
        -------
        prisma.models.LiteLLM_TeamMembership
            The created or updated LiteLLM_TeamMembership record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        litellm_teammembership = await LiteLLM_TeamMembership.prisma().upsert(
            where={
                # LiteLLM_TeamMembership where unique filter
            },
            data={
                'create': {
                    # LiteLLM_TeamMembership data to be set if the record does not exist
                },
                'update': {
                    # LiteLLM_TeamMembership data to be set if the record does exist
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.LiteLLM_TeamMembershipUpdateManyMutationInput,
        where: types.LiteLLM_TeamMembershipWhereInput,
    ) -> int:
        """Update multiple LiteLLM_TeamMembership records

        Parameters
        ----------
        data
            LiteLLM_TeamMembership data to update the selected LiteLLM_TeamMembership records to
        where
            Filter to select the LiteLLM_TeamMembership records to update

        Returns
        -------
        int
            The total number of LiteLLM_TeamMembership records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all LiteLLM_TeamMembership records
        total = await LiteLLM_TeamMembership.prisma().update_many(
            data={
                'team_id': 'fgeahddae'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_TeamMembershipWhereInput] = None,
        cursor: Optional[types.LiteLLM_TeamMembershipWhereUniqueInput] = None,
    ) -> int:
        """Count the number of LiteLLM_TeamMembership records present in the database

        Parameters
        ----------
        select
            Select the LiteLLM_TeamMembership fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            LiteLLM_TeamMembership filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.LiteLLM_TeamMembershipCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await LiteLLM_TeamMembership.prisma().count()

        # results: prisma.types.LiteLLM_TeamMembershipCountAggregateOutput
        results = await LiteLLM_TeamMembership.prisma().count(
            select={
                '_all': True,
                'spend': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.LiteLLM_TeamMembershipCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_TeamMembershipWhereInput] = None,
        cursor: Optional[types.LiteLLM_TeamMembershipWhereUniqueInput] = None,
    ) -> types.LiteLLM_TeamMembershipCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.LiteLLM_TeamMembershipCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_TeamMembershipWhereInput] = None,
        cursor: Optional[types.LiteLLM_TeamMembershipWhereUniqueInput] = None,
    ) -> Union[int, types.LiteLLM_TeamMembershipCountAggregateOutput]:
        """Count the number of LiteLLM_TeamMembership records present in the database

        Parameters
        ----------
        select
            Select the LiteLLM_TeamMembership fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            LiteLLM_TeamMembership filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.LiteLLM_TeamMembershipCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await LiteLLM_TeamMembership.prisma().count()

        # results: prisma.types.LiteLLM_TeamMembershipCountAggregateOutput
        results = await LiteLLM_TeamMembership.prisma().count(
            select={
                '_all': True,
                'budget_id': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.LiteLLM_TeamMembershipCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.LiteLLM_TeamMembershipWhereInput] = None
    ) -> int:
        """Delete multiple LiteLLM_TeamMembership records.

        Parameters
        ----------
        where
            Optional LiteLLM_TeamMembership filter to find the records to be deleted

        Returns
        -------
        int
            The total number of LiteLLM_TeamMembership records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all LiteLLM_TeamMembership records
        total = await LiteLLM_TeamMembership.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.LiteLLM_TeamMembershipScalarFieldKeys'],
        *,
        where: Optional['types.LiteLLM_TeamMembershipWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.LiteLLM_TeamMembershipAvgAggregateInput'] = None,
        sum: Optional['types.LiteLLM_TeamMembershipSumAggregateInput'] = None,
        min: Optional['types.LiteLLM_TeamMembershipMinAggregateInput'] = None,
        max: Optional['types.LiteLLM_TeamMembershipMaxAggregateInput'] = None,
        having: Optional['types.LiteLLM_TeamMembershipScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.LiteLLM_TeamMembershipCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.LiteLLM_TeamMembershipScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.LiteLLM_TeamMembershipScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.LiteLLM_TeamMembershipGroupByOutput']:
        """Group LiteLLM_TeamMembership records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar LiteLLM_TeamMembership fields to group records by
        where
            LiteLLM_TeamMembership filter to select records
        take
            Limit the maximum number of LiteLLM_TeamMembership records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.LiteLLM_TeamMembershipGroupByOutput]
            A list of dictionaries representing the LiteLLM_TeamMembership record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group LiteLLM_TeamMembership records by user_id values
        # and count how many records are in each group
        results = await LiteLLM_TeamMembership.prisma().group_by(
            ['user_id'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class LiteLLM_OrganizationMembershipActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: 'Client', model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.LiteLLM_OrganizationMembership]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await LiteLLM_OrganizationMembership.prisma().query_raw(
            'SELECT * FROM LiteLLM_OrganizationMembership WHERE user_id = $1',
            'diageigcf',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.LiteLLM_OrganizationMembership
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await LiteLLM_OrganizationMembership.prisma().query_first(
            'SELECT * FROM LiteLLM_OrganizationMembership WHERE organization_id = $1',
            'badagbgeha',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.LiteLLM_OrganizationMembershipCreateInput,
        include: Optional[types.LiteLLM_OrganizationMembershipInclude] = None
    ) -> _PrismaModelT:
        """Create a new LiteLLM_OrganizationMembership record.

        Parameters
        ----------
        data
            LiteLLM_OrganizationMembership record data
        include
            Specifies which relations should be loaded on the returned LiteLLM_OrganizationMembership model

        Returns
        -------
        prisma.models.LiteLLM_OrganizationMembership
            The created LiteLLM_OrganizationMembership record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a LiteLLM_OrganizationMembership record from just the required fields
        litellm_organizationmembership = await LiteLLM_OrganizationMembership.prisma().create(
            data={
                # data to create a LiteLLM_OrganizationMembership record
                'user_id': 'ibgebbjch',
                'organization_id': 'baieajjiee',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.LiteLLM_OrganizationMembershipCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple LiteLLM_OrganizationMembership records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of LiteLLM_OrganizationMembership record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await LiteLLM_OrganizationMembership.prisma().create_many(
            data=[
                {
                    # data to create a LiteLLM_OrganizationMembership record
                    'user_id': 'bahjhaccfd',
                    'organization_id': 'hffhfabhi',
                },
                {
                    # data to create a LiteLLM_OrganizationMembership record
                    'user_id': 'bbcigiadhb',
                    'organization_id': 'cfjagbbae',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.LiteLLM_OrganizationMembershipWhereUniqueInput,
        include: Optional[types.LiteLLM_OrganizationMembershipInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single LiteLLM_OrganizationMembership record.

        Parameters
        ----------
        where
            LiteLLM_OrganizationMembership filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned LiteLLM_OrganizationMembership model

        Returns
        -------
        prisma.models.LiteLLM_OrganizationMembership
            The deleted LiteLLM_OrganizationMembership record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        litellm_organizationmembership = await LiteLLM_OrganizationMembership.prisma().delete(
            where={
                # LiteLLM_OrganizationMembership where unique filter

            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.LiteLLM_OrganizationMembershipWhereUniqueInput,
        include: Optional[types.LiteLLM_OrganizationMembershipInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique LiteLLM_OrganizationMembership record.

        Parameters
        ----------
        where
            LiteLLM_OrganizationMembership filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned LiteLLM_OrganizationMembership model

        Returns
        -------
        prisma.models.LiteLLM_OrganizationMembership
            The found LiteLLM_OrganizationMembership record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        litellm_organizationmembership = await LiteLLM_OrganizationMembership.prisma().find_unique(
            where={
                # LiteLLM_OrganizationMembership where unique filter

            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.LiteLLM_OrganizationMembershipWhereUniqueInput,
        include: Optional[types.LiteLLM_OrganizationMembershipInclude] = None
    ) -> _PrismaModelT:
        """Find a unique LiteLLM_OrganizationMembership record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            LiteLLM_OrganizationMembership filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned LiteLLM_OrganizationMembership model

        Returns
        -------
        prisma.models.LiteLLM_OrganizationMembership
            The found LiteLLM_OrganizationMembership record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        litellm_organizationmembership = await LiteLLM_OrganizationMembership.prisma().find_unique_or_raise(
            where={
                # LiteLLM_OrganizationMembership where unique filter

            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_OrganizationMembershipWhereInput] = None,
        cursor: Optional[types.LiteLLM_OrganizationMembershipWhereUniqueInput] = None,
        include: Optional[types.LiteLLM_OrganizationMembershipInclude] = None,
        order: Optional[Union[types.LiteLLM_OrganizationMembershipOrderByInput, List[types.LiteLLM_OrganizationMembershipOrderByInput]]] = None,
        distinct: Optional[List[types.LiteLLM_OrganizationMembershipScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple LiteLLM_OrganizationMembership records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of LiteLLM_OrganizationMembership records returned
        skip
            Ignore the first N results
        where
            LiteLLM_OrganizationMembership filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned LiteLLM_OrganizationMembership model
        order
            Order the returned LiteLLM_OrganizationMembership records by any field
        distinct
            Filter LiteLLM_OrganizationMembership records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.LiteLLM_OrganizationMembership]
            The list of all LiteLLM_OrganizationMembership records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 LiteLLM_OrganizationMembership records
        litellm_organizationmemberships = await LiteLLM_OrganizationMembership.prisma().find_many(take=10)

        # find the first 5 LiteLLM_OrganizationMembership records ordered by the user_role field
        litellm_organizationmemberships = await LiteLLM_OrganizationMembership.prisma().find_many(
            take=5,
            order={
                'user_role': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_OrganizationMembershipWhereInput] = None,
        cursor: Optional[types.LiteLLM_OrganizationMembershipWhereUniqueInput] = None,
        include: Optional[types.LiteLLM_OrganizationMembershipInclude] = None,
        order: Optional[Union[types.LiteLLM_OrganizationMembershipOrderByInput, List[types.LiteLLM_OrganizationMembershipOrderByInput]]] = None,
        distinct: Optional[List[types.LiteLLM_OrganizationMembershipScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single LiteLLM_OrganizationMembership record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            LiteLLM_OrganizationMembership filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned LiteLLM_OrganizationMembership model
        order
            Order the returned LiteLLM_OrganizationMembership records by any field
        distinct
            Filter LiteLLM_OrganizationMembership records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.LiteLLM_OrganizationMembership
            The first LiteLLM_OrganizationMembership record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second LiteLLM_OrganizationMembership record ordered by the spend field
        litellm_organizationmembership = await LiteLLM_OrganizationMembership.prisma().find_first(
            skip=1,
            order={
                'spend': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_OrganizationMembershipWhereInput] = None,
        cursor: Optional[types.LiteLLM_OrganizationMembershipWhereUniqueInput] = None,
        include: Optional[types.LiteLLM_OrganizationMembershipInclude] = None,
        order: Optional[Union[types.LiteLLM_OrganizationMembershipOrderByInput, List[types.LiteLLM_OrganizationMembershipOrderByInput]]] = None,
        distinct: Optional[List[types.LiteLLM_OrganizationMembershipScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single LiteLLM_OrganizationMembership record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            LiteLLM_OrganizationMembership filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned LiteLLM_OrganizationMembership model
        order
            Order the returned LiteLLM_OrganizationMembership records by any field
        distinct
            Filter LiteLLM_OrganizationMembership records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.LiteLLM_OrganizationMembership
            The first LiteLLM_OrganizationMembership record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second LiteLLM_OrganizationMembership record ordered by the budget_id field
        litellm_organizationmembership = await LiteLLM_OrganizationMembership.prisma().find_first_or_raise(
            skip=1,
            order={
                'budget_id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.LiteLLM_OrganizationMembershipUpdateInput,
        where: types.LiteLLM_OrganizationMembershipWhereUniqueInput,
        include: Optional[types.LiteLLM_OrganizationMembershipInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single LiteLLM_OrganizationMembership record.

        Parameters
        ----------
        data
            LiteLLM_OrganizationMembership record data specifying what to update
        where
            LiteLLM_OrganizationMembership filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned LiteLLM_OrganizationMembership model

        Returns
        -------
        prisma.models.LiteLLM_OrganizationMembership
            The updated LiteLLM_OrganizationMembership record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        litellm_organizationmembership = await LiteLLM_OrganizationMembership.prisma().update(
            where={
                # LiteLLM_OrganizationMembership where unique filter

            },
            data={
                # data to update the LiteLLM_OrganizationMembership record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.LiteLLM_OrganizationMembershipWhereUniqueInput,
        data: types.LiteLLM_OrganizationMembershipUpsertInput,
        include: Optional[types.LiteLLM_OrganizationMembershipInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            LiteLLM_OrganizationMembership filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned LiteLLM_OrganizationMembership model

        Returns
        -------
        prisma.models.LiteLLM_OrganizationMembership
            The created or updated LiteLLM_OrganizationMembership record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        litellm_organizationmembership = await LiteLLM_OrganizationMembership.prisma().upsert(
            where={
                # LiteLLM_OrganizationMembership where unique filter
            },
            data={
                'create': {
                    # LiteLLM_OrganizationMembership data to be set if the record does not exist
                },
                'update': {
                    # LiteLLM_OrganizationMembership data to be set if the record does exist
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.LiteLLM_OrganizationMembershipUpdateManyMutationInput,
        where: types.LiteLLM_OrganizationMembershipWhereInput,
    ) -> int:
        """Update multiple LiteLLM_OrganizationMembership records

        Parameters
        ----------
        data
            LiteLLM_OrganizationMembership data to update the selected LiteLLM_OrganizationMembership records to
        where
            Filter to select the LiteLLM_OrganizationMembership records to update

        Returns
        -------
        int
            The total number of LiteLLM_OrganizationMembership records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all LiteLLM_OrganizationMembership records
        total = await LiteLLM_OrganizationMembership.prisma().update_many(
            data={
                'created_at': datetime.datetime.utcnow()
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_OrganizationMembershipWhereInput] = None,
        cursor: Optional[types.LiteLLM_OrganizationMembershipWhereUniqueInput] = None,
    ) -> int:
        """Count the number of LiteLLM_OrganizationMembership records present in the database

        Parameters
        ----------
        select
            Select the LiteLLM_OrganizationMembership fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            LiteLLM_OrganizationMembership filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.LiteLLM_OrganizationMembershipCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await LiteLLM_OrganizationMembership.prisma().count()

        # results: prisma.types.LiteLLM_OrganizationMembershipCountAggregateOutput
        results = await LiteLLM_OrganizationMembership.prisma().count(
            select={
                '_all': True,
                'updated_at': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.LiteLLM_OrganizationMembershipCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_OrganizationMembershipWhereInput] = None,
        cursor: Optional[types.LiteLLM_OrganizationMembershipWhereUniqueInput] = None,
    ) -> types.LiteLLM_OrganizationMembershipCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.LiteLLM_OrganizationMembershipCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_OrganizationMembershipWhereInput] = None,
        cursor: Optional[types.LiteLLM_OrganizationMembershipWhereUniqueInput] = None,
    ) -> Union[int, types.LiteLLM_OrganizationMembershipCountAggregateOutput]:
        """Count the number of LiteLLM_OrganizationMembership records present in the database

        Parameters
        ----------
        select
            Select the LiteLLM_OrganizationMembership fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            LiteLLM_OrganizationMembership filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.LiteLLM_OrganizationMembershipCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await LiteLLM_OrganizationMembership.prisma().count()

        # results: prisma.types.LiteLLM_OrganizationMembershipCountAggregateOutput
        results = await LiteLLM_OrganizationMembership.prisma().count(
            select={
                '_all': True,
                'user_id': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.LiteLLM_OrganizationMembershipCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.LiteLLM_OrganizationMembershipWhereInput] = None
    ) -> int:
        """Delete multiple LiteLLM_OrganizationMembership records.

        Parameters
        ----------
        where
            Optional LiteLLM_OrganizationMembership filter to find the records to be deleted

        Returns
        -------
        int
            The total number of LiteLLM_OrganizationMembership records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all LiteLLM_OrganizationMembership records
        total = await LiteLLM_OrganizationMembership.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.LiteLLM_OrganizationMembershipScalarFieldKeys'],
        *,
        where: Optional['types.LiteLLM_OrganizationMembershipWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.LiteLLM_OrganizationMembershipAvgAggregateInput'] = None,
        sum: Optional['types.LiteLLM_OrganizationMembershipSumAggregateInput'] = None,
        min: Optional['types.LiteLLM_OrganizationMembershipMinAggregateInput'] = None,
        max: Optional['types.LiteLLM_OrganizationMembershipMaxAggregateInput'] = None,
        having: Optional['types.LiteLLM_OrganizationMembershipScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.LiteLLM_OrganizationMembershipCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.LiteLLM_OrganizationMembershipScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.LiteLLM_OrganizationMembershipScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.LiteLLM_OrganizationMembershipGroupByOutput']:
        """Group LiteLLM_OrganizationMembership records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar LiteLLM_OrganizationMembership fields to group records by
        where
            LiteLLM_OrganizationMembership filter to select records
        take
            Limit the maximum number of LiteLLM_OrganizationMembership records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.LiteLLM_OrganizationMembershipGroupByOutput]
            A list of dictionaries representing the LiteLLM_OrganizationMembership record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group LiteLLM_OrganizationMembership records by organization_id values
        # and count how many records are in each group
        results = await LiteLLM_OrganizationMembership.prisma().group_by(
            ['organization_id'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class LiteLLM_InvitationLinkActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: 'Client', model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.LiteLLM_InvitationLink]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await LiteLLM_InvitationLink.prisma().query_raw(
            'SELECT * FROM LiteLLM_InvitationLink WHERE id = $1',
            'bbbfhdidef',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.LiteLLM_InvitationLink
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await LiteLLM_InvitationLink.prisma().query_first(
            'SELECT * FROM LiteLLM_InvitationLink WHERE user_id = $1',
            'bdadhibhec',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.LiteLLM_InvitationLinkCreateInput,
        include: Optional[types.LiteLLM_InvitationLinkInclude] = None
    ) -> _PrismaModelT:
        """Create a new LiteLLM_InvitationLink record.

        Parameters
        ----------
        data
            LiteLLM_InvitationLink record data
        include
            Specifies which relations should be loaded on the returned LiteLLM_InvitationLink model

        Returns
        -------
        prisma.models.LiteLLM_InvitationLink
            The created LiteLLM_InvitationLink record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a LiteLLM_InvitationLink record from just the required fields
        litellm_invitationlink = await LiteLLM_InvitationLink.prisma().create(
            data={
                # data to create a LiteLLM_InvitationLink record
                'user_id': 'bfhdjaiejf',
                'expires_at': datetime.datetime.utcnow(),
                'created_at': datetime.datetime.utcnow(),
                'created_by': 'bbjfijjadg',
                'updated_at': datetime.datetime.utcnow(),
                'updated_by': 'hdjacbehh',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.LiteLLM_InvitationLinkCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple LiteLLM_InvitationLink records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of LiteLLM_InvitationLink record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await LiteLLM_InvitationLink.prisma().create_many(
            data=[
                {
                    # data to create a LiteLLM_InvitationLink record
                    'user_id': 'bhcccbeaba',
                    'expires_at': datetime.datetime.utcnow(),
                    'created_at': datetime.datetime.utcnow(),
                    'created_by': 'bcgjbdgjdj',
                    'updated_at': datetime.datetime.utcnow(),
                    'updated_by': 'fhdbhifae',
                },
                {
                    # data to create a LiteLLM_InvitationLink record
                    'user_id': 'beeacgfcej',
                    'expires_at': datetime.datetime.utcnow(),
                    'created_at': datetime.datetime.utcnow(),
                    'created_by': 'bbifhdiicc',
                    'updated_at': datetime.datetime.utcnow(),
                    'updated_by': 'bgjeccejad',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.LiteLLM_InvitationLinkWhereUniqueInput,
        include: Optional[types.LiteLLM_InvitationLinkInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single LiteLLM_InvitationLink record.

        Parameters
        ----------
        where
            LiteLLM_InvitationLink filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned LiteLLM_InvitationLink model

        Returns
        -------
        prisma.models.LiteLLM_InvitationLink
            The deleted LiteLLM_InvitationLink record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        litellm_invitationlink = await LiteLLM_InvitationLink.prisma().delete(
            where={
                'id': 'bjagdgabbg',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.LiteLLM_InvitationLinkWhereUniqueInput,
        include: Optional[types.LiteLLM_InvitationLinkInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique LiteLLM_InvitationLink record.

        Parameters
        ----------
        where
            LiteLLM_InvitationLink filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned LiteLLM_InvitationLink model

        Returns
        -------
        prisma.models.LiteLLM_InvitationLink
            The found LiteLLM_InvitationLink record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        litellm_invitationlink = await LiteLLM_InvitationLink.prisma().find_unique(
            where={
                'id': 'bjbbcffdij',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.LiteLLM_InvitationLinkWhereUniqueInput,
        include: Optional[types.LiteLLM_InvitationLinkInclude] = None
    ) -> _PrismaModelT:
        """Find a unique LiteLLM_InvitationLink record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            LiteLLM_InvitationLink filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned LiteLLM_InvitationLink model

        Returns
        -------
        prisma.models.LiteLLM_InvitationLink
            The found LiteLLM_InvitationLink record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        litellm_invitationlink = await LiteLLM_InvitationLink.prisma().find_unique_or_raise(
            where={
                'id': 'begcgchdi',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_InvitationLinkWhereInput] = None,
        cursor: Optional[types.LiteLLM_InvitationLinkWhereUniqueInput] = None,
        include: Optional[types.LiteLLM_InvitationLinkInclude] = None,
        order: Optional[Union[types.LiteLLM_InvitationLinkOrderByInput, List[types.LiteLLM_InvitationLinkOrderByInput]]] = None,
        distinct: Optional[List[types.LiteLLM_InvitationLinkScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple LiteLLM_InvitationLink records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of LiteLLM_InvitationLink records returned
        skip
            Ignore the first N results
        where
            LiteLLM_InvitationLink filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned LiteLLM_InvitationLink model
        order
            Order the returned LiteLLM_InvitationLink records by any field
        distinct
            Filter LiteLLM_InvitationLink records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.LiteLLM_InvitationLink]
            The list of all LiteLLM_InvitationLink records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 LiteLLM_InvitationLink records
        litellm_invitationlinks = await LiteLLM_InvitationLink.prisma().find_many(take=10)

        # find the first 5 LiteLLM_InvitationLink records ordered by the is_accepted field
        litellm_invitationlinks = await LiteLLM_InvitationLink.prisma().find_many(
            take=5,
            order={
                'is_accepted': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_InvitationLinkWhereInput] = None,
        cursor: Optional[types.LiteLLM_InvitationLinkWhereUniqueInput] = None,
        include: Optional[types.LiteLLM_InvitationLinkInclude] = None,
        order: Optional[Union[types.LiteLLM_InvitationLinkOrderByInput, List[types.LiteLLM_InvitationLinkOrderByInput]]] = None,
        distinct: Optional[List[types.LiteLLM_InvitationLinkScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single LiteLLM_InvitationLink record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            LiteLLM_InvitationLink filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned LiteLLM_InvitationLink model
        order
            Order the returned LiteLLM_InvitationLink records by any field
        distinct
            Filter LiteLLM_InvitationLink records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.LiteLLM_InvitationLink
            The first LiteLLM_InvitationLink record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second LiteLLM_InvitationLink record ordered by the accepted_at field
        litellm_invitationlink = await LiteLLM_InvitationLink.prisma().find_first(
            skip=1,
            order={
                'accepted_at': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_InvitationLinkWhereInput] = None,
        cursor: Optional[types.LiteLLM_InvitationLinkWhereUniqueInput] = None,
        include: Optional[types.LiteLLM_InvitationLinkInclude] = None,
        order: Optional[Union[types.LiteLLM_InvitationLinkOrderByInput, List[types.LiteLLM_InvitationLinkOrderByInput]]] = None,
        distinct: Optional[List[types.LiteLLM_InvitationLinkScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single LiteLLM_InvitationLink record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            LiteLLM_InvitationLink filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned LiteLLM_InvitationLink model
        order
            Order the returned LiteLLM_InvitationLink records by any field
        distinct
            Filter LiteLLM_InvitationLink records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.LiteLLM_InvitationLink
            The first LiteLLM_InvitationLink record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second LiteLLM_InvitationLink record ordered by the expires_at field
        litellm_invitationlink = await LiteLLM_InvitationLink.prisma().find_first_or_raise(
            skip=1,
            order={
                'expires_at': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.LiteLLM_InvitationLinkUpdateInput,
        where: types.LiteLLM_InvitationLinkWhereUniqueInput,
        include: Optional[types.LiteLLM_InvitationLinkInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single LiteLLM_InvitationLink record.

        Parameters
        ----------
        data
            LiteLLM_InvitationLink record data specifying what to update
        where
            LiteLLM_InvitationLink filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned LiteLLM_InvitationLink model

        Returns
        -------
        prisma.models.LiteLLM_InvitationLink
            The updated LiteLLM_InvitationLink record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        litellm_invitationlink = await LiteLLM_InvitationLink.prisma().update(
            where={
                'id': 'bhbjceagbb',
            },
            data={
                # data to update the LiteLLM_InvitationLink record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.LiteLLM_InvitationLinkWhereUniqueInput,
        data: types.LiteLLM_InvitationLinkUpsertInput,
        include: Optional[types.LiteLLM_InvitationLinkInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            LiteLLM_InvitationLink filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned LiteLLM_InvitationLink model

        Returns
        -------
        prisma.models.LiteLLM_InvitationLink
            The created or updated LiteLLM_InvitationLink record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        litellm_invitationlink = await LiteLLM_InvitationLink.prisma().upsert(
            where={
                'id': 'bjeifffjdg',
            },
            data={
                'create': {
                    'id': 'bjeifffjdg',
                    'user_id': 'beeacgfcej',
                    'expires_at': datetime.datetime.utcnow(),
                    'created_at': datetime.datetime.utcnow(),
                    'created_by': 'bbifhdiicc',
                    'updated_at': datetime.datetime.utcnow(),
                    'updated_by': 'bgjeccejad',
                },
                'update': {
                    'user_id': 'beeacgfcej',
                    'expires_at': datetime.datetime.utcnow(),
                    'created_at': datetime.datetime.utcnow(),
                    'created_by': 'bbifhdiicc',
                    'updated_at': datetime.datetime.utcnow(),
                    'updated_by': 'bgjeccejad',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.LiteLLM_InvitationLinkUpdateManyMutationInput,
        where: types.LiteLLM_InvitationLinkWhereInput,
    ) -> int:
        """Update multiple LiteLLM_InvitationLink records

        Parameters
        ----------
        data
            LiteLLM_InvitationLink data to update the selected LiteLLM_InvitationLink records to
        where
            Filter to select the LiteLLM_InvitationLink records to update

        Returns
        -------
        int
            The total number of LiteLLM_InvitationLink records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all LiteLLM_InvitationLink records
        total = await LiteLLM_InvitationLink.prisma().update_many(
            data={
                'created_at': datetime.datetime.utcnow()
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_InvitationLinkWhereInput] = None,
        cursor: Optional[types.LiteLLM_InvitationLinkWhereUniqueInput] = None,
    ) -> int:
        """Count the number of LiteLLM_InvitationLink records present in the database

        Parameters
        ----------
        select
            Select the LiteLLM_InvitationLink fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            LiteLLM_InvitationLink filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.LiteLLM_InvitationLinkCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await LiteLLM_InvitationLink.prisma().count()

        # results: prisma.types.LiteLLM_InvitationLinkCountAggregateOutput
        results = await LiteLLM_InvitationLink.prisma().count(
            select={
                '_all': True,
                'created_by': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.LiteLLM_InvitationLinkCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_InvitationLinkWhereInput] = None,
        cursor: Optional[types.LiteLLM_InvitationLinkWhereUniqueInput] = None,
    ) -> types.LiteLLM_InvitationLinkCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.LiteLLM_InvitationLinkCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_InvitationLinkWhereInput] = None,
        cursor: Optional[types.LiteLLM_InvitationLinkWhereUniqueInput] = None,
    ) -> Union[int, types.LiteLLM_InvitationLinkCountAggregateOutput]:
        """Count the number of LiteLLM_InvitationLink records present in the database

        Parameters
        ----------
        select
            Select the LiteLLM_InvitationLink fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            LiteLLM_InvitationLink filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.LiteLLM_InvitationLinkCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await LiteLLM_InvitationLink.prisma().count()

        # results: prisma.types.LiteLLM_InvitationLinkCountAggregateOutput
        results = await LiteLLM_InvitationLink.prisma().count(
            select={
                '_all': True,
                'updated_at': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.LiteLLM_InvitationLinkCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.LiteLLM_InvitationLinkWhereInput] = None
    ) -> int:
        """Delete multiple LiteLLM_InvitationLink records.

        Parameters
        ----------
        where
            Optional LiteLLM_InvitationLink filter to find the records to be deleted

        Returns
        -------
        int
            The total number of LiteLLM_InvitationLink records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all LiteLLM_InvitationLink records
        total = await LiteLLM_InvitationLink.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.LiteLLM_InvitationLinkScalarFieldKeys'],
        *,
        where: Optional['types.LiteLLM_InvitationLinkWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.LiteLLM_InvitationLinkAvgAggregateInput'] = None,
        sum: Optional['types.LiteLLM_InvitationLinkSumAggregateInput'] = None,
        min: Optional['types.LiteLLM_InvitationLinkMinAggregateInput'] = None,
        max: Optional['types.LiteLLM_InvitationLinkMaxAggregateInput'] = None,
        having: Optional['types.LiteLLM_InvitationLinkScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.LiteLLM_InvitationLinkCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.LiteLLM_InvitationLinkScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.LiteLLM_InvitationLinkScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.LiteLLM_InvitationLinkGroupByOutput']:
        """Group LiteLLM_InvitationLink records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar LiteLLM_InvitationLink fields to group records by
        where
            LiteLLM_InvitationLink filter to select records
        take
            Limit the maximum number of LiteLLM_InvitationLink records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.LiteLLM_InvitationLinkGroupByOutput]
            A list of dictionaries representing the LiteLLM_InvitationLink record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group LiteLLM_InvitationLink records by updated_by values
        # and count how many records are in each group
        results = await LiteLLM_InvitationLink.prisma().group_by(
            ['updated_by'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class LiteLLM_AuditLogActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: 'Client', model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.LiteLLM_AuditLog]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await LiteLLM_AuditLog.prisma().query_raw(
            'SELECT * FROM LiteLLM_AuditLog WHERE id = $1',
            'bdidcfdfjd',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.LiteLLM_AuditLog
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await LiteLLM_AuditLog.prisma().query_first(
            'SELECT * FROM LiteLLM_AuditLog WHERE updated_at = $1',
            datetime.datetime.utcnow(),
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.LiteLLM_AuditLogCreateInput,
        include: Optional[types.LiteLLM_AuditLogInclude] = None
    ) -> _PrismaModelT:
        """Create a new LiteLLM_AuditLog record.

        Parameters
        ----------
        data
            LiteLLM_AuditLog record data
        include
            Specifies which relations should be loaded on the returned LiteLLM_AuditLog model

        Returns
        -------
        prisma.models.LiteLLM_AuditLog
            The created LiteLLM_AuditLog record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a LiteLLM_AuditLog record from just the required fields
        litellm_auditlog = await LiteLLM_AuditLog.prisma().create(
            data={
                # data to create a LiteLLM_AuditLog record
                'action': 'dfeggejja',
                'table_name': 'gehbgghbj',
                'object_id': 'dfhaijeie',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.LiteLLM_AuditLogCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple LiteLLM_AuditLog records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of LiteLLM_AuditLog record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await LiteLLM_AuditLog.prisma().create_many(
            data=[
                {
                    # data to create a LiteLLM_AuditLog record
                    'action': 'gbcdjgicb',
                    'table_name': 'biaibdagac',
                    'object_id': 'bbfbheibcd',
                },
                {
                    # data to create a LiteLLM_AuditLog record
                    'action': 'hiagajie',
                    'table_name': 'eeejidbif',
                    'object_id': 'efgbahec',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.LiteLLM_AuditLogWhereUniqueInput,
        include: Optional[types.LiteLLM_AuditLogInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single LiteLLM_AuditLog record.

        Parameters
        ----------
        where
            LiteLLM_AuditLog filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned LiteLLM_AuditLog model

        Returns
        -------
        prisma.models.LiteLLM_AuditLog
            The deleted LiteLLM_AuditLog record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        litellm_auditlog = await LiteLLM_AuditLog.prisma().delete(
            where={
                'id': 'hgjaiebfb',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.LiteLLM_AuditLogWhereUniqueInput,
        include: Optional[types.LiteLLM_AuditLogInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique LiteLLM_AuditLog record.

        Parameters
        ----------
        where
            LiteLLM_AuditLog filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned LiteLLM_AuditLog model

        Returns
        -------
        prisma.models.LiteLLM_AuditLog
            The found LiteLLM_AuditLog record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        litellm_auditlog = await LiteLLM_AuditLog.prisma().find_unique(
            where={
                'id': 'bddefjjabc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.LiteLLM_AuditLogWhereUniqueInput,
        include: Optional[types.LiteLLM_AuditLogInclude] = None
    ) -> _PrismaModelT:
        """Find a unique LiteLLM_AuditLog record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            LiteLLM_AuditLog filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned LiteLLM_AuditLog model

        Returns
        -------
        prisma.models.LiteLLM_AuditLog
            The found LiteLLM_AuditLog record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        litellm_auditlog = await LiteLLM_AuditLog.prisma().find_unique_or_raise(
            where={
                'id': 'bbbghgbadh',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_AuditLogWhereInput] = None,
        cursor: Optional[types.LiteLLM_AuditLogWhereUniqueInput] = None,
        include: Optional[types.LiteLLM_AuditLogInclude] = None,
        order: Optional[Union[types.LiteLLM_AuditLogOrderByInput, List[types.LiteLLM_AuditLogOrderByInput]]] = None,
        distinct: Optional[List[types.LiteLLM_AuditLogScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple LiteLLM_AuditLog records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of LiteLLM_AuditLog records returned
        skip
            Ignore the first N results
        where
            LiteLLM_AuditLog filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned LiteLLM_AuditLog model
        order
            Order the returned LiteLLM_AuditLog records by any field
        distinct
            Filter LiteLLM_AuditLog records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.LiteLLM_AuditLog]
            The list of all LiteLLM_AuditLog records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 LiteLLM_AuditLog records
        litellm_auditlogs = await LiteLLM_AuditLog.prisma().find_many(take=10)

        # find the first 5 LiteLLM_AuditLog records ordered by the changed_by field
        litellm_auditlogs = await LiteLLM_AuditLog.prisma().find_many(
            take=5,
            order={
                'changed_by': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_AuditLogWhereInput] = None,
        cursor: Optional[types.LiteLLM_AuditLogWhereUniqueInput] = None,
        include: Optional[types.LiteLLM_AuditLogInclude] = None,
        order: Optional[Union[types.LiteLLM_AuditLogOrderByInput, List[types.LiteLLM_AuditLogOrderByInput]]] = None,
        distinct: Optional[List[types.LiteLLM_AuditLogScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single LiteLLM_AuditLog record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            LiteLLM_AuditLog filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned LiteLLM_AuditLog model
        order
            Order the returned LiteLLM_AuditLog records by any field
        distinct
            Filter LiteLLM_AuditLog records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.LiteLLM_AuditLog
            The first LiteLLM_AuditLog record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second LiteLLM_AuditLog record ordered by the changed_by_api_key field
        litellm_auditlog = await LiteLLM_AuditLog.prisma().find_first(
            skip=1,
            order={
                'changed_by_api_key': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_AuditLogWhereInput] = None,
        cursor: Optional[types.LiteLLM_AuditLogWhereUniqueInput] = None,
        include: Optional[types.LiteLLM_AuditLogInclude] = None,
        order: Optional[Union[types.LiteLLM_AuditLogOrderByInput, List[types.LiteLLM_AuditLogOrderByInput]]] = None,
        distinct: Optional[List[types.LiteLLM_AuditLogScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single LiteLLM_AuditLog record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            LiteLLM_AuditLog filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned LiteLLM_AuditLog model
        order
            Order the returned LiteLLM_AuditLog records by any field
        distinct
            Filter LiteLLM_AuditLog records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.LiteLLM_AuditLog
            The first LiteLLM_AuditLog record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second LiteLLM_AuditLog record ordered by the action field
        litellm_auditlog = await LiteLLM_AuditLog.prisma().find_first_or_raise(
            skip=1,
            order={
                'action': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.LiteLLM_AuditLogUpdateInput,
        where: types.LiteLLM_AuditLogWhereUniqueInput,
        include: Optional[types.LiteLLM_AuditLogInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single LiteLLM_AuditLog record.

        Parameters
        ----------
        data
            LiteLLM_AuditLog record data specifying what to update
        where
            LiteLLM_AuditLog filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned LiteLLM_AuditLog model

        Returns
        -------
        prisma.models.LiteLLM_AuditLog
            The updated LiteLLM_AuditLog record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        litellm_auditlog = await LiteLLM_AuditLog.prisma().update(
            where={
                'id': 'bbhcgagaic',
            },
            data={
                # data to update the LiteLLM_AuditLog record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.LiteLLM_AuditLogWhereUniqueInput,
        data: types.LiteLLM_AuditLogUpsertInput,
        include: Optional[types.LiteLLM_AuditLogInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            LiteLLM_AuditLog filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned LiteLLM_AuditLog model

        Returns
        -------
        prisma.models.LiteLLM_AuditLog
            The created or updated LiteLLM_AuditLog record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        litellm_auditlog = await LiteLLM_AuditLog.prisma().upsert(
            where={
                'id': 'ddaabegbb',
            },
            data={
                'create': {
                    'id': 'ddaabegbb',
                    'action': 'hiagajie',
                    'table_name': 'eeejidbif',
                    'object_id': 'efgbahec',
                },
                'update': {
                    'action': 'hiagajie',
                    'table_name': 'eeejidbif',
                    'object_id': 'efgbahec',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.LiteLLM_AuditLogUpdateManyMutationInput,
        where: types.LiteLLM_AuditLogWhereInput,
    ) -> int:
        """Update multiple LiteLLM_AuditLog records

        Parameters
        ----------
        data
            LiteLLM_AuditLog data to update the selected LiteLLM_AuditLog records to
        where
            Filter to select the LiteLLM_AuditLog records to update

        Returns
        -------
        int
            The total number of LiteLLM_AuditLog records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all LiteLLM_AuditLog records
        total = await LiteLLM_AuditLog.prisma().update_many(
            data={
                'table_name': 'bhgibfgbbc'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_AuditLogWhereInput] = None,
        cursor: Optional[types.LiteLLM_AuditLogWhereUniqueInput] = None,
    ) -> int:
        """Count the number of LiteLLM_AuditLog records present in the database

        Parameters
        ----------
        select
            Select the LiteLLM_AuditLog fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            LiteLLM_AuditLog filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.LiteLLM_AuditLogCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await LiteLLM_AuditLog.prisma().count()

        # results: prisma.types.LiteLLM_AuditLogCountAggregateOutput
        results = await LiteLLM_AuditLog.prisma().count(
            select={
                '_all': True,
                'object_id': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.LiteLLM_AuditLogCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_AuditLogWhereInput] = None,
        cursor: Optional[types.LiteLLM_AuditLogWhereUniqueInput] = None,
    ) -> types.LiteLLM_AuditLogCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.LiteLLM_AuditLogCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_AuditLogWhereInput] = None,
        cursor: Optional[types.LiteLLM_AuditLogWhereUniqueInput] = None,
    ) -> Union[int, types.LiteLLM_AuditLogCountAggregateOutput]:
        """Count the number of LiteLLM_AuditLog records present in the database

        Parameters
        ----------
        select
            Select the LiteLLM_AuditLog fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            LiteLLM_AuditLog filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.LiteLLM_AuditLogCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await LiteLLM_AuditLog.prisma().count()

        # results: prisma.types.LiteLLM_AuditLogCountAggregateOutput
        results = await LiteLLM_AuditLog.prisma().count(
            select={
                '_all': True,
                'before_value': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.LiteLLM_AuditLogCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.LiteLLM_AuditLogWhereInput] = None
    ) -> int:
        """Delete multiple LiteLLM_AuditLog records.

        Parameters
        ----------
        where
            Optional LiteLLM_AuditLog filter to find the records to be deleted

        Returns
        -------
        int
            The total number of LiteLLM_AuditLog records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all LiteLLM_AuditLog records
        total = await LiteLLM_AuditLog.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.LiteLLM_AuditLogScalarFieldKeys'],
        *,
        where: Optional['types.LiteLLM_AuditLogWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.LiteLLM_AuditLogAvgAggregateInput'] = None,
        sum: Optional['types.LiteLLM_AuditLogSumAggregateInput'] = None,
        min: Optional['types.LiteLLM_AuditLogMinAggregateInput'] = None,
        max: Optional['types.LiteLLM_AuditLogMaxAggregateInput'] = None,
        having: Optional['types.LiteLLM_AuditLogScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.LiteLLM_AuditLogCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.LiteLLM_AuditLogScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.LiteLLM_AuditLogScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.LiteLLM_AuditLogGroupByOutput']:
        """Group LiteLLM_AuditLog records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar LiteLLM_AuditLog fields to group records by
        where
            LiteLLM_AuditLog filter to select records
        take
            Limit the maximum number of LiteLLM_AuditLog records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.LiteLLM_AuditLogGroupByOutput]
            A list of dictionaries representing the LiteLLM_AuditLog record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group LiteLLM_AuditLog records by updated_values values
        # and count how many records are in each group
        results = await LiteLLM_AuditLog.prisma().group_by(
            ['updated_values'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class LiteLLM_DailyUserSpendActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: 'Client', model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.LiteLLM_DailyUserSpend]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await LiteLLM_DailyUserSpend.prisma().query_raw(
            'SELECT * FROM LiteLLM_DailyUserSpend WHERE id = $1',
            'hbgcihef',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.LiteLLM_DailyUserSpend
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await LiteLLM_DailyUserSpend.prisma().query_first(
            'SELECT * FROM LiteLLM_DailyUserSpend WHERE user_id = $1',
            'ffhgghde',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.LiteLLM_DailyUserSpendCreateInput,
        include: Optional[types.LiteLLM_DailyUserSpendInclude] = None
    ) -> _PrismaModelT:
        """Create a new LiteLLM_DailyUserSpend record.

        Parameters
        ----------
        data
            LiteLLM_DailyUserSpend record data
        include
            Specifies which relations should be loaded on the returned LiteLLM_DailyUserSpend model

        Returns
        -------
        prisma.models.LiteLLM_DailyUserSpend
            The created LiteLLM_DailyUserSpend record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a LiteLLM_DailyUserSpend record from just the required fields
        litellm_dailyuserspend = await LiteLLM_DailyUserSpend.prisma().create(
            data={
                # data to create a LiteLLM_DailyUserSpend record
                'date': 'ibcadcejf',
                'api_key': 'bdcdfgccdg',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.LiteLLM_DailyUserSpendCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple LiteLLM_DailyUserSpend records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of LiteLLM_DailyUserSpend record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await LiteLLM_DailyUserSpend.prisma().create_many(
            data=[
                {
                    # data to create a LiteLLM_DailyUserSpend record
                    'date': 'edhjgdfh',
                    'api_key': 'bdeffdadda',
                },
                {
                    # data to create a LiteLLM_DailyUserSpend record
                    'date': 'bjgfdihchf',
                    'api_key': 'iaeihdeei',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.LiteLLM_DailyUserSpendWhereUniqueInput,
        include: Optional[types.LiteLLM_DailyUserSpendInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single LiteLLM_DailyUserSpend record.

        Parameters
        ----------
        where
            LiteLLM_DailyUserSpend filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned LiteLLM_DailyUserSpend model

        Returns
        -------
        prisma.models.LiteLLM_DailyUserSpend
            The deleted LiteLLM_DailyUserSpend record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        litellm_dailyuserspend = await LiteLLM_DailyUserSpend.prisma().delete(
            where={
                'id': 'bfggejgfbd',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.LiteLLM_DailyUserSpendWhereUniqueInput,
        include: Optional[types.LiteLLM_DailyUserSpendInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique LiteLLM_DailyUserSpend record.

        Parameters
        ----------
        where
            LiteLLM_DailyUserSpend filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned LiteLLM_DailyUserSpend model

        Returns
        -------
        prisma.models.LiteLLM_DailyUserSpend
            The found LiteLLM_DailyUserSpend record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        litellm_dailyuserspend = await LiteLLM_DailyUserSpend.prisma().find_unique(
            where={
                'id': 'ifaaaedja',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.LiteLLM_DailyUserSpendWhereUniqueInput,
        include: Optional[types.LiteLLM_DailyUserSpendInclude] = None
    ) -> _PrismaModelT:
        """Find a unique LiteLLM_DailyUserSpend record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            LiteLLM_DailyUserSpend filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned LiteLLM_DailyUserSpend model

        Returns
        -------
        prisma.models.LiteLLM_DailyUserSpend
            The found LiteLLM_DailyUserSpend record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        litellm_dailyuserspend = await LiteLLM_DailyUserSpend.prisma().find_unique_or_raise(
            where={
                'id': 'cbajdjjabf',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_DailyUserSpendWhereInput] = None,
        cursor: Optional[types.LiteLLM_DailyUserSpendWhereUniqueInput] = None,
        include: Optional[types.LiteLLM_DailyUserSpendInclude] = None,
        order: Optional[Union[types.LiteLLM_DailyUserSpendOrderByInput, List[types.LiteLLM_DailyUserSpendOrderByInput]]] = None,
        distinct: Optional[List[types.LiteLLM_DailyUserSpendScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple LiteLLM_DailyUserSpend records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of LiteLLM_DailyUserSpend records returned
        skip
            Ignore the first N results
        where
            LiteLLM_DailyUserSpend filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned LiteLLM_DailyUserSpend model
        order
            Order the returned LiteLLM_DailyUserSpend records by any field
        distinct
            Filter LiteLLM_DailyUserSpend records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.LiteLLM_DailyUserSpend]
            The list of all LiteLLM_DailyUserSpend records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 LiteLLM_DailyUserSpend records
        litellm_dailyuserspends = await LiteLLM_DailyUserSpend.prisma().find_many(take=10)

        # find the first 5 LiteLLM_DailyUserSpend records ordered by the date field
        litellm_dailyuserspends = await LiteLLM_DailyUserSpend.prisma().find_many(
            take=5,
            order={
                'date': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_DailyUserSpendWhereInput] = None,
        cursor: Optional[types.LiteLLM_DailyUserSpendWhereUniqueInput] = None,
        include: Optional[types.LiteLLM_DailyUserSpendInclude] = None,
        order: Optional[Union[types.LiteLLM_DailyUserSpendOrderByInput, List[types.LiteLLM_DailyUserSpendOrderByInput]]] = None,
        distinct: Optional[List[types.LiteLLM_DailyUserSpendScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single LiteLLM_DailyUserSpend record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            LiteLLM_DailyUserSpend filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned LiteLLM_DailyUserSpend model
        order
            Order the returned LiteLLM_DailyUserSpend records by any field
        distinct
            Filter LiteLLM_DailyUserSpend records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.LiteLLM_DailyUserSpend
            The first LiteLLM_DailyUserSpend record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second LiteLLM_DailyUserSpend record ordered by the api_key field
        litellm_dailyuserspend = await LiteLLM_DailyUserSpend.prisma().find_first(
            skip=1,
            order={
                'api_key': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_DailyUserSpendWhereInput] = None,
        cursor: Optional[types.LiteLLM_DailyUserSpendWhereUniqueInput] = None,
        include: Optional[types.LiteLLM_DailyUserSpendInclude] = None,
        order: Optional[Union[types.LiteLLM_DailyUserSpendOrderByInput, List[types.LiteLLM_DailyUserSpendOrderByInput]]] = None,
        distinct: Optional[List[types.LiteLLM_DailyUserSpendScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single LiteLLM_DailyUserSpend record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            LiteLLM_DailyUserSpend filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned LiteLLM_DailyUserSpend model
        order
            Order the returned LiteLLM_DailyUserSpend records by any field
        distinct
            Filter LiteLLM_DailyUserSpend records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.LiteLLM_DailyUserSpend
            The first LiteLLM_DailyUserSpend record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second LiteLLM_DailyUserSpend record ordered by the model field
        litellm_dailyuserspend = await LiteLLM_DailyUserSpend.prisma().find_first_or_raise(
            skip=1,
            order={
                'model': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.LiteLLM_DailyUserSpendUpdateInput,
        where: types.LiteLLM_DailyUserSpendWhereUniqueInput,
        include: Optional[types.LiteLLM_DailyUserSpendInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single LiteLLM_DailyUserSpend record.

        Parameters
        ----------
        data
            LiteLLM_DailyUserSpend record data specifying what to update
        where
            LiteLLM_DailyUserSpend filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned LiteLLM_DailyUserSpend model

        Returns
        -------
        prisma.models.LiteLLM_DailyUserSpend
            The updated LiteLLM_DailyUserSpend record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        litellm_dailyuserspend = await LiteLLM_DailyUserSpend.prisma().update(
            where={
                'id': 'bcicggedea',
            },
            data={
                # data to update the LiteLLM_DailyUserSpend record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.LiteLLM_DailyUserSpendWhereUniqueInput,
        data: types.LiteLLM_DailyUserSpendUpsertInput,
        include: Optional[types.LiteLLM_DailyUserSpendInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            LiteLLM_DailyUserSpend filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned LiteLLM_DailyUserSpend model

        Returns
        -------
        prisma.models.LiteLLM_DailyUserSpend
            The created or updated LiteLLM_DailyUserSpend record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        litellm_dailyuserspend = await LiteLLM_DailyUserSpend.prisma().upsert(
            where={
                'id': 'cebcdadjh',
            },
            data={
                'create': {
                    'id': 'cebcdadjh',
                    'date': 'bjgfdihchf',
                    'api_key': 'iaeihdeei',
                },
                'update': {
                    'date': 'bjgfdihchf',
                    'api_key': 'iaeihdeei',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.LiteLLM_DailyUserSpendUpdateManyMutationInput,
        where: types.LiteLLM_DailyUserSpendWhereInput,
    ) -> int:
        """Update multiple LiteLLM_DailyUserSpend records

        Parameters
        ----------
        data
            LiteLLM_DailyUserSpend data to update the selected LiteLLM_DailyUserSpend records to
        where
            Filter to select the LiteLLM_DailyUserSpend records to update

        Returns
        -------
        int
            The total number of LiteLLM_DailyUserSpend records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all LiteLLM_DailyUserSpend records
        total = await LiteLLM_DailyUserSpend.prisma().update_many(
            data={
                'model_group': 'ehfigdgac'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_DailyUserSpendWhereInput] = None,
        cursor: Optional[types.LiteLLM_DailyUserSpendWhereUniqueInput] = None,
    ) -> int:
        """Count the number of LiteLLM_DailyUserSpend records present in the database

        Parameters
        ----------
        select
            Select the LiteLLM_DailyUserSpend fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            LiteLLM_DailyUserSpend filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.LiteLLM_DailyUserSpendCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await LiteLLM_DailyUserSpend.prisma().count()

        # results: prisma.types.LiteLLM_DailyUserSpendCountAggregateOutput
        results = await LiteLLM_DailyUserSpend.prisma().count(
            select={
                '_all': True,
                'custom_llm_provider': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.LiteLLM_DailyUserSpendCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_DailyUserSpendWhereInput] = None,
        cursor: Optional[types.LiteLLM_DailyUserSpendWhereUniqueInput] = None,
    ) -> types.LiteLLM_DailyUserSpendCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.LiteLLM_DailyUserSpendCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_DailyUserSpendWhereInput] = None,
        cursor: Optional[types.LiteLLM_DailyUserSpendWhereUniqueInput] = None,
    ) -> Union[int, types.LiteLLM_DailyUserSpendCountAggregateOutput]:
        """Count the number of LiteLLM_DailyUserSpend records present in the database

        Parameters
        ----------
        select
            Select the LiteLLM_DailyUserSpend fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            LiteLLM_DailyUserSpend filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.LiteLLM_DailyUserSpendCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await LiteLLM_DailyUserSpend.prisma().count()

        # results: prisma.types.LiteLLM_DailyUserSpendCountAggregateOutput
        results = await LiteLLM_DailyUserSpend.prisma().count(
            select={
                '_all': True,
                'mcp_namespaced_tool_name': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.LiteLLM_DailyUserSpendCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.LiteLLM_DailyUserSpendWhereInput] = None
    ) -> int:
        """Delete multiple LiteLLM_DailyUserSpend records.

        Parameters
        ----------
        where
            Optional LiteLLM_DailyUserSpend filter to find the records to be deleted

        Returns
        -------
        int
            The total number of LiteLLM_DailyUserSpend records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all LiteLLM_DailyUserSpend records
        total = await LiteLLM_DailyUserSpend.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.LiteLLM_DailyUserSpendScalarFieldKeys'],
        *,
        where: Optional['types.LiteLLM_DailyUserSpendWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.LiteLLM_DailyUserSpendAvgAggregateInput'] = None,
        sum: Optional['types.LiteLLM_DailyUserSpendSumAggregateInput'] = None,
        min: Optional['types.LiteLLM_DailyUserSpendMinAggregateInput'] = None,
        max: Optional['types.LiteLLM_DailyUserSpendMaxAggregateInput'] = None,
        having: Optional['types.LiteLLM_DailyUserSpendScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.LiteLLM_DailyUserSpendCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.LiteLLM_DailyUserSpendScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.LiteLLM_DailyUserSpendScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.LiteLLM_DailyUserSpendGroupByOutput']:
        """Group LiteLLM_DailyUserSpend records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar LiteLLM_DailyUserSpend fields to group records by
        where
            LiteLLM_DailyUserSpend filter to select records
        take
            Limit the maximum number of LiteLLM_DailyUserSpend records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.LiteLLM_DailyUserSpendGroupByOutput]
            A list of dictionaries representing the LiteLLM_DailyUserSpend record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group LiteLLM_DailyUserSpend records by prompt_tokens values
        # and count how many records are in each group
        results = await LiteLLM_DailyUserSpend.prisma().group_by(
            ['prompt_tokens'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class LiteLLM_DailyTeamSpendActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: 'Client', model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.LiteLLM_DailyTeamSpend]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await LiteLLM_DailyTeamSpend.prisma().query_raw(
            'SELECT * FROM LiteLLM_DailyTeamSpend WHERE id = $1',
            'bhbgccijjf',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.LiteLLM_DailyTeamSpend
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await LiteLLM_DailyTeamSpend.prisma().query_first(
            'SELECT * FROM LiteLLM_DailyTeamSpend WHERE team_id = $1',
            'bigjhdgbjc',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.LiteLLM_DailyTeamSpendCreateInput,
        include: Optional[types.LiteLLM_DailyTeamSpendInclude] = None
    ) -> _PrismaModelT:
        """Create a new LiteLLM_DailyTeamSpend record.

        Parameters
        ----------
        data
            LiteLLM_DailyTeamSpend record data
        include
            Specifies which relations should be loaded on the returned LiteLLM_DailyTeamSpend model

        Returns
        -------
        prisma.models.LiteLLM_DailyTeamSpend
            The created LiteLLM_DailyTeamSpend record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a LiteLLM_DailyTeamSpend record from just the required fields
        litellm_dailyteamspend = await LiteLLM_DailyTeamSpend.prisma().create(
            data={
                # data to create a LiteLLM_DailyTeamSpend record
                'date': 'bfifdebhfd',
                'api_key': 'cjchbjde',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.LiteLLM_DailyTeamSpendCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple LiteLLM_DailyTeamSpend records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of LiteLLM_DailyTeamSpend record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await LiteLLM_DailyTeamSpend.prisma().create_many(
            data=[
                {
                    # data to create a LiteLLM_DailyTeamSpend record
                    'date': 'bfiibjcehj',
                    'api_key': 'ijieafghg',
                },
                {
                    # data to create a LiteLLM_DailyTeamSpend record
                    'date': 'hhhegahcf',
                    'api_key': 'edhijefdi',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.LiteLLM_DailyTeamSpendWhereUniqueInput,
        include: Optional[types.LiteLLM_DailyTeamSpendInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single LiteLLM_DailyTeamSpend record.

        Parameters
        ----------
        where
            LiteLLM_DailyTeamSpend filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned LiteLLM_DailyTeamSpend model

        Returns
        -------
        prisma.models.LiteLLM_DailyTeamSpend
            The deleted LiteLLM_DailyTeamSpend record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        litellm_dailyteamspend = await LiteLLM_DailyTeamSpend.prisma().delete(
            where={
                'id': 'djddecjhb',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.LiteLLM_DailyTeamSpendWhereUniqueInput,
        include: Optional[types.LiteLLM_DailyTeamSpendInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique LiteLLM_DailyTeamSpend record.

        Parameters
        ----------
        where
            LiteLLM_DailyTeamSpend filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned LiteLLM_DailyTeamSpend model

        Returns
        -------
        prisma.models.LiteLLM_DailyTeamSpend
            The found LiteLLM_DailyTeamSpend record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        litellm_dailyteamspend = await LiteLLM_DailyTeamSpend.prisma().find_unique(
            where={
                'id': 'bgdicjhie',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.LiteLLM_DailyTeamSpendWhereUniqueInput,
        include: Optional[types.LiteLLM_DailyTeamSpendInclude] = None
    ) -> _PrismaModelT:
        """Find a unique LiteLLM_DailyTeamSpend record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            LiteLLM_DailyTeamSpend filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned LiteLLM_DailyTeamSpend model

        Returns
        -------
        prisma.models.LiteLLM_DailyTeamSpend
            The found LiteLLM_DailyTeamSpend record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        litellm_dailyteamspend = await LiteLLM_DailyTeamSpend.prisma().find_unique_or_raise(
            where={
                'id': 'ceibfcgij',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_DailyTeamSpendWhereInput] = None,
        cursor: Optional[types.LiteLLM_DailyTeamSpendWhereUniqueInput] = None,
        include: Optional[types.LiteLLM_DailyTeamSpendInclude] = None,
        order: Optional[Union[types.LiteLLM_DailyTeamSpendOrderByInput, List[types.LiteLLM_DailyTeamSpendOrderByInput]]] = None,
        distinct: Optional[List[types.LiteLLM_DailyTeamSpendScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple LiteLLM_DailyTeamSpend records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of LiteLLM_DailyTeamSpend records returned
        skip
            Ignore the first N results
        where
            LiteLLM_DailyTeamSpend filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned LiteLLM_DailyTeamSpend model
        order
            Order the returned LiteLLM_DailyTeamSpend records by any field
        distinct
            Filter LiteLLM_DailyTeamSpend records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.LiteLLM_DailyTeamSpend]
            The list of all LiteLLM_DailyTeamSpend records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 LiteLLM_DailyTeamSpend records
        litellm_dailyteamspends = await LiteLLM_DailyTeamSpend.prisma().find_many(take=10)

        # find the first 5 LiteLLM_DailyTeamSpend records ordered by the date field
        litellm_dailyteamspends = await LiteLLM_DailyTeamSpend.prisma().find_many(
            take=5,
            order={
                'date': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_DailyTeamSpendWhereInput] = None,
        cursor: Optional[types.LiteLLM_DailyTeamSpendWhereUniqueInput] = None,
        include: Optional[types.LiteLLM_DailyTeamSpendInclude] = None,
        order: Optional[Union[types.LiteLLM_DailyTeamSpendOrderByInput, List[types.LiteLLM_DailyTeamSpendOrderByInput]]] = None,
        distinct: Optional[List[types.LiteLLM_DailyTeamSpendScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single LiteLLM_DailyTeamSpend record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            LiteLLM_DailyTeamSpend filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned LiteLLM_DailyTeamSpend model
        order
            Order the returned LiteLLM_DailyTeamSpend records by any field
        distinct
            Filter LiteLLM_DailyTeamSpend records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.LiteLLM_DailyTeamSpend
            The first LiteLLM_DailyTeamSpend record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second LiteLLM_DailyTeamSpend record ordered by the api_key field
        litellm_dailyteamspend = await LiteLLM_DailyTeamSpend.prisma().find_first(
            skip=1,
            order={
                'api_key': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_DailyTeamSpendWhereInput] = None,
        cursor: Optional[types.LiteLLM_DailyTeamSpendWhereUniqueInput] = None,
        include: Optional[types.LiteLLM_DailyTeamSpendInclude] = None,
        order: Optional[Union[types.LiteLLM_DailyTeamSpendOrderByInput, List[types.LiteLLM_DailyTeamSpendOrderByInput]]] = None,
        distinct: Optional[List[types.LiteLLM_DailyTeamSpendScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single LiteLLM_DailyTeamSpend record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            LiteLLM_DailyTeamSpend filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned LiteLLM_DailyTeamSpend model
        order
            Order the returned LiteLLM_DailyTeamSpend records by any field
        distinct
            Filter LiteLLM_DailyTeamSpend records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.LiteLLM_DailyTeamSpend
            The first LiteLLM_DailyTeamSpend record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second LiteLLM_DailyTeamSpend record ordered by the model field
        litellm_dailyteamspend = await LiteLLM_DailyTeamSpend.prisma().find_first_or_raise(
            skip=1,
            order={
                'model': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.LiteLLM_DailyTeamSpendUpdateInput,
        where: types.LiteLLM_DailyTeamSpendWhereUniqueInput,
        include: Optional[types.LiteLLM_DailyTeamSpendInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single LiteLLM_DailyTeamSpend record.

        Parameters
        ----------
        data
            LiteLLM_DailyTeamSpend record data specifying what to update
        where
            LiteLLM_DailyTeamSpend filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned LiteLLM_DailyTeamSpend model

        Returns
        -------
        prisma.models.LiteLLM_DailyTeamSpend
            The updated LiteLLM_DailyTeamSpend record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        litellm_dailyteamspend = await LiteLLM_DailyTeamSpend.prisma().update(
            where={
                'id': 'debhbfada',
            },
            data={
                # data to update the LiteLLM_DailyTeamSpend record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.LiteLLM_DailyTeamSpendWhereUniqueInput,
        data: types.LiteLLM_DailyTeamSpendUpsertInput,
        include: Optional[types.LiteLLM_DailyTeamSpendInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            LiteLLM_DailyTeamSpend filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned LiteLLM_DailyTeamSpend model

        Returns
        -------
        prisma.models.LiteLLM_DailyTeamSpend
            The created or updated LiteLLM_DailyTeamSpend record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        litellm_dailyteamspend = await LiteLLM_DailyTeamSpend.prisma().upsert(
            where={
                'id': 'bgjchggecd',
            },
            data={
                'create': {
                    'id': 'bgjchggecd',
                    'date': 'hhhegahcf',
                    'api_key': 'edhijefdi',
                },
                'update': {
                    'date': 'hhhegahcf',
                    'api_key': 'edhijefdi',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.LiteLLM_DailyTeamSpendUpdateManyMutationInput,
        where: types.LiteLLM_DailyTeamSpendWhereInput,
    ) -> int:
        """Update multiple LiteLLM_DailyTeamSpend records

        Parameters
        ----------
        data
            LiteLLM_DailyTeamSpend data to update the selected LiteLLM_DailyTeamSpend records to
        where
            Filter to select the LiteLLM_DailyTeamSpend records to update

        Returns
        -------
        int
            The total number of LiteLLM_DailyTeamSpend records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all LiteLLM_DailyTeamSpend records
        total = await LiteLLM_DailyTeamSpend.prisma().update_many(
            data={
                'model_group': 'igggcfjg'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_DailyTeamSpendWhereInput] = None,
        cursor: Optional[types.LiteLLM_DailyTeamSpendWhereUniqueInput] = None,
    ) -> int:
        """Count the number of LiteLLM_DailyTeamSpend records present in the database

        Parameters
        ----------
        select
            Select the LiteLLM_DailyTeamSpend fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            LiteLLM_DailyTeamSpend filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.LiteLLM_DailyTeamSpendCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await LiteLLM_DailyTeamSpend.prisma().count()

        # results: prisma.types.LiteLLM_DailyTeamSpendCountAggregateOutput
        results = await LiteLLM_DailyTeamSpend.prisma().count(
            select={
                '_all': True,
                'custom_llm_provider': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.LiteLLM_DailyTeamSpendCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_DailyTeamSpendWhereInput] = None,
        cursor: Optional[types.LiteLLM_DailyTeamSpendWhereUniqueInput] = None,
    ) -> types.LiteLLM_DailyTeamSpendCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.LiteLLM_DailyTeamSpendCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_DailyTeamSpendWhereInput] = None,
        cursor: Optional[types.LiteLLM_DailyTeamSpendWhereUniqueInput] = None,
    ) -> Union[int, types.LiteLLM_DailyTeamSpendCountAggregateOutput]:
        """Count the number of LiteLLM_DailyTeamSpend records present in the database

        Parameters
        ----------
        select
            Select the LiteLLM_DailyTeamSpend fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            LiteLLM_DailyTeamSpend filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.LiteLLM_DailyTeamSpendCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await LiteLLM_DailyTeamSpend.prisma().count()

        # results: prisma.types.LiteLLM_DailyTeamSpendCountAggregateOutput
        results = await LiteLLM_DailyTeamSpend.prisma().count(
            select={
                '_all': True,
                'mcp_namespaced_tool_name': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.LiteLLM_DailyTeamSpendCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.LiteLLM_DailyTeamSpendWhereInput] = None
    ) -> int:
        """Delete multiple LiteLLM_DailyTeamSpend records.

        Parameters
        ----------
        where
            Optional LiteLLM_DailyTeamSpend filter to find the records to be deleted

        Returns
        -------
        int
            The total number of LiteLLM_DailyTeamSpend records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all LiteLLM_DailyTeamSpend records
        total = await LiteLLM_DailyTeamSpend.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.LiteLLM_DailyTeamSpendScalarFieldKeys'],
        *,
        where: Optional['types.LiteLLM_DailyTeamSpendWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.LiteLLM_DailyTeamSpendAvgAggregateInput'] = None,
        sum: Optional['types.LiteLLM_DailyTeamSpendSumAggregateInput'] = None,
        min: Optional['types.LiteLLM_DailyTeamSpendMinAggregateInput'] = None,
        max: Optional['types.LiteLLM_DailyTeamSpendMaxAggregateInput'] = None,
        having: Optional['types.LiteLLM_DailyTeamSpendScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.LiteLLM_DailyTeamSpendCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.LiteLLM_DailyTeamSpendScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.LiteLLM_DailyTeamSpendScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.LiteLLM_DailyTeamSpendGroupByOutput']:
        """Group LiteLLM_DailyTeamSpend records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar LiteLLM_DailyTeamSpend fields to group records by
        where
            LiteLLM_DailyTeamSpend filter to select records
        take
            Limit the maximum number of LiteLLM_DailyTeamSpend records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.LiteLLM_DailyTeamSpendGroupByOutput]
            A list of dictionaries representing the LiteLLM_DailyTeamSpend record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group LiteLLM_DailyTeamSpend records by prompt_tokens values
        # and count how many records are in each group
        results = await LiteLLM_DailyTeamSpend.prisma().group_by(
            ['prompt_tokens'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class LiteLLM_DailyTagSpendActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: 'Client', model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.LiteLLM_DailyTagSpend]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await LiteLLM_DailyTagSpend.prisma().query_raw(
            'SELECT * FROM LiteLLM_DailyTagSpend WHERE id = $1',
            'bgjhijffjh',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.LiteLLM_DailyTagSpend
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await LiteLLM_DailyTagSpend.prisma().query_first(
            'SELECT * FROM LiteLLM_DailyTagSpend WHERE tag = $1',
            'bcigdhache',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.LiteLLM_DailyTagSpendCreateInput,
        include: Optional[types.LiteLLM_DailyTagSpendInclude] = None
    ) -> _PrismaModelT:
        """Create a new LiteLLM_DailyTagSpend record.

        Parameters
        ----------
        data
            LiteLLM_DailyTagSpend record data
        include
            Specifies which relations should be loaded on the returned LiteLLM_DailyTagSpend model

        Returns
        -------
        prisma.models.LiteLLM_DailyTagSpend
            The created LiteLLM_DailyTagSpend record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a LiteLLM_DailyTagSpend record from just the required fields
        litellm_dailytagspend = await LiteLLM_DailyTagSpend.prisma().create(
            data={
                # data to create a LiteLLM_DailyTagSpend record
                'date': 'igefhgdhb',
                'api_key': 'ejbiifbae',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.LiteLLM_DailyTagSpendCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple LiteLLM_DailyTagSpend records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of LiteLLM_DailyTagSpend record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await LiteLLM_DailyTagSpend.prisma().create_many(
            data=[
                {
                    # data to create a LiteLLM_DailyTagSpend record
                    'date': 'djcfgedjd',
                    'api_key': 'bdbjcdegag',
                },
                {
                    # data to create a LiteLLM_DailyTagSpend record
                    'date': 'hbchfebch',
                    'api_key': 'bcjjffegfc',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.LiteLLM_DailyTagSpendWhereUniqueInput,
        include: Optional[types.LiteLLM_DailyTagSpendInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single LiteLLM_DailyTagSpend record.

        Parameters
        ----------
        where
            LiteLLM_DailyTagSpend filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned LiteLLM_DailyTagSpend model

        Returns
        -------
        prisma.models.LiteLLM_DailyTagSpend
            The deleted LiteLLM_DailyTagSpend record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        litellm_dailytagspend = await LiteLLM_DailyTagSpend.prisma().delete(
            where={
                'id': 'cahaeaicjd',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.LiteLLM_DailyTagSpendWhereUniqueInput,
        include: Optional[types.LiteLLM_DailyTagSpendInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique LiteLLM_DailyTagSpend record.

        Parameters
        ----------
        where
            LiteLLM_DailyTagSpend filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned LiteLLM_DailyTagSpend model

        Returns
        -------
        prisma.models.LiteLLM_DailyTagSpend
            The found LiteLLM_DailyTagSpend record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        litellm_dailytagspend = await LiteLLM_DailyTagSpend.prisma().find_unique(
            where={
                'id': 'ibbjaacbi',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.LiteLLM_DailyTagSpendWhereUniqueInput,
        include: Optional[types.LiteLLM_DailyTagSpendInclude] = None
    ) -> _PrismaModelT:
        """Find a unique LiteLLM_DailyTagSpend record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            LiteLLM_DailyTagSpend filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned LiteLLM_DailyTagSpend model

        Returns
        -------
        prisma.models.LiteLLM_DailyTagSpend
            The found LiteLLM_DailyTagSpend record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        litellm_dailytagspend = await LiteLLM_DailyTagSpend.prisma().find_unique_or_raise(
            where={
                'id': 'djgacbcch',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_DailyTagSpendWhereInput] = None,
        cursor: Optional[types.LiteLLM_DailyTagSpendWhereUniqueInput] = None,
        include: Optional[types.LiteLLM_DailyTagSpendInclude] = None,
        order: Optional[Union[types.LiteLLM_DailyTagSpendOrderByInput, List[types.LiteLLM_DailyTagSpendOrderByInput]]] = None,
        distinct: Optional[List[types.LiteLLM_DailyTagSpendScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple LiteLLM_DailyTagSpend records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of LiteLLM_DailyTagSpend records returned
        skip
            Ignore the first N results
        where
            LiteLLM_DailyTagSpend filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned LiteLLM_DailyTagSpend model
        order
            Order the returned LiteLLM_DailyTagSpend records by any field
        distinct
            Filter LiteLLM_DailyTagSpend records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.LiteLLM_DailyTagSpend]
            The list of all LiteLLM_DailyTagSpend records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 LiteLLM_DailyTagSpend records
        litellm_dailytagspends = await LiteLLM_DailyTagSpend.prisma().find_many(take=10)

        # find the first 5 LiteLLM_DailyTagSpend records ordered by the date field
        litellm_dailytagspends = await LiteLLM_DailyTagSpend.prisma().find_many(
            take=5,
            order={
                'date': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_DailyTagSpendWhereInput] = None,
        cursor: Optional[types.LiteLLM_DailyTagSpendWhereUniqueInput] = None,
        include: Optional[types.LiteLLM_DailyTagSpendInclude] = None,
        order: Optional[Union[types.LiteLLM_DailyTagSpendOrderByInput, List[types.LiteLLM_DailyTagSpendOrderByInput]]] = None,
        distinct: Optional[List[types.LiteLLM_DailyTagSpendScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single LiteLLM_DailyTagSpend record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            LiteLLM_DailyTagSpend filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned LiteLLM_DailyTagSpend model
        order
            Order the returned LiteLLM_DailyTagSpend records by any field
        distinct
            Filter LiteLLM_DailyTagSpend records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.LiteLLM_DailyTagSpend
            The first LiteLLM_DailyTagSpend record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second LiteLLM_DailyTagSpend record ordered by the api_key field
        litellm_dailytagspend = await LiteLLM_DailyTagSpend.prisma().find_first(
            skip=1,
            order={
                'api_key': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_DailyTagSpendWhereInput] = None,
        cursor: Optional[types.LiteLLM_DailyTagSpendWhereUniqueInput] = None,
        include: Optional[types.LiteLLM_DailyTagSpendInclude] = None,
        order: Optional[Union[types.LiteLLM_DailyTagSpendOrderByInput, List[types.LiteLLM_DailyTagSpendOrderByInput]]] = None,
        distinct: Optional[List[types.LiteLLM_DailyTagSpendScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single LiteLLM_DailyTagSpend record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            LiteLLM_DailyTagSpend filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned LiteLLM_DailyTagSpend model
        order
            Order the returned LiteLLM_DailyTagSpend records by any field
        distinct
            Filter LiteLLM_DailyTagSpend records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.LiteLLM_DailyTagSpend
            The first LiteLLM_DailyTagSpend record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second LiteLLM_DailyTagSpend record ordered by the model field
        litellm_dailytagspend = await LiteLLM_DailyTagSpend.prisma().find_first_or_raise(
            skip=1,
            order={
                'model': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.LiteLLM_DailyTagSpendUpdateInput,
        where: types.LiteLLM_DailyTagSpendWhereUniqueInput,
        include: Optional[types.LiteLLM_DailyTagSpendInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single LiteLLM_DailyTagSpend record.

        Parameters
        ----------
        data
            LiteLLM_DailyTagSpend record data specifying what to update
        where
            LiteLLM_DailyTagSpend filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned LiteLLM_DailyTagSpend model

        Returns
        -------
        prisma.models.LiteLLM_DailyTagSpend
            The updated LiteLLM_DailyTagSpend record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        litellm_dailytagspend = await LiteLLM_DailyTagSpend.prisma().update(
            where={
                'id': 'geeeegace',
            },
            data={
                # data to update the LiteLLM_DailyTagSpend record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.LiteLLM_DailyTagSpendWhereUniqueInput,
        data: types.LiteLLM_DailyTagSpendUpsertInput,
        include: Optional[types.LiteLLM_DailyTagSpendInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            LiteLLM_DailyTagSpend filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned LiteLLM_DailyTagSpend model

        Returns
        -------
        prisma.models.LiteLLM_DailyTagSpend
            The created or updated LiteLLM_DailyTagSpend record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        litellm_dailytagspend = await LiteLLM_DailyTagSpend.prisma().upsert(
            where={
                'id': 'bbgdigchd',
            },
            data={
                'create': {
                    'id': 'bbgdigchd',
                    'date': 'hbchfebch',
                    'api_key': 'bcjjffegfc',
                },
                'update': {
                    'date': 'hbchfebch',
                    'api_key': 'bcjjffegfc',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.LiteLLM_DailyTagSpendUpdateManyMutationInput,
        where: types.LiteLLM_DailyTagSpendWhereInput,
    ) -> int:
        """Update multiple LiteLLM_DailyTagSpend records

        Parameters
        ----------
        data
            LiteLLM_DailyTagSpend data to update the selected LiteLLM_DailyTagSpend records to
        where
            Filter to select the LiteLLM_DailyTagSpend records to update

        Returns
        -------
        int
            The total number of LiteLLM_DailyTagSpend records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all LiteLLM_DailyTagSpend records
        total = await LiteLLM_DailyTagSpend.prisma().update_many(
            data={
                'model_group': 'dajcifgdi'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_DailyTagSpendWhereInput] = None,
        cursor: Optional[types.LiteLLM_DailyTagSpendWhereUniqueInput] = None,
    ) -> int:
        """Count the number of LiteLLM_DailyTagSpend records present in the database

        Parameters
        ----------
        select
            Select the LiteLLM_DailyTagSpend fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            LiteLLM_DailyTagSpend filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.LiteLLM_DailyTagSpendCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await LiteLLM_DailyTagSpend.prisma().count()

        # results: prisma.types.LiteLLM_DailyTagSpendCountAggregateOutput
        results = await LiteLLM_DailyTagSpend.prisma().count(
            select={
                '_all': True,
                'custom_llm_provider': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.LiteLLM_DailyTagSpendCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_DailyTagSpendWhereInput] = None,
        cursor: Optional[types.LiteLLM_DailyTagSpendWhereUniqueInput] = None,
    ) -> types.LiteLLM_DailyTagSpendCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.LiteLLM_DailyTagSpendCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_DailyTagSpendWhereInput] = None,
        cursor: Optional[types.LiteLLM_DailyTagSpendWhereUniqueInput] = None,
    ) -> Union[int, types.LiteLLM_DailyTagSpendCountAggregateOutput]:
        """Count the number of LiteLLM_DailyTagSpend records present in the database

        Parameters
        ----------
        select
            Select the LiteLLM_DailyTagSpend fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            LiteLLM_DailyTagSpend filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.LiteLLM_DailyTagSpendCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await LiteLLM_DailyTagSpend.prisma().count()

        # results: prisma.types.LiteLLM_DailyTagSpendCountAggregateOutput
        results = await LiteLLM_DailyTagSpend.prisma().count(
            select={
                '_all': True,
                'mcp_namespaced_tool_name': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.LiteLLM_DailyTagSpendCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.LiteLLM_DailyTagSpendWhereInput] = None
    ) -> int:
        """Delete multiple LiteLLM_DailyTagSpend records.

        Parameters
        ----------
        where
            Optional LiteLLM_DailyTagSpend filter to find the records to be deleted

        Returns
        -------
        int
            The total number of LiteLLM_DailyTagSpend records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all LiteLLM_DailyTagSpend records
        total = await LiteLLM_DailyTagSpend.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.LiteLLM_DailyTagSpendScalarFieldKeys'],
        *,
        where: Optional['types.LiteLLM_DailyTagSpendWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.LiteLLM_DailyTagSpendAvgAggregateInput'] = None,
        sum: Optional['types.LiteLLM_DailyTagSpendSumAggregateInput'] = None,
        min: Optional['types.LiteLLM_DailyTagSpendMinAggregateInput'] = None,
        max: Optional['types.LiteLLM_DailyTagSpendMaxAggregateInput'] = None,
        having: Optional['types.LiteLLM_DailyTagSpendScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.LiteLLM_DailyTagSpendCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.LiteLLM_DailyTagSpendScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.LiteLLM_DailyTagSpendScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.LiteLLM_DailyTagSpendGroupByOutput']:
        """Group LiteLLM_DailyTagSpend records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar LiteLLM_DailyTagSpend fields to group records by
        where
            LiteLLM_DailyTagSpend filter to select records
        take
            Limit the maximum number of LiteLLM_DailyTagSpend records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.LiteLLM_DailyTagSpendGroupByOutput]
            A list of dictionaries representing the LiteLLM_DailyTagSpend record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group LiteLLM_DailyTagSpend records by prompt_tokens values
        # and count how many records are in each group
        results = await LiteLLM_DailyTagSpend.prisma().group_by(
            ['prompt_tokens'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class LiteLLM_CronJobActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: 'Client', model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.LiteLLM_CronJob]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await LiteLLM_CronJob.prisma().query_raw(
            'SELECT * FROM LiteLLM_CronJob WHERE cronjob_id = $1',
            'ccedhdbj',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.LiteLLM_CronJob
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await LiteLLM_CronJob.prisma().query_first(
            'SELECT * FROM LiteLLM_CronJob WHERE pod_id = $1',
            'bjaabjjjce',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.LiteLLM_CronJobCreateInput,
        include: Optional[types.LiteLLM_CronJobInclude] = None
    ) -> _PrismaModelT:
        """Create a new LiteLLM_CronJob record.

        Parameters
        ----------
        data
            LiteLLM_CronJob record data
        include
            Specifies which relations should be loaded on the returned LiteLLM_CronJob model

        Returns
        -------
        prisma.models.LiteLLM_CronJob
            The created LiteLLM_CronJob record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a LiteLLM_CronJob record from just the required fields
        litellm_cronjob = await LiteLLM_CronJob.prisma().create(
            data={
                # data to create a LiteLLM_CronJob record
                'pod_id': 'cafhdcdcjd',
                'ttl': datetime.datetime.utcnow(),
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.LiteLLM_CronJobCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple LiteLLM_CronJob records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of LiteLLM_CronJob record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await LiteLLM_CronJob.prisma().create_many(
            data=[
                {
                    # data to create a LiteLLM_CronJob record
                    'pod_id': 'bdeebbhbdi',
                    'ttl': datetime.datetime.utcnow(),
                },
                {
                    # data to create a LiteLLM_CronJob record
                    'pod_id': 'cafcbdchah',
                    'ttl': datetime.datetime.utcnow(),
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.LiteLLM_CronJobWhereUniqueInput,
        include: Optional[types.LiteLLM_CronJobInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single LiteLLM_CronJob record.

        Parameters
        ----------
        where
            LiteLLM_CronJob filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned LiteLLM_CronJob model

        Returns
        -------
        prisma.models.LiteLLM_CronJob
            The deleted LiteLLM_CronJob record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        litellm_cronjob = await LiteLLM_CronJob.prisma().delete(
            where={
                'cronjob_id': 'bdffbehbae',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.LiteLLM_CronJobWhereUniqueInput,
        include: Optional[types.LiteLLM_CronJobInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique LiteLLM_CronJob record.

        Parameters
        ----------
        where
            LiteLLM_CronJob filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned LiteLLM_CronJob model

        Returns
        -------
        prisma.models.LiteLLM_CronJob
            The found LiteLLM_CronJob record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        litellm_cronjob = await LiteLLM_CronJob.prisma().find_unique(
            where={
                'cronjob_id': 'ieahjgeb',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.LiteLLM_CronJobWhereUniqueInput,
        include: Optional[types.LiteLLM_CronJobInclude] = None
    ) -> _PrismaModelT:
        """Find a unique LiteLLM_CronJob record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            LiteLLM_CronJob filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned LiteLLM_CronJob model

        Returns
        -------
        prisma.models.LiteLLM_CronJob
            The found LiteLLM_CronJob record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        litellm_cronjob = await LiteLLM_CronJob.prisma().find_unique_or_raise(
            where={
                'cronjob_id': 'hfeeddceg',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_CronJobWhereInput] = None,
        cursor: Optional[types.LiteLLM_CronJobWhereUniqueInput] = None,
        include: Optional[types.LiteLLM_CronJobInclude] = None,
        order: Optional[Union[types.LiteLLM_CronJobOrderByInput, List[types.LiteLLM_CronJobOrderByInput]]] = None,
        distinct: Optional[List[types.LiteLLM_CronJobScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple LiteLLM_CronJob records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of LiteLLM_CronJob records returned
        skip
            Ignore the first N results
        where
            LiteLLM_CronJob filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned LiteLLM_CronJob model
        order
            Order the returned LiteLLM_CronJob records by any field
        distinct
            Filter LiteLLM_CronJob records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.LiteLLM_CronJob]
            The list of all LiteLLM_CronJob records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 LiteLLM_CronJob records
        litellm_cronjobs = await LiteLLM_CronJob.prisma().find_many(take=10)

        # find the first 5 LiteLLM_CronJob records ordered by the status field
        litellm_cronjobs = await LiteLLM_CronJob.prisma().find_many(
            take=5,
            order={
                'status': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_CronJobWhereInput] = None,
        cursor: Optional[types.LiteLLM_CronJobWhereUniqueInput] = None,
        include: Optional[types.LiteLLM_CronJobInclude] = None,
        order: Optional[Union[types.LiteLLM_CronJobOrderByInput, List[types.LiteLLM_CronJobOrderByInput]]] = None,
        distinct: Optional[List[types.LiteLLM_CronJobScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single LiteLLM_CronJob record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            LiteLLM_CronJob filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned LiteLLM_CronJob model
        order
            Order the returned LiteLLM_CronJob records by any field
        distinct
            Filter LiteLLM_CronJob records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.LiteLLM_CronJob
            The first LiteLLM_CronJob record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second LiteLLM_CronJob record ordered by the last_updated field
        litellm_cronjob = await LiteLLM_CronJob.prisma().find_first(
            skip=1,
            order={
                'last_updated': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_CronJobWhereInput] = None,
        cursor: Optional[types.LiteLLM_CronJobWhereUniqueInput] = None,
        include: Optional[types.LiteLLM_CronJobInclude] = None,
        order: Optional[Union[types.LiteLLM_CronJobOrderByInput, List[types.LiteLLM_CronJobOrderByInput]]] = None,
        distinct: Optional[List[types.LiteLLM_CronJobScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single LiteLLM_CronJob record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            LiteLLM_CronJob filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned LiteLLM_CronJob model
        order
            Order the returned LiteLLM_CronJob records by any field
        distinct
            Filter LiteLLM_CronJob records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.LiteLLM_CronJob
            The first LiteLLM_CronJob record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second LiteLLM_CronJob record ordered by the ttl field
        litellm_cronjob = await LiteLLM_CronJob.prisma().find_first_or_raise(
            skip=1,
            order={
                'ttl': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.LiteLLM_CronJobUpdateInput,
        where: types.LiteLLM_CronJobWhereUniqueInput,
        include: Optional[types.LiteLLM_CronJobInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single LiteLLM_CronJob record.

        Parameters
        ----------
        data
            LiteLLM_CronJob record data specifying what to update
        where
            LiteLLM_CronJob filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned LiteLLM_CronJob model

        Returns
        -------
        prisma.models.LiteLLM_CronJob
            The updated LiteLLM_CronJob record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        litellm_cronjob = await LiteLLM_CronJob.prisma().update(
            where={
                'cronjob_id': 'dbecgbbid',
            },
            data={
                # data to update the LiteLLM_CronJob record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.LiteLLM_CronJobWhereUniqueInput,
        data: types.LiteLLM_CronJobUpsertInput,
        include: Optional[types.LiteLLM_CronJobInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            LiteLLM_CronJob filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned LiteLLM_CronJob model

        Returns
        -------
        prisma.models.LiteLLM_CronJob
            The created or updated LiteLLM_CronJob record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        litellm_cronjob = await LiteLLM_CronJob.prisma().upsert(
            where={
                'cronjob_id': 'cchghigae',
            },
            data={
                'create': {
                    'cronjob_id': 'cchghigae',
                    'pod_id': 'cafcbdchah',
                    'ttl': datetime.datetime.utcnow(),
                },
                'update': {
                    'pod_id': 'cafcbdchah',
                    'ttl': datetime.datetime.utcnow(),
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.LiteLLM_CronJobUpdateManyMutationInput,
        where: types.LiteLLM_CronJobWhereInput,
    ) -> int:
        """Update multiple LiteLLM_CronJob records

        Parameters
        ----------
        data
            LiteLLM_CronJob data to update the selected LiteLLM_CronJob records to
        where
            Filter to select the LiteLLM_CronJob records to update

        Returns
        -------
        int
            The total number of LiteLLM_CronJob records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all LiteLLM_CronJob records
        total = await LiteLLM_CronJob.prisma().update_many(
            data={
                'cronjob_id': 'ecdjjjhab'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_CronJobWhereInput] = None,
        cursor: Optional[types.LiteLLM_CronJobWhereUniqueInput] = None,
    ) -> int:
        """Count the number of LiteLLM_CronJob records present in the database

        Parameters
        ----------
        select
            Select the LiteLLM_CronJob fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            LiteLLM_CronJob filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.LiteLLM_CronJobCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await LiteLLM_CronJob.prisma().count()

        # results: prisma.types.LiteLLM_CronJobCountAggregateOutput
        results = await LiteLLM_CronJob.prisma().count(
            select={
                '_all': True,
                'pod_id': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.LiteLLM_CronJobCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_CronJobWhereInput] = None,
        cursor: Optional[types.LiteLLM_CronJobWhereUniqueInput] = None,
    ) -> types.LiteLLM_CronJobCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.LiteLLM_CronJobCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_CronJobWhereInput] = None,
        cursor: Optional[types.LiteLLM_CronJobWhereUniqueInput] = None,
    ) -> Union[int, types.LiteLLM_CronJobCountAggregateOutput]:
        """Count the number of LiteLLM_CronJob records present in the database

        Parameters
        ----------
        select
            Select the LiteLLM_CronJob fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            LiteLLM_CronJob filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.LiteLLM_CronJobCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await LiteLLM_CronJob.prisma().count()

        # results: prisma.types.LiteLLM_CronJobCountAggregateOutput
        results = await LiteLLM_CronJob.prisma().count(
            select={
                '_all': True,
                'status': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.LiteLLM_CronJobCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.LiteLLM_CronJobWhereInput] = None
    ) -> int:
        """Delete multiple LiteLLM_CronJob records.

        Parameters
        ----------
        where
            Optional LiteLLM_CronJob filter to find the records to be deleted

        Returns
        -------
        int
            The total number of LiteLLM_CronJob records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all LiteLLM_CronJob records
        total = await LiteLLM_CronJob.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.LiteLLM_CronJobScalarFieldKeys'],
        *,
        where: Optional['types.LiteLLM_CronJobWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.LiteLLM_CronJobAvgAggregateInput'] = None,
        sum: Optional['types.LiteLLM_CronJobSumAggregateInput'] = None,
        min: Optional['types.LiteLLM_CronJobMinAggregateInput'] = None,
        max: Optional['types.LiteLLM_CronJobMaxAggregateInput'] = None,
        having: Optional['types.LiteLLM_CronJobScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.LiteLLM_CronJobCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.LiteLLM_CronJobScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.LiteLLM_CronJobScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.LiteLLM_CronJobGroupByOutput']:
        """Group LiteLLM_CronJob records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar LiteLLM_CronJob fields to group records by
        where
            LiteLLM_CronJob filter to select records
        take
            Limit the maximum number of LiteLLM_CronJob records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.LiteLLM_CronJobGroupByOutput]
            A list of dictionaries representing the LiteLLM_CronJob record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group LiteLLM_CronJob records by last_updated values
        # and count how many records are in each group
        results = await LiteLLM_CronJob.prisma().group_by(
            ['last_updated'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class LiteLLM_ManagedFileTableActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: 'Client', model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.LiteLLM_ManagedFileTable]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await LiteLLM_ManagedFileTable.prisma().query_raw(
            'SELECT * FROM LiteLLM_ManagedFileTable WHERE id = $1',
            'biachfede',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.LiteLLM_ManagedFileTable
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await LiteLLM_ManagedFileTable.prisma().query_first(
            'SELECT * FROM LiteLLM_ManagedFileTable WHERE unified_file_id = $1',
            'fhgaibff',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.LiteLLM_ManagedFileTableCreateInput,
        include: Optional[types.LiteLLM_ManagedFileTableInclude] = None
    ) -> _PrismaModelT:
        """Create a new LiteLLM_ManagedFileTable record.

        Parameters
        ----------
        data
            LiteLLM_ManagedFileTable record data
        include
            Specifies which relations should be loaded on the returned LiteLLM_ManagedFileTable model

        Returns
        -------
        prisma.models.LiteLLM_ManagedFileTable
            The created LiteLLM_ManagedFileTable record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a LiteLLM_ManagedFileTable record from just the required fields
        litellm_managedfiletable = await LiteLLM_ManagedFileTable.prisma().create(
            data={
                # data to create a LiteLLM_ManagedFileTable record
                'unified_file_id': 'cadajbcbca',
                'model_mappings': Json({'bjheigfcdd': True}),
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.LiteLLM_ManagedFileTableCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple LiteLLM_ManagedFileTable records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of LiteLLM_ManagedFileTable record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await LiteLLM_ManagedFileTable.prisma().create_many(
            data=[
                {
                    # data to create a LiteLLM_ManagedFileTable record
                    'unified_file_id': 'bjejigcdcg',
                    'model_mappings': Json({'bifiiibcah': True}),
                },
                {
                    # data to create a LiteLLM_ManagedFileTable record
                    'unified_file_id': 'dbjibjdaa',
                    'model_mappings': Json({'dgijbdiaf': True}),
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.LiteLLM_ManagedFileTableWhereUniqueInput,
        include: Optional[types.LiteLLM_ManagedFileTableInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single LiteLLM_ManagedFileTable record.

        Parameters
        ----------
        where
            LiteLLM_ManagedFileTable filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned LiteLLM_ManagedFileTable model

        Returns
        -------
        prisma.models.LiteLLM_ManagedFileTable
            The deleted LiteLLM_ManagedFileTable record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        litellm_managedfiletable = await LiteLLM_ManagedFileTable.prisma().delete(
            where={
                'id': 'begfaigba',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.LiteLLM_ManagedFileTableWhereUniqueInput,
        include: Optional[types.LiteLLM_ManagedFileTableInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique LiteLLM_ManagedFileTable record.

        Parameters
        ----------
        where
            LiteLLM_ManagedFileTable filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned LiteLLM_ManagedFileTable model

        Returns
        -------
        prisma.models.LiteLLM_ManagedFileTable
            The found LiteLLM_ManagedFileTable record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        litellm_managedfiletable = await LiteLLM_ManagedFileTable.prisma().find_unique(
            where={
                'id': 'bdjiafcgjb',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.LiteLLM_ManagedFileTableWhereUniqueInput,
        include: Optional[types.LiteLLM_ManagedFileTableInclude] = None
    ) -> _PrismaModelT:
        """Find a unique LiteLLM_ManagedFileTable record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            LiteLLM_ManagedFileTable filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned LiteLLM_ManagedFileTable model

        Returns
        -------
        prisma.models.LiteLLM_ManagedFileTable
            The found LiteLLM_ManagedFileTable record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        litellm_managedfiletable = await LiteLLM_ManagedFileTable.prisma().find_unique_or_raise(
            where={
                'id': 'bficecgcfg',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_ManagedFileTableWhereInput] = None,
        cursor: Optional[types.LiteLLM_ManagedFileTableWhereUniqueInput] = None,
        include: Optional[types.LiteLLM_ManagedFileTableInclude] = None,
        order: Optional[Union[types.LiteLLM_ManagedFileTableOrderByInput, List[types.LiteLLM_ManagedFileTableOrderByInput]]] = None,
        distinct: Optional[List[types.LiteLLM_ManagedFileTableScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple LiteLLM_ManagedFileTable records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of LiteLLM_ManagedFileTable records returned
        skip
            Ignore the first N results
        where
            LiteLLM_ManagedFileTable filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned LiteLLM_ManagedFileTable model
        order
            Order the returned LiteLLM_ManagedFileTable records by any field
        distinct
            Filter LiteLLM_ManagedFileTable records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.LiteLLM_ManagedFileTable]
            The list of all LiteLLM_ManagedFileTable records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 LiteLLM_ManagedFileTable records
        litellm_managedfiletables = await LiteLLM_ManagedFileTable.prisma().find_many(take=10)

        # find the first 5 LiteLLM_ManagedFileTable records ordered by the file_object field
        litellm_managedfiletables = await LiteLLM_ManagedFileTable.prisma().find_many(
            take=5,
            order={
                'file_object': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_ManagedFileTableWhereInput] = None,
        cursor: Optional[types.LiteLLM_ManagedFileTableWhereUniqueInput] = None,
        include: Optional[types.LiteLLM_ManagedFileTableInclude] = None,
        order: Optional[Union[types.LiteLLM_ManagedFileTableOrderByInput, List[types.LiteLLM_ManagedFileTableOrderByInput]]] = None,
        distinct: Optional[List[types.LiteLLM_ManagedFileTableScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single LiteLLM_ManagedFileTable record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            LiteLLM_ManagedFileTable filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned LiteLLM_ManagedFileTable model
        order
            Order the returned LiteLLM_ManagedFileTable records by any field
        distinct
            Filter LiteLLM_ManagedFileTable records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.LiteLLM_ManagedFileTable
            The first LiteLLM_ManagedFileTable record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second LiteLLM_ManagedFileTable record ordered by the model_mappings field
        litellm_managedfiletable = await LiteLLM_ManagedFileTable.prisma().find_first(
            skip=1,
            order={
                'model_mappings': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_ManagedFileTableWhereInput] = None,
        cursor: Optional[types.LiteLLM_ManagedFileTableWhereUniqueInput] = None,
        include: Optional[types.LiteLLM_ManagedFileTableInclude] = None,
        order: Optional[Union[types.LiteLLM_ManagedFileTableOrderByInput, List[types.LiteLLM_ManagedFileTableOrderByInput]]] = None,
        distinct: Optional[List[types.LiteLLM_ManagedFileTableScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single LiteLLM_ManagedFileTable record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            LiteLLM_ManagedFileTable filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned LiteLLM_ManagedFileTable model
        order
            Order the returned LiteLLM_ManagedFileTable records by any field
        distinct
            Filter LiteLLM_ManagedFileTable records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.LiteLLM_ManagedFileTable
            The first LiteLLM_ManagedFileTable record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second LiteLLM_ManagedFileTable record ordered by the flat_model_file_ids field
        litellm_managedfiletable = await LiteLLM_ManagedFileTable.prisma().find_first_or_raise(
            skip=1,
            order={
                'flat_model_file_ids': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.LiteLLM_ManagedFileTableUpdateInput,
        where: types.LiteLLM_ManagedFileTableWhereUniqueInput,
        include: Optional[types.LiteLLM_ManagedFileTableInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single LiteLLM_ManagedFileTable record.

        Parameters
        ----------
        data
            LiteLLM_ManagedFileTable record data specifying what to update
        where
            LiteLLM_ManagedFileTable filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned LiteLLM_ManagedFileTable model

        Returns
        -------
        prisma.models.LiteLLM_ManagedFileTable
            The updated LiteLLM_ManagedFileTable record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        litellm_managedfiletable = await LiteLLM_ManagedFileTable.prisma().update(
            where={
                'id': 'cbjjeedcj',
            },
            data={
                # data to update the LiteLLM_ManagedFileTable record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.LiteLLM_ManagedFileTableWhereUniqueInput,
        data: types.LiteLLM_ManagedFileTableUpsertInput,
        include: Optional[types.LiteLLM_ManagedFileTableInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            LiteLLM_ManagedFileTable filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned LiteLLM_ManagedFileTable model

        Returns
        -------
        prisma.models.LiteLLM_ManagedFileTable
            The created or updated LiteLLM_ManagedFileTable record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        litellm_managedfiletable = await LiteLLM_ManagedFileTable.prisma().upsert(
            where={
                'id': 'dedgbbhja',
            },
            data={
                'create': {
                    'id': 'dedgbbhja',
                    'unified_file_id': 'dbjibjdaa',
                    'model_mappings': Json({'dgijbdiaf': True}),
                },
                'update': {
                    'unified_file_id': 'dbjibjdaa',
                    'model_mappings': Json({'dgijbdiaf': True}),
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.LiteLLM_ManagedFileTableUpdateManyMutationInput,
        where: types.LiteLLM_ManagedFileTableWhereInput,
    ) -> int:
        """Update multiple LiteLLM_ManagedFileTable records

        Parameters
        ----------
        data
            LiteLLM_ManagedFileTable data to update the selected LiteLLM_ManagedFileTable records to
        where
            Filter to select the LiteLLM_ManagedFileTable records to update

        Returns
        -------
        int
            The total number of LiteLLM_ManagedFileTable records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all LiteLLM_ManagedFileTable records
        total = await LiteLLM_ManagedFileTable.prisma().update_many(
            data={
                'created_at': datetime.datetime.utcnow()
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_ManagedFileTableWhereInput] = None,
        cursor: Optional[types.LiteLLM_ManagedFileTableWhereUniqueInput] = None,
    ) -> int:
        """Count the number of LiteLLM_ManagedFileTable records present in the database

        Parameters
        ----------
        select
            Select the LiteLLM_ManagedFileTable fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            LiteLLM_ManagedFileTable filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.LiteLLM_ManagedFileTableCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await LiteLLM_ManagedFileTable.prisma().count()

        # results: prisma.types.LiteLLM_ManagedFileTableCountAggregateOutput
        results = await LiteLLM_ManagedFileTable.prisma().count(
            select={
                '_all': True,
                'created_by': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.LiteLLM_ManagedFileTableCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_ManagedFileTableWhereInput] = None,
        cursor: Optional[types.LiteLLM_ManagedFileTableWhereUniqueInput] = None,
    ) -> types.LiteLLM_ManagedFileTableCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.LiteLLM_ManagedFileTableCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_ManagedFileTableWhereInput] = None,
        cursor: Optional[types.LiteLLM_ManagedFileTableWhereUniqueInput] = None,
    ) -> Union[int, types.LiteLLM_ManagedFileTableCountAggregateOutput]:
        """Count the number of LiteLLM_ManagedFileTable records present in the database

        Parameters
        ----------
        select
            Select the LiteLLM_ManagedFileTable fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            LiteLLM_ManagedFileTable filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.LiteLLM_ManagedFileTableCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await LiteLLM_ManagedFileTable.prisma().count()

        # results: prisma.types.LiteLLM_ManagedFileTableCountAggregateOutput
        results = await LiteLLM_ManagedFileTable.prisma().count(
            select={
                '_all': True,
                'updated_at': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.LiteLLM_ManagedFileTableCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.LiteLLM_ManagedFileTableWhereInput] = None
    ) -> int:
        """Delete multiple LiteLLM_ManagedFileTable records.

        Parameters
        ----------
        where
            Optional LiteLLM_ManagedFileTable filter to find the records to be deleted

        Returns
        -------
        int
            The total number of LiteLLM_ManagedFileTable records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all LiteLLM_ManagedFileTable records
        total = await LiteLLM_ManagedFileTable.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.LiteLLM_ManagedFileTableScalarFieldKeys'],
        *,
        where: Optional['types.LiteLLM_ManagedFileTableWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.LiteLLM_ManagedFileTableAvgAggregateInput'] = None,
        sum: Optional['types.LiteLLM_ManagedFileTableSumAggregateInput'] = None,
        min: Optional['types.LiteLLM_ManagedFileTableMinAggregateInput'] = None,
        max: Optional['types.LiteLLM_ManagedFileTableMaxAggregateInput'] = None,
        having: Optional['types.LiteLLM_ManagedFileTableScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.LiteLLM_ManagedFileTableCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.LiteLLM_ManagedFileTableScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.LiteLLM_ManagedFileTableScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.LiteLLM_ManagedFileTableGroupByOutput']:
        """Group LiteLLM_ManagedFileTable records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar LiteLLM_ManagedFileTable fields to group records by
        where
            LiteLLM_ManagedFileTable filter to select records
        take
            Limit the maximum number of LiteLLM_ManagedFileTable records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.LiteLLM_ManagedFileTableGroupByOutput]
            A list of dictionaries representing the LiteLLM_ManagedFileTable record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group LiteLLM_ManagedFileTable records by updated_by values
        # and count how many records are in each group
        results = await LiteLLM_ManagedFileTable.prisma().group_by(
            ['updated_by'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class LiteLLM_ManagedObjectTableActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: 'Client', model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.LiteLLM_ManagedObjectTable]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await LiteLLM_ManagedObjectTable.prisma().query_raw(
            'SELECT * FROM LiteLLM_ManagedObjectTable WHERE id = $1',
            'cabiahchj',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.LiteLLM_ManagedObjectTable
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await LiteLLM_ManagedObjectTable.prisma().query_first(
            'SELECT * FROM LiteLLM_ManagedObjectTable WHERE unified_object_id = $1',
            'cgbeccfce',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.LiteLLM_ManagedObjectTableCreateInput,
        include: Optional[types.LiteLLM_ManagedObjectTableInclude] = None
    ) -> _PrismaModelT:
        """Create a new LiteLLM_ManagedObjectTable record.

        Parameters
        ----------
        data
            LiteLLM_ManagedObjectTable record data
        include
            Specifies which relations should be loaded on the returned LiteLLM_ManagedObjectTable model

        Returns
        -------
        prisma.models.LiteLLM_ManagedObjectTable
            The created LiteLLM_ManagedObjectTable record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a LiteLLM_ManagedObjectTable record from just the required fields
        litellm_managedobjecttable = await LiteLLM_ManagedObjectTable.prisma().create(
            data={
                # data to create a LiteLLM_ManagedObjectTable record
                'unified_object_id': 'fcjcagef',
                'model_object_id': 'bgdhaeacic',
                'file_object': Json({'caffafcheh': True}),
                'file_purpose': 'fjjbegge',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.LiteLLM_ManagedObjectTableCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple LiteLLM_ManagedObjectTable records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of LiteLLM_ManagedObjectTable record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await LiteLLM_ManagedObjectTable.prisma().create_many(
            data=[
                {
                    # data to create a LiteLLM_ManagedObjectTable record
                    'unified_object_id': 'bdiifhbieb',
                    'model_object_id': 'cdcaejhgg',
                    'file_object': Json({'jbijgfbfj': True}),
                    'file_purpose': 'ggfbeddia',
                },
                {
                    # data to create a LiteLLM_ManagedObjectTable record
                    'unified_object_id': 'djjejdaj',
                    'model_object_id': 'bjabbfceji',
                    'file_object': Json({'bgchfbjibb': True}),
                    'file_purpose': 'bajecchdjc',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.LiteLLM_ManagedObjectTableWhereUniqueInput,
        include: Optional[types.LiteLLM_ManagedObjectTableInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single LiteLLM_ManagedObjectTable record.

        Parameters
        ----------
        where
            LiteLLM_ManagedObjectTable filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned LiteLLM_ManagedObjectTable model

        Returns
        -------
        prisma.models.LiteLLM_ManagedObjectTable
            The deleted LiteLLM_ManagedObjectTable record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        litellm_managedobjecttable = await LiteLLM_ManagedObjectTable.prisma().delete(
            where={
                'id': 'dfgacajif',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.LiteLLM_ManagedObjectTableWhereUniqueInput,
        include: Optional[types.LiteLLM_ManagedObjectTableInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique LiteLLM_ManagedObjectTable record.

        Parameters
        ----------
        where
            LiteLLM_ManagedObjectTable filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned LiteLLM_ManagedObjectTable model

        Returns
        -------
        prisma.models.LiteLLM_ManagedObjectTable
            The found LiteLLM_ManagedObjectTable record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        litellm_managedobjecttable = await LiteLLM_ManagedObjectTable.prisma().find_unique(
            where={
                'id': 'bgdiddfadi',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.LiteLLM_ManagedObjectTableWhereUniqueInput,
        include: Optional[types.LiteLLM_ManagedObjectTableInclude] = None
    ) -> _PrismaModelT:
        """Find a unique LiteLLM_ManagedObjectTable record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            LiteLLM_ManagedObjectTable filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned LiteLLM_ManagedObjectTable model

        Returns
        -------
        prisma.models.LiteLLM_ManagedObjectTable
            The found LiteLLM_ManagedObjectTable record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        litellm_managedobjecttable = await LiteLLM_ManagedObjectTable.prisma().find_unique_or_raise(
            where={
                'id': 'bijbfghhhf',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_ManagedObjectTableWhereInput] = None,
        cursor: Optional[types.LiteLLM_ManagedObjectTableWhereUniqueInput] = None,
        include: Optional[types.LiteLLM_ManagedObjectTableInclude] = None,
        order: Optional[Union[types.LiteLLM_ManagedObjectTableOrderByInput, List[types.LiteLLM_ManagedObjectTableOrderByInput]]] = None,
        distinct: Optional[List[types.LiteLLM_ManagedObjectTableScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple LiteLLM_ManagedObjectTable records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of LiteLLM_ManagedObjectTable records returned
        skip
            Ignore the first N results
        where
            LiteLLM_ManagedObjectTable filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned LiteLLM_ManagedObjectTable model
        order
            Order the returned LiteLLM_ManagedObjectTable records by any field
        distinct
            Filter LiteLLM_ManagedObjectTable records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.LiteLLM_ManagedObjectTable]
            The list of all LiteLLM_ManagedObjectTable records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 LiteLLM_ManagedObjectTable records
        litellm_managedobjecttables = await LiteLLM_ManagedObjectTable.prisma().find_many(take=10)

        # find the first 5 LiteLLM_ManagedObjectTable records ordered by the model_object_id field
        litellm_managedobjecttables = await LiteLLM_ManagedObjectTable.prisma().find_many(
            take=5,
            order={
                'model_object_id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_ManagedObjectTableWhereInput] = None,
        cursor: Optional[types.LiteLLM_ManagedObjectTableWhereUniqueInput] = None,
        include: Optional[types.LiteLLM_ManagedObjectTableInclude] = None,
        order: Optional[Union[types.LiteLLM_ManagedObjectTableOrderByInput, List[types.LiteLLM_ManagedObjectTableOrderByInput]]] = None,
        distinct: Optional[List[types.LiteLLM_ManagedObjectTableScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single LiteLLM_ManagedObjectTable record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            LiteLLM_ManagedObjectTable filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned LiteLLM_ManagedObjectTable model
        order
            Order the returned LiteLLM_ManagedObjectTable records by any field
        distinct
            Filter LiteLLM_ManagedObjectTable records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.LiteLLM_ManagedObjectTable
            The first LiteLLM_ManagedObjectTable record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second LiteLLM_ManagedObjectTable record ordered by the file_object field
        litellm_managedobjecttable = await LiteLLM_ManagedObjectTable.prisma().find_first(
            skip=1,
            order={
                'file_object': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_ManagedObjectTableWhereInput] = None,
        cursor: Optional[types.LiteLLM_ManagedObjectTableWhereUniqueInput] = None,
        include: Optional[types.LiteLLM_ManagedObjectTableInclude] = None,
        order: Optional[Union[types.LiteLLM_ManagedObjectTableOrderByInput, List[types.LiteLLM_ManagedObjectTableOrderByInput]]] = None,
        distinct: Optional[List[types.LiteLLM_ManagedObjectTableScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single LiteLLM_ManagedObjectTable record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            LiteLLM_ManagedObjectTable filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned LiteLLM_ManagedObjectTable model
        order
            Order the returned LiteLLM_ManagedObjectTable records by any field
        distinct
            Filter LiteLLM_ManagedObjectTable records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.LiteLLM_ManagedObjectTable
            The first LiteLLM_ManagedObjectTable record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second LiteLLM_ManagedObjectTable record ordered by the file_purpose field
        litellm_managedobjecttable = await LiteLLM_ManagedObjectTable.prisma().find_first_or_raise(
            skip=1,
            order={
                'file_purpose': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.LiteLLM_ManagedObjectTableUpdateInput,
        where: types.LiteLLM_ManagedObjectTableWhereUniqueInput,
        include: Optional[types.LiteLLM_ManagedObjectTableInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single LiteLLM_ManagedObjectTable record.

        Parameters
        ----------
        data
            LiteLLM_ManagedObjectTable record data specifying what to update
        where
            LiteLLM_ManagedObjectTable filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned LiteLLM_ManagedObjectTable model

        Returns
        -------
        prisma.models.LiteLLM_ManagedObjectTable
            The updated LiteLLM_ManagedObjectTable record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        litellm_managedobjecttable = await LiteLLM_ManagedObjectTable.prisma().update(
            where={
                'id': 'bahchhihdc',
            },
            data={
                # data to update the LiteLLM_ManagedObjectTable record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.LiteLLM_ManagedObjectTableWhereUniqueInput,
        data: types.LiteLLM_ManagedObjectTableUpsertInput,
        include: Optional[types.LiteLLM_ManagedObjectTableInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            LiteLLM_ManagedObjectTable filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned LiteLLM_ManagedObjectTable model

        Returns
        -------
        prisma.models.LiteLLM_ManagedObjectTable
            The created or updated LiteLLM_ManagedObjectTable record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        litellm_managedobjecttable = await LiteLLM_ManagedObjectTable.prisma().upsert(
            where={
                'id': 'bihjdcibib',
            },
            data={
                'create': {
                    'id': 'bihjdcibib',
                    'unified_object_id': 'djjejdaj',
                    'model_object_id': 'bjabbfceji',
                    'file_object': Json({'bgchfbjibb': True}),
                    'file_purpose': 'bajecchdjc',
                },
                'update': {
                    'unified_object_id': 'djjejdaj',
                    'model_object_id': 'bjabbfceji',
                    'file_object': Json({'bgchfbjibb': True}),
                    'file_purpose': 'bajecchdjc',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.LiteLLM_ManagedObjectTableUpdateManyMutationInput,
        where: types.LiteLLM_ManagedObjectTableWhereInput,
    ) -> int:
        """Update multiple LiteLLM_ManagedObjectTable records

        Parameters
        ----------
        data
            LiteLLM_ManagedObjectTable data to update the selected LiteLLM_ManagedObjectTable records to
        where
            Filter to select the LiteLLM_ManagedObjectTable records to update

        Returns
        -------
        int
            The total number of LiteLLM_ManagedObjectTable records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all LiteLLM_ManagedObjectTable records
        total = await LiteLLM_ManagedObjectTable.prisma().update_many(
            data={
                'status': 'bfhhjbbdha'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_ManagedObjectTableWhereInput] = None,
        cursor: Optional[types.LiteLLM_ManagedObjectTableWhereUniqueInput] = None,
    ) -> int:
        """Count the number of LiteLLM_ManagedObjectTable records present in the database

        Parameters
        ----------
        select
            Select the LiteLLM_ManagedObjectTable fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            LiteLLM_ManagedObjectTable filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.LiteLLM_ManagedObjectTableCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await LiteLLM_ManagedObjectTable.prisma().count()

        # results: prisma.types.LiteLLM_ManagedObjectTableCountAggregateOutput
        results = await LiteLLM_ManagedObjectTable.prisma().count(
            select={
                '_all': True,
                'created_at': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.LiteLLM_ManagedObjectTableCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_ManagedObjectTableWhereInput] = None,
        cursor: Optional[types.LiteLLM_ManagedObjectTableWhereUniqueInput] = None,
    ) -> types.LiteLLM_ManagedObjectTableCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.LiteLLM_ManagedObjectTableCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_ManagedObjectTableWhereInput] = None,
        cursor: Optional[types.LiteLLM_ManagedObjectTableWhereUniqueInput] = None,
    ) -> Union[int, types.LiteLLM_ManagedObjectTableCountAggregateOutput]:
        """Count the number of LiteLLM_ManagedObjectTable records present in the database

        Parameters
        ----------
        select
            Select the LiteLLM_ManagedObjectTable fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            LiteLLM_ManagedObjectTable filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.LiteLLM_ManagedObjectTableCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await LiteLLM_ManagedObjectTable.prisma().count()

        # results: prisma.types.LiteLLM_ManagedObjectTableCountAggregateOutput
        results = await LiteLLM_ManagedObjectTable.prisma().count(
            select={
                '_all': True,
                'created_by': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.LiteLLM_ManagedObjectTableCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.LiteLLM_ManagedObjectTableWhereInput] = None
    ) -> int:
        """Delete multiple LiteLLM_ManagedObjectTable records.

        Parameters
        ----------
        where
            Optional LiteLLM_ManagedObjectTable filter to find the records to be deleted

        Returns
        -------
        int
            The total number of LiteLLM_ManagedObjectTable records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all LiteLLM_ManagedObjectTable records
        total = await LiteLLM_ManagedObjectTable.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.LiteLLM_ManagedObjectTableScalarFieldKeys'],
        *,
        where: Optional['types.LiteLLM_ManagedObjectTableWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.LiteLLM_ManagedObjectTableAvgAggregateInput'] = None,
        sum: Optional['types.LiteLLM_ManagedObjectTableSumAggregateInput'] = None,
        min: Optional['types.LiteLLM_ManagedObjectTableMinAggregateInput'] = None,
        max: Optional['types.LiteLLM_ManagedObjectTableMaxAggregateInput'] = None,
        having: Optional['types.LiteLLM_ManagedObjectTableScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.LiteLLM_ManagedObjectTableCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.LiteLLM_ManagedObjectTableScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.LiteLLM_ManagedObjectTableScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.LiteLLM_ManagedObjectTableGroupByOutput']:
        """Group LiteLLM_ManagedObjectTable records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar LiteLLM_ManagedObjectTable fields to group records by
        where
            LiteLLM_ManagedObjectTable filter to select records
        take
            Limit the maximum number of LiteLLM_ManagedObjectTable records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.LiteLLM_ManagedObjectTableGroupByOutput]
            A list of dictionaries representing the LiteLLM_ManagedObjectTable record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group LiteLLM_ManagedObjectTable records by updated_at values
        # and count how many records are in each group
        results = await LiteLLM_ManagedObjectTable.prisma().group_by(
            ['updated_at'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class LiteLLM_ManagedVectorStoresTableActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: 'Client', model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.LiteLLM_ManagedVectorStoresTable]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await LiteLLM_ManagedVectorStoresTable.prisma().query_raw(
            'SELECT * FROM LiteLLM_ManagedVectorStoresTable WHERE vector_store_id = $1',
            'faehcjfdb',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.LiteLLM_ManagedVectorStoresTable
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await LiteLLM_ManagedVectorStoresTable.prisma().query_first(
            'SELECT * FROM LiteLLM_ManagedVectorStoresTable WHERE custom_llm_provider = $1',
            'bbaiefbee',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.LiteLLM_ManagedVectorStoresTableCreateInput,
        include: Optional[types.LiteLLM_ManagedVectorStoresTableInclude] = None
    ) -> _PrismaModelT:
        """Create a new LiteLLM_ManagedVectorStoresTable record.

        Parameters
        ----------
        data
            LiteLLM_ManagedVectorStoresTable record data
        include
            Specifies which relations should be loaded on the returned LiteLLM_ManagedVectorStoresTable model

        Returns
        -------
        prisma.models.LiteLLM_ManagedVectorStoresTable
            The created LiteLLM_ManagedVectorStoresTable record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a LiteLLM_ManagedVectorStoresTable record from just the required fields
        litellm_managedvectorstorestable = await LiteLLM_ManagedVectorStoresTable.prisma().create(
            data={
                # data to create a LiteLLM_ManagedVectorStoresTable record
                'vector_store_id': 'bdaacgjbaf',
                'custom_llm_provider': 'biibaighec',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.LiteLLM_ManagedVectorStoresTableCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple LiteLLM_ManagedVectorStoresTable records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of LiteLLM_ManagedVectorStoresTable record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await LiteLLM_ManagedVectorStoresTable.prisma().create_many(
            data=[
                {
                    # data to create a LiteLLM_ManagedVectorStoresTable record
                    'vector_store_id': 'baicdfeidj',
                    'custom_llm_provider': 'befgiciadg',
                },
                {
                    # data to create a LiteLLM_ManagedVectorStoresTable record
                    'vector_store_id': 'cbcehahedh',
                    'custom_llm_provider': 'bcjihiaide',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.LiteLLM_ManagedVectorStoresTableWhereUniqueInput,
        include: Optional[types.LiteLLM_ManagedVectorStoresTableInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single LiteLLM_ManagedVectorStoresTable record.

        Parameters
        ----------
        where
            LiteLLM_ManagedVectorStoresTable filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned LiteLLM_ManagedVectorStoresTable model

        Returns
        -------
        prisma.models.LiteLLM_ManagedVectorStoresTable
            The deleted LiteLLM_ManagedVectorStoresTable record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        litellm_managedvectorstorestable = await LiteLLM_ManagedVectorStoresTable.prisma().delete(
            where={
                'vector_store_id': 'bagfijcgfj',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.LiteLLM_ManagedVectorStoresTableWhereUniqueInput,
        include: Optional[types.LiteLLM_ManagedVectorStoresTableInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique LiteLLM_ManagedVectorStoresTable record.

        Parameters
        ----------
        where
            LiteLLM_ManagedVectorStoresTable filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned LiteLLM_ManagedVectorStoresTable model

        Returns
        -------
        prisma.models.LiteLLM_ManagedVectorStoresTable
            The found LiteLLM_ManagedVectorStoresTable record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        litellm_managedvectorstorestable = await LiteLLM_ManagedVectorStoresTable.prisma().find_unique(
            where={
                'vector_store_id': 'bcggehiidc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.LiteLLM_ManagedVectorStoresTableWhereUniqueInput,
        include: Optional[types.LiteLLM_ManagedVectorStoresTableInclude] = None
    ) -> _PrismaModelT:
        """Find a unique LiteLLM_ManagedVectorStoresTable record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            LiteLLM_ManagedVectorStoresTable filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned LiteLLM_ManagedVectorStoresTable model

        Returns
        -------
        prisma.models.LiteLLM_ManagedVectorStoresTable
            The found LiteLLM_ManagedVectorStoresTable record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        litellm_managedvectorstorestable = await LiteLLM_ManagedVectorStoresTable.prisma().find_unique_or_raise(
            where={
                'vector_store_id': 'bjcdacgacf',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_ManagedVectorStoresTableWhereInput] = None,
        cursor: Optional[types.LiteLLM_ManagedVectorStoresTableWhereUniqueInput] = None,
        include: Optional[types.LiteLLM_ManagedVectorStoresTableInclude] = None,
        order: Optional[Union[types.LiteLLM_ManagedVectorStoresTableOrderByInput, List[types.LiteLLM_ManagedVectorStoresTableOrderByInput]]] = None,
        distinct: Optional[List[types.LiteLLM_ManagedVectorStoresTableScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple LiteLLM_ManagedVectorStoresTable records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of LiteLLM_ManagedVectorStoresTable records returned
        skip
            Ignore the first N results
        where
            LiteLLM_ManagedVectorStoresTable filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned LiteLLM_ManagedVectorStoresTable model
        order
            Order the returned LiteLLM_ManagedVectorStoresTable records by any field
        distinct
            Filter LiteLLM_ManagedVectorStoresTable records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.LiteLLM_ManagedVectorStoresTable]
            The list of all LiteLLM_ManagedVectorStoresTable records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 LiteLLM_ManagedVectorStoresTable records
        litellm_managedvectorstorestables = await LiteLLM_ManagedVectorStoresTable.prisma().find_many(take=10)

        # find the first 5 LiteLLM_ManagedVectorStoresTable records ordered by the vector_store_name field
        litellm_managedvectorstorestables = await LiteLLM_ManagedVectorStoresTable.prisma().find_many(
            take=5,
            order={
                'vector_store_name': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_ManagedVectorStoresTableWhereInput] = None,
        cursor: Optional[types.LiteLLM_ManagedVectorStoresTableWhereUniqueInput] = None,
        include: Optional[types.LiteLLM_ManagedVectorStoresTableInclude] = None,
        order: Optional[Union[types.LiteLLM_ManagedVectorStoresTableOrderByInput, List[types.LiteLLM_ManagedVectorStoresTableOrderByInput]]] = None,
        distinct: Optional[List[types.LiteLLM_ManagedVectorStoresTableScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single LiteLLM_ManagedVectorStoresTable record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            LiteLLM_ManagedVectorStoresTable filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned LiteLLM_ManagedVectorStoresTable model
        order
            Order the returned LiteLLM_ManagedVectorStoresTable records by any field
        distinct
            Filter LiteLLM_ManagedVectorStoresTable records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.LiteLLM_ManagedVectorStoresTable
            The first LiteLLM_ManagedVectorStoresTable record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second LiteLLM_ManagedVectorStoresTable record ordered by the vector_store_description field
        litellm_managedvectorstorestable = await LiteLLM_ManagedVectorStoresTable.prisma().find_first(
            skip=1,
            order={
                'vector_store_description': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_ManagedVectorStoresTableWhereInput] = None,
        cursor: Optional[types.LiteLLM_ManagedVectorStoresTableWhereUniqueInput] = None,
        include: Optional[types.LiteLLM_ManagedVectorStoresTableInclude] = None,
        order: Optional[Union[types.LiteLLM_ManagedVectorStoresTableOrderByInput, List[types.LiteLLM_ManagedVectorStoresTableOrderByInput]]] = None,
        distinct: Optional[List[types.LiteLLM_ManagedVectorStoresTableScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single LiteLLM_ManagedVectorStoresTable record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            LiteLLM_ManagedVectorStoresTable filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned LiteLLM_ManagedVectorStoresTable model
        order
            Order the returned LiteLLM_ManagedVectorStoresTable records by any field
        distinct
            Filter LiteLLM_ManagedVectorStoresTable records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.LiteLLM_ManagedVectorStoresTable
            The first LiteLLM_ManagedVectorStoresTable record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second LiteLLM_ManagedVectorStoresTable record ordered by the vector_store_metadata field
        litellm_managedvectorstorestable = await LiteLLM_ManagedVectorStoresTable.prisma().find_first_or_raise(
            skip=1,
            order={
                'vector_store_metadata': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.LiteLLM_ManagedVectorStoresTableUpdateInput,
        where: types.LiteLLM_ManagedVectorStoresTableWhereUniqueInput,
        include: Optional[types.LiteLLM_ManagedVectorStoresTableInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single LiteLLM_ManagedVectorStoresTable record.

        Parameters
        ----------
        data
            LiteLLM_ManagedVectorStoresTable record data specifying what to update
        where
            LiteLLM_ManagedVectorStoresTable filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned LiteLLM_ManagedVectorStoresTable model

        Returns
        -------
        prisma.models.LiteLLM_ManagedVectorStoresTable
            The updated LiteLLM_ManagedVectorStoresTable record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        litellm_managedvectorstorestable = await LiteLLM_ManagedVectorStoresTable.prisma().update(
            where={
                'vector_store_id': 'jfieeahi',
            },
            data={
                # data to update the LiteLLM_ManagedVectorStoresTable record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.LiteLLM_ManagedVectorStoresTableWhereUniqueInput,
        data: types.LiteLLM_ManagedVectorStoresTableUpsertInput,
        include: Optional[types.LiteLLM_ManagedVectorStoresTableInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            LiteLLM_ManagedVectorStoresTable filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned LiteLLM_ManagedVectorStoresTable model

        Returns
        -------
        prisma.models.LiteLLM_ManagedVectorStoresTable
            The created or updated LiteLLM_ManagedVectorStoresTable record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        litellm_managedvectorstorestable = await LiteLLM_ManagedVectorStoresTable.prisma().upsert(
            where={
                'vector_store_id': 'bijfjbddfj',
            },
            data={
                'create': {
                    'vector_store_id': 'bijfjbddfj',
                    'custom_llm_provider': 'bcjihiaide',
                },
                'update': {
                    'custom_llm_provider': 'bcjihiaide',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.LiteLLM_ManagedVectorStoresTableUpdateManyMutationInput,
        where: types.LiteLLM_ManagedVectorStoresTableWhereInput,
    ) -> int:
        """Update multiple LiteLLM_ManagedVectorStoresTable records

        Parameters
        ----------
        data
            LiteLLM_ManagedVectorStoresTable data to update the selected LiteLLM_ManagedVectorStoresTable records to
        where
            Filter to select the LiteLLM_ManagedVectorStoresTable records to update

        Returns
        -------
        int
            The total number of LiteLLM_ManagedVectorStoresTable records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all LiteLLM_ManagedVectorStoresTable records
        total = await LiteLLM_ManagedVectorStoresTable.prisma().update_many(
            data={
                'created_at': datetime.datetime.utcnow()
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_ManagedVectorStoresTableWhereInput] = None,
        cursor: Optional[types.LiteLLM_ManagedVectorStoresTableWhereUniqueInput] = None,
    ) -> int:
        """Count the number of LiteLLM_ManagedVectorStoresTable records present in the database

        Parameters
        ----------
        select
            Select the LiteLLM_ManagedVectorStoresTable fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            LiteLLM_ManagedVectorStoresTable filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.LiteLLM_ManagedVectorStoresTableCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await LiteLLM_ManagedVectorStoresTable.prisma().count()

        # results: prisma.types.LiteLLM_ManagedVectorStoresTableCountAggregateOutput
        results = await LiteLLM_ManagedVectorStoresTable.prisma().count(
            select={
                '_all': True,
                'updated_at': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.LiteLLM_ManagedVectorStoresTableCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_ManagedVectorStoresTableWhereInput] = None,
        cursor: Optional[types.LiteLLM_ManagedVectorStoresTableWhereUniqueInput] = None,
    ) -> types.LiteLLM_ManagedVectorStoresTableCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.LiteLLM_ManagedVectorStoresTableCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_ManagedVectorStoresTableWhereInput] = None,
        cursor: Optional[types.LiteLLM_ManagedVectorStoresTableWhereUniqueInput] = None,
    ) -> Union[int, types.LiteLLM_ManagedVectorStoresTableCountAggregateOutput]:
        """Count the number of LiteLLM_ManagedVectorStoresTable records present in the database

        Parameters
        ----------
        select
            Select the LiteLLM_ManagedVectorStoresTable fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            LiteLLM_ManagedVectorStoresTable filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.LiteLLM_ManagedVectorStoresTableCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await LiteLLM_ManagedVectorStoresTable.prisma().count()

        # results: prisma.types.LiteLLM_ManagedVectorStoresTableCountAggregateOutput
        results = await LiteLLM_ManagedVectorStoresTable.prisma().count(
            select={
                '_all': True,
                'litellm_credential_name': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.LiteLLM_ManagedVectorStoresTableCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.LiteLLM_ManagedVectorStoresTableWhereInput] = None
    ) -> int:
        """Delete multiple LiteLLM_ManagedVectorStoresTable records.

        Parameters
        ----------
        where
            Optional LiteLLM_ManagedVectorStoresTable filter to find the records to be deleted

        Returns
        -------
        int
            The total number of LiteLLM_ManagedVectorStoresTable records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all LiteLLM_ManagedVectorStoresTable records
        total = await LiteLLM_ManagedVectorStoresTable.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.LiteLLM_ManagedVectorStoresTableScalarFieldKeys'],
        *,
        where: Optional['types.LiteLLM_ManagedVectorStoresTableWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.LiteLLM_ManagedVectorStoresTableAvgAggregateInput'] = None,
        sum: Optional['types.LiteLLM_ManagedVectorStoresTableSumAggregateInput'] = None,
        min: Optional['types.LiteLLM_ManagedVectorStoresTableMinAggregateInput'] = None,
        max: Optional['types.LiteLLM_ManagedVectorStoresTableMaxAggregateInput'] = None,
        having: Optional['types.LiteLLM_ManagedVectorStoresTableScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.LiteLLM_ManagedVectorStoresTableCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.LiteLLM_ManagedVectorStoresTableScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.LiteLLM_ManagedVectorStoresTableScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.LiteLLM_ManagedVectorStoresTableGroupByOutput']:
        """Group LiteLLM_ManagedVectorStoresTable records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar LiteLLM_ManagedVectorStoresTable fields to group records by
        where
            LiteLLM_ManagedVectorStoresTable filter to select records
        take
            Limit the maximum number of LiteLLM_ManagedVectorStoresTable records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.LiteLLM_ManagedVectorStoresTableGroupByOutput]
            A list of dictionaries representing the LiteLLM_ManagedVectorStoresTable record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group LiteLLM_ManagedVectorStoresTable records by litellm_params values
        # and count how many records are in each group
        results = await LiteLLM_ManagedVectorStoresTable.prisma().group_by(
            ['litellm_params'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class LiteLLM_GuardrailsTableActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: 'Client', model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.LiteLLM_GuardrailsTable]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await LiteLLM_GuardrailsTable.prisma().query_raw(
            'SELECT * FROM LiteLLM_GuardrailsTable WHERE guardrail_id = $1',
            'cdcdjdcee',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.LiteLLM_GuardrailsTable
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await LiteLLM_GuardrailsTable.prisma().query_first(
            'SELECT * FROM LiteLLM_GuardrailsTable WHERE guardrail_name = $1',
            'bbbgjdbgcb',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.LiteLLM_GuardrailsTableCreateInput,
        include: Optional[types.LiteLLM_GuardrailsTableInclude] = None
    ) -> _PrismaModelT:
        """Create a new LiteLLM_GuardrailsTable record.

        Parameters
        ----------
        data
            LiteLLM_GuardrailsTable record data
        include
            Specifies which relations should be loaded on the returned LiteLLM_GuardrailsTable model

        Returns
        -------
        prisma.models.LiteLLM_GuardrailsTable
            The created LiteLLM_GuardrailsTable record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a LiteLLM_GuardrailsTable record from just the required fields
        litellm_guardrailstable = await LiteLLM_GuardrailsTable.prisma().create(
            data={
                # data to create a LiteLLM_GuardrailsTable record
                'guardrail_name': 'bcedacgecg',
                'litellm_params': Json({'cbdffjeh': True}),
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.LiteLLM_GuardrailsTableCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple LiteLLM_GuardrailsTable records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of LiteLLM_GuardrailsTable record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await LiteLLM_GuardrailsTable.prisma().create_many(
            data=[
                {
                    # data to create a LiteLLM_GuardrailsTable record
                    'guardrail_name': 'idbcdhbci',
                    'litellm_params': Json({'bacegehahd': True}),
                },
                {
                    # data to create a LiteLLM_GuardrailsTable record
                    'guardrail_name': 'ebedeihec',
                    'litellm_params': Json({'bajagjdfbb': True}),
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.LiteLLM_GuardrailsTableWhereUniqueInput,
        include: Optional[types.LiteLLM_GuardrailsTableInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single LiteLLM_GuardrailsTable record.

        Parameters
        ----------
        where
            LiteLLM_GuardrailsTable filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned LiteLLM_GuardrailsTable model

        Returns
        -------
        prisma.models.LiteLLM_GuardrailsTable
            The deleted LiteLLM_GuardrailsTable record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        litellm_guardrailstable = await LiteLLM_GuardrailsTable.prisma().delete(
            where={
                'guardrail_id': 'bggedbjggi',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.LiteLLM_GuardrailsTableWhereUniqueInput,
        include: Optional[types.LiteLLM_GuardrailsTableInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique LiteLLM_GuardrailsTable record.

        Parameters
        ----------
        where
            LiteLLM_GuardrailsTable filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned LiteLLM_GuardrailsTable model

        Returns
        -------
        prisma.models.LiteLLM_GuardrailsTable
            The found LiteLLM_GuardrailsTable record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        litellm_guardrailstable = await LiteLLM_GuardrailsTable.prisma().find_unique(
            where={
                'guardrail_id': 'hgbafifcf',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.LiteLLM_GuardrailsTableWhereUniqueInput,
        include: Optional[types.LiteLLM_GuardrailsTableInclude] = None
    ) -> _PrismaModelT:
        """Find a unique LiteLLM_GuardrailsTable record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            LiteLLM_GuardrailsTable filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned LiteLLM_GuardrailsTable model

        Returns
        -------
        prisma.models.LiteLLM_GuardrailsTable
            The found LiteLLM_GuardrailsTable record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        litellm_guardrailstable = await LiteLLM_GuardrailsTable.prisma().find_unique_or_raise(
            where={
                'guardrail_id': 'bejiecfecg',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_GuardrailsTableWhereInput] = None,
        cursor: Optional[types.LiteLLM_GuardrailsTableWhereUniqueInput] = None,
        include: Optional[types.LiteLLM_GuardrailsTableInclude] = None,
        order: Optional[Union[types.LiteLLM_GuardrailsTableOrderByInput, List[types.LiteLLM_GuardrailsTableOrderByInput]]] = None,
        distinct: Optional[List[types.LiteLLM_GuardrailsTableScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple LiteLLM_GuardrailsTable records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of LiteLLM_GuardrailsTable records returned
        skip
            Ignore the first N results
        where
            LiteLLM_GuardrailsTable filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned LiteLLM_GuardrailsTable model
        order
            Order the returned LiteLLM_GuardrailsTable records by any field
        distinct
            Filter LiteLLM_GuardrailsTable records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.LiteLLM_GuardrailsTable]
            The list of all LiteLLM_GuardrailsTable records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 LiteLLM_GuardrailsTable records
        litellm_guardrailstables = await LiteLLM_GuardrailsTable.prisma().find_many(take=10)

        # find the first 5 LiteLLM_GuardrailsTable records ordered by the litellm_params field
        litellm_guardrailstables = await LiteLLM_GuardrailsTable.prisma().find_many(
            take=5,
            order={
                'litellm_params': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_GuardrailsTableWhereInput] = None,
        cursor: Optional[types.LiteLLM_GuardrailsTableWhereUniqueInput] = None,
        include: Optional[types.LiteLLM_GuardrailsTableInclude] = None,
        order: Optional[Union[types.LiteLLM_GuardrailsTableOrderByInput, List[types.LiteLLM_GuardrailsTableOrderByInput]]] = None,
        distinct: Optional[List[types.LiteLLM_GuardrailsTableScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single LiteLLM_GuardrailsTable record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            LiteLLM_GuardrailsTable filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned LiteLLM_GuardrailsTable model
        order
            Order the returned LiteLLM_GuardrailsTable records by any field
        distinct
            Filter LiteLLM_GuardrailsTable records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.LiteLLM_GuardrailsTable
            The first LiteLLM_GuardrailsTable record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second LiteLLM_GuardrailsTable record ordered by the guardrail_info field
        litellm_guardrailstable = await LiteLLM_GuardrailsTable.prisma().find_first(
            skip=1,
            order={
                'guardrail_info': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_GuardrailsTableWhereInput] = None,
        cursor: Optional[types.LiteLLM_GuardrailsTableWhereUniqueInput] = None,
        include: Optional[types.LiteLLM_GuardrailsTableInclude] = None,
        order: Optional[Union[types.LiteLLM_GuardrailsTableOrderByInput, List[types.LiteLLM_GuardrailsTableOrderByInput]]] = None,
        distinct: Optional[List[types.LiteLLM_GuardrailsTableScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single LiteLLM_GuardrailsTable record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            LiteLLM_GuardrailsTable filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned LiteLLM_GuardrailsTable model
        order
            Order the returned LiteLLM_GuardrailsTable records by any field
        distinct
            Filter LiteLLM_GuardrailsTable records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.LiteLLM_GuardrailsTable
            The first LiteLLM_GuardrailsTable record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second LiteLLM_GuardrailsTable record ordered by the created_at field
        litellm_guardrailstable = await LiteLLM_GuardrailsTable.prisma().find_first_or_raise(
            skip=1,
            order={
                'created_at': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.LiteLLM_GuardrailsTableUpdateInput,
        where: types.LiteLLM_GuardrailsTableWhereUniqueInput,
        include: Optional[types.LiteLLM_GuardrailsTableInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single LiteLLM_GuardrailsTable record.

        Parameters
        ----------
        data
            LiteLLM_GuardrailsTable record data specifying what to update
        where
            LiteLLM_GuardrailsTable filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned LiteLLM_GuardrailsTable model

        Returns
        -------
        prisma.models.LiteLLM_GuardrailsTable
            The updated LiteLLM_GuardrailsTable record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        litellm_guardrailstable = await LiteLLM_GuardrailsTable.prisma().update(
            where={
                'guardrail_id': 'bjgacaeagh',
            },
            data={
                # data to update the LiteLLM_GuardrailsTable record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.LiteLLM_GuardrailsTableWhereUniqueInput,
        data: types.LiteLLM_GuardrailsTableUpsertInput,
        include: Optional[types.LiteLLM_GuardrailsTableInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            LiteLLM_GuardrailsTable filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned LiteLLM_GuardrailsTable model

        Returns
        -------
        prisma.models.LiteLLM_GuardrailsTable
            The created or updated LiteLLM_GuardrailsTable record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        litellm_guardrailstable = await LiteLLM_GuardrailsTable.prisma().upsert(
            where={
                'guardrail_id': 'beeaihbefg',
            },
            data={
                'create': {
                    'guardrail_id': 'beeaihbefg',
                    'guardrail_name': 'ebedeihec',
                    'litellm_params': Json({'bajagjdfbb': True}),
                },
                'update': {
                    'guardrail_name': 'ebedeihec',
                    'litellm_params': Json({'bajagjdfbb': True}),
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.LiteLLM_GuardrailsTableUpdateManyMutationInput,
        where: types.LiteLLM_GuardrailsTableWhereInput,
    ) -> int:
        """Update multiple LiteLLM_GuardrailsTable records

        Parameters
        ----------
        data
            LiteLLM_GuardrailsTable data to update the selected LiteLLM_GuardrailsTable records to
        where
            Filter to select the LiteLLM_GuardrailsTable records to update

        Returns
        -------
        int
            The total number of LiteLLM_GuardrailsTable records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all LiteLLM_GuardrailsTable records
        total = await LiteLLM_GuardrailsTable.prisma().update_many(
            data={
                'updated_at': datetime.datetime.utcnow()
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_GuardrailsTableWhereInput] = None,
        cursor: Optional[types.LiteLLM_GuardrailsTableWhereUniqueInput] = None,
    ) -> int:
        """Count the number of LiteLLM_GuardrailsTable records present in the database

        Parameters
        ----------
        select
            Select the LiteLLM_GuardrailsTable fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            LiteLLM_GuardrailsTable filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.LiteLLM_GuardrailsTableCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await LiteLLM_GuardrailsTable.prisma().count()

        # results: prisma.types.LiteLLM_GuardrailsTableCountAggregateOutput
        results = await LiteLLM_GuardrailsTable.prisma().count(
            select={
                '_all': True,
                'guardrail_id': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.LiteLLM_GuardrailsTableCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_GuardrailsTableWhereInput] = None,
        cursor: Optional[types.LiteLLM_GuardrailsTableWhereUniqueInput] = None,
    ) -> types.LiteLLM_GuardrailsTableCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.LiteLLM_GuardrailsTableCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_GuardrailsTableWhereInput] = None,
        cursor: Optional[types.LiteLLM_GuardrailsTableWhereUniqueInput] = None,
    ) -> Union[int, types.LiteLLM_GuardrailsTableCountAggregateOutput]:
        """Count the number of LiteLLM_GuardrailsTable records present in the database

        Parameters
        ----------
        select
            Select the LiteLLM_GuardrailsTable fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            LiteLLM_GuardrailsTable filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.LiteLLM_GuardrailsTableCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await LiteLLM_GuardrailsTable.prisma().count()

        # results: prisma.types.LiteLLM_GuardrailsTableCountAggregateOutput
        results = await LiteLLM_GuardrailsTable.prisma().count(
            select={
                '_all': True,
                'guardrail_name': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.LiteLLM_GuardrailsTableCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.LiteLLM_GuardrailsTableWhereInput] = None
    ) -> int:
        """Delete multiple LiteLLM_GuardrailsTable records.

        Parameters
        ----------
        where
            Optional LiteLLM_GuardrailsTable filter to find the records to be deleted

        Returns
        -------
        int
            The total number of LiteLLM_GuardrailsTable records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all LiteLLM_GuardrailsTable records
        total = await LiteLLM_GuardrailsTable.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.LiteLLM_GuardrailsTableScalarFieldKeys'],
        *,
        where: Optional['types.LiteLLM_GuardrailsTableWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.LiteLLM_GuardrailsTableAvgAggregateInput'] = None,
        sum: Optional['types.LiteLLM_GuardrailsTableSumAggregateInput'] = None,
        min: Optional['types.LiteLLM_GuardrailsTableMinAggregateInput'] = None,
        max: Optional['types.LiteLLM_GuardrailsTableMaxAggregateInput'] = None,
        having: Optional['types.LiteLLM_GuardrailsTableScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.LiteLLM_GuardrailsTableCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.LiteLLM_GuardrailsTableScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.LiteLLM_GuardrailsTableScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.LiteLLM_GuardrailsTableGroupByOutput']:
        """Group LiteLLM_GuardrailsTable records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar LiteLLM_GuardrailsTable fields to group records by
        where
            LiteLLM_GuardrailsTable filter to select records
        take
            Limit the maximum number of LiteLLM_GuardrailsTable records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.LiteLLM_GuardrailsTableGroupByOutput]
            A list of dictionaries representing the LiteLLM_GuardrailsTable record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group LiteLLM_GuardrailsTable records by litellm_params values
        # and count how many records are in each group
        results = await LiteLLM_GuardrailsTable.prisma().group_by(
            ['litellm_params'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class LiteLLM_PromptTableActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: 'Client', model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.LiteLLM_PromptTable]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await LiteLLM_PromptTable.prisma().query_raw(
            'SELECT * FROM LiteLLM_PromptTable WHERE id = $1',
            'bfbfgeddfd',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.LiteLLM_PromptTable
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await LiteLLM_PromptTable.prisma().query_first(
            'SELECT * FROM LiteLLM_PromptTable WHERE prompt_id = $1',
            'jbgheibja',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.LiteLLM_PromptTableCreateInput,
        include: Optional[types.LiteLLM_PromptTableInclude] = None
    ) -> _PrismaModelT:
        """Create a new LiteLLM_PromptTable record.

        Parameters
        ----------
        data
            LiteLLM_PromptTable record data
        include
            Specifies which relations should be loaded on the returned LiteLLM_PromptTable model

        Returns
        -------
        prisma.models.LiteLLM_PromptTable
            The created LiteLLM_PromptTable record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a LiteLLM_PromptTable record from just the required fields
        litellm_prompttable = await LiteLLM_PromptTable.prisma().create(
            data={
                # data to create a LiteLLM_PromptTable record
                'prompt_id': 'eejajbid',
                'litellm_params': Json({'efhdcdaie': True}),
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.LiteLLM_PromptTableCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple LiteLLM_PromptTable records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of LiteLLM_PromptTable record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await LiteLLM_PromptTable.prisma().create_many(
            data=[
                {
                    # data to create a LiteLLM_PromptTable record
                    'prompt_id': 'cadejecgbd',
                    'litellm_params': Json({'bahjhjjhcc': True}),
                },
                {
                    # data to create a LiteLLM_PromptTable record
                    'prompt_id': 'ebhbhbdff',
                    'litellm_params': Json({'bdiefcdfhg': True}),
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.LiteLLM_PromptTableWhereUniqueInput,
        include: Optional[types.LiteLLM_PromptTableInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single LiteLLM_PromptTable record.

        Parameters
        ----------
        where
            LiteLLM_PromptTable filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned LiteLLM_PromptTable model

        Returns
        -------
        prisma.models.LiteLLM_PromptTable
            The deleted LiteLLM_PromptTable record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        litellm_prompttable = await LiteLLM_PromptTable.prisma().delete(
            where={
                'id': 'cheifeghd',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.LiteLLM_PromptTableWhereUniqueInput,
        include: Optional[types.LiteLLM_PromptTableInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique LiteLLM_PromptTable record.

        Parameters
        ----------
        where
            LiteLLM_PromptTable filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned LiteLLM_PromptTable model

        Returns
        -------
        prisma.models.LiteLLM_PromptTable
            The found LiteLLM_PromptTable record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        litellm_prompttable = await LiteLLM_PromptTable.prisma().find_unique(
            where={
                'id': 'fgijheefe',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.LiteLLM_PromptTableWhereUniqueInput,
        include: Optional[types.LiteLLM_PromptTableInclude] = None
    ) -> _PrismaModelT:
        """Find a unique LiteLLM_PromptTable record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            LiteLLM_PromptTable filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned LiteLLM_PromptTable model

        Returns
        -------
        prisma.models.LiteLLM_PromptTable
            The found LiteLLM_PromptTable record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        litellm_prompttable = await LiteLLM_PromptTable.prisma().find_unique_or_raise(
            where={
                'id': 'hcbgbhfch',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_PromptTableWhereInput] = None,
        cursor: Optional[types.LiteLLM_PromptTableWhereUniqueInput] = None,
        include: Optional[types.LiteLLM_PromptTableInclude] = None,
        order: Optional[Union[types.LiteLLM_PromptTableOrderByInput, List[types.LiteLLM_PromptTableOrderByInput]]] = None,
        distinct: Optional[List[types.LiteLLM_PromptTableScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple LiteLLM_PromptTable records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of LiteLLM_PromptTable records returned
        skip
            Ignore the first N results
        where
            LiteLLM_PromptTable filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned LiteLLM_PromptTable model
        order
            Order the returned LiteLLM_PromptTable records by any field
        distinct
            Filter LiteLLM_PromptTable records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.LiteLLM_PromptTable]
            The list of all LiteLLM_PromptTable records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 LiteLLM_PromptTable records
        litellm_prompttables = await LiteLLM_PromptTable.prisma().find_many(take=10)

        # find the first 5 LiteLLM_PromptTable records ordered by the litellm_params field
        litellm_prompttables = await LiteLLM_PromptTable.prisma().find_many(
            take=5,
            order={
                'litellm_params': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_PromptTableWhereInput] = None,
        cursor: Optional[types.LiteLLM_PromptTableWhereUniqueInput] = None,
        include: Optional[types.LiteLLM_PromptTableInclude] = None,
        order: Optional[Union[types.LiteLLM_PromptTableOrderByInput, List[types.LiteLLM_PromptTableOrderByInput]]] = None,
        distinct: Optional[List[types.LiteLLM_PromptTableScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single LiteLLM_PromptTable record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            LiteLLM_PromptTable filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned LiteLLM_PromptTable model
        order
            Order the returned LiteLLM_PromptTable records by any field
        distinct
            Filter LiteLLM_PromptTable records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.LiteLLM_PromptTable
            The first LiteLLM_PromptTable record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second LiteLLM_PromptTable record ordered by the prompt_info field
        litellm_prompttable = await LiteLLM_PromptTable.prisma().find_first(
            skip=1,
            order={
                'prompt_info': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_PromptTableWhereInput] = None,
        cursor: Optional[types.LiteLLM_PromptTableWhereUniqueInput] = None,
        include: Optional[types.LiteLLM_PromptTableInclude] = None,
        order: Optional[Union[types.LiteLLM_PromptTableOrderByInput, List[types.LiteLLM_PromptTableOrderByInput]]] = None,
        distinct: Optional[List[types.LiteLLM_PromptTableScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single LiteLLM_PromptTable record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            LiteLLM_PromptTable filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned LiteLLM_PromptTable model
        order
            Order the returned LiteLLM_PromptTable records by any field
        distinct
            Filter LiteLLM_PromptTable records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.LiteLLM_PromptTable
            The first LiteLLM_PromptTable record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second LiteLLM_PromptTable record ordered by the created_at field
        litellm_prompttable = await LiteLLM_PromptTable.prisma().find_first_or_raise(
            skip=1,
            order={
                'created_at': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.LiteLLM_PromptTableUpdateInput,
        where: types.LiteLLM_PromptTableWhereUniqueInput,
        include: Optional[types.LiteLLM_PromptTableInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single LiteLLM_PromptTable record.

        Parameters
        ----------
        data
            LiteLLM_PromptTable record data specifying what to update
        where
            LiteLLM_PromptTable filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned LiteLLM_PromptTable model

        Returns
        -------
        prisma.models.LiteLLM_PromptTable
            The updated LiteLLM_PromptTable record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        litellm_prompttable = await LiteLLM_PromptTable.prisma().update(
            where={
                'id': 'bfbbbgbfhc',
            },
            data={
                # data to update the LiteLLM_PromptTable record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.LiteLLM_PromptTableWhereUniqueInput,
        data: types.LiteLLM_PromptTableUpsertInput,
        include: Optional[types.LiteLLM_PromptTableInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            LiteLLM_PromptTable filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned LiteLLM_PromptTable model

        Returns
        -------
        prisma.models.LiteLLM_PromptTable
            The created or updated LiteLLM_PromptTable record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        litellm_prompttable = await LiteLLM_PromptTable.prisma().upsert(
            where={
                'id': 'ibijjdeb',
            },
            data={
                'create': {
                    'id': 'ibijjdeb',
                    'prompt_id': 'ebhbhbdff',
                    'litellm_params': Json({'bdiefcdfhg': True}),
                },
                'update': {
                    'prompt_id': 'ebhbhbdff',
                    'litellm_params': Json({'bdiefcdfhg': True}),
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.LiteLLM_PromptTableUpdateManyMutationInput,
        where: types.LiteLLM_PromptTableWhereInput,
    ) -> int:
        """Update multiple LiteLLM_PromptTable records

        Parameters
        ----------
        data
            LiteLLM_PromptTable data to update the selected LiteLLM_PromptTable records to
        where
            Filter to select the LiteLLM_PromptTable records to update

        Returns
        -------
        int
            The total number of LiteLLM_PromptTable records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all LiteLLM_PromptTable records
        total = await LiteLLM_PromptTable.prisma().update_many(
            data={
                'updated_at': datetime.datetime.utcnow()
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_PromptTableWhereInput] = None,
        cursor: Optional[types.LiteLLM_PromptTableWhereUniqueInput] = None,
    ) -> int:
        """Count the number of LiteLLM_PromptTable records present in the database

        Parameters
        ----------
        select
            Select the LiteLLM_PromptTable fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            LiteLLM_PromptTable filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.LiteLLM_PromptTableCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await LiteLLM_PromptTable.prisma().count()

        # results: prisma.types.LiteLLM_PromptTableCountAggregateOutput
        results = await LiteLLM_PromptTable.prisma().count(
            select={
                '_all': True,
                'id': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.LiteLLM_PromptTableCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_PromptTableWhereInput] = None,
        cursor: Optional[types.LiteLLM_PromptTableWhereUniqueInput] = None,
    ) -> types.LiteLLM_PromptTableCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.LiteLLM_PromptTableCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_PromptTableWhereInput] = None,
        cursor: Optional[types.LiteLLM_PromptTableWhereUniqueInput] = None,
    ) -> Union[int, types.LiteLLM_PromptTableCountAggregateOutput]:
        """Count the number of LiteLLM_PromptTable records present in the database

        Parameters
        ----------
        select
            Select the LiteLLM_PromptTable fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            LiteLLM_PromptTable filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.LiteLLM_PromptTableCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await LiteLLM_PromptTable.prisma().count()

        # results: prisma.types.LiteLLM_PromptTableCountAggregateOutput
        results = await LiteLLM_PromptTable.prisma().count(
            select={
                '_all': True,
                'prompt_id': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.LiteLLM_PromptTableCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.LiteLLM_PromptTableWhereInput] = None
    ) -> int:
        """Delete multiple LiteLLM_PromptTable records.

        Parameters
        ----------
        where
            Optional LiteLLM_PromptTable filter to find the records to be deleted

        Returns
        -------
        int
            The total number of LiteLLM_PromptTable records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all LiteLLM_PromptTable records
        total = await LiteLLM_PromptTable.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.LiteLLM_PromptTableScalarFieldKeys'],
        *,
        where: Optional['types.LiteLLM_PromptTableWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.LiteLLM_PromptTableAvgAggregateInput'] = None,
        sum: Optional['types.LiteLLM_PromptTableSumAggregateInput'] = None,
        min: Optional['types.LiteLLM_PromptTableMinAggregateInput'] = None,
        max: Optional['types.LiteLLM_PromptTableMaxAggregateInput'] = None,
        having: Optional['types.LiteLLM_PromptTableScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.LiteLLM_PromptTableCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.LiteLLM_PromptTableScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.LiteLLM_PromptTableScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.LiteLLM_PromptTableGroupByOutput']:
        """Group LiteLLM_PromptTable records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar LiteLLM_PromptTable fields to group records by
        where
            LiteLLM_PromptTable filter to select records
        take
            Limit the maximum number of LiteLLM_PromptTable records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.LiteLLM_PromptTableGroupByOutput]
            A list of dictionaries representing the LiteLLM_PromptTable record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group LiteLLM_PromptTable records by litellm_params values
        # and count how many records are in each group
        results = await LiteLLM_PromptTable.prisma().group_by(
            ['litellm_params'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class LiteLLM_HealthCheckTableActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: 'Client', model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.LiteLLM_HealthCheckTable]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await LiteLLM_HealthCheckTable.prisma().query_raw(
            'SELECT * FROM LiteLLM_HealthCheckTable WHERE health_check_id = $1',
            'caehiccddi',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.LiteLLM_HealthCheckTable
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await LiteLLM_HealthCheckTable.prisma().query_first(
            'SELECT * FROM LiteLLM_HealthCheckTable WHERE model_name = $1',
            'bgcahjbafj',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.LiteLLM_HealthCheckTableCreateInput,
        include: Optional[types.LiteLLM_HealthCheckTableInclude] = None
    ) -> _PrismaModelT:
        """Create a new LiteLLM_HealthCheckTable record.

        Parameters
        ----------
        data
            LiteLLM_HealthCheckTable record data
        include
            Specifies which relations should be loaded on the returned LiteLLM_HealthCheckTable model

        Returns
        -------
        prisma.models.LiteLLM_HealthCheckTable
            The created LiteLLM_HealthCheckTable record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a LiteLLM_HealthCheckTable record from just the required fields
        litellm_healthchecktable = await LiteLLM_HealthCheckTable.prisma().create(
            data={
                # data to create a LiteLLM_HealthCheckTable record
                'model_name': 'bihhgeihca',
                'status': 'bdgbfahbef',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.LiteLLM_HealthCheckTableCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple LiteLLM_HealthCheckTable records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of LiteLLM_HealthCheckTable record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await LiteLLM_HealthCheckTable.prisma().create_many(
            data=[
                {
                    # data to create a LiteLLM_HealthCheckTable record
                    'model_name': 'fccjhidic',
                    'status': 'bdgfdgdaff',
                },
                {
                    # data to create a LiteLLM_HealthCheckTable record
                    'model_name': 'bicgeaiaga',
                    'status': 'fajhhafab',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.LiteLLM_HealthCheckTableWhereUniqueInput,
        include: Optional[types.LiteLLM_HealthCheckTableInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single LiteLLM_HealthCheckTable record.

        Parameters
        ----------
        where
            LiteLLM_HealthCheckTable filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned LiteLLM_HealthCheckTable model

        Returns
        -------
        prisma.models.LiteLLM_HealthCheckTable
            The deleted LiteLLM_HealthCheckTable record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        litellm_healthchecktable = await LiteLLM_HealthCheckTable.prisma().delete(
            where={
                'health_check_id': 'bfeiccieec',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.LiteLLM_HealthCheckTableWhereUniqueInput,
        include: Optional[types.LiteLLM_HealthCheckTableInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique LiteLLM_HealthCheckTable record.

        Parameters
        ----------
        where
            LiteLLM_HealthCheckTable filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned LiteLLM_HealthCheckTable model

        Returns
        -------
        prisma.models.LiteLLM_HealthCheckTable
            The found LiteLLM_HealthCheckTable record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        litellm_healthchecktable = await LiteLLM_HealthCheckTable.prisma().find_unique(
            where={
                'health_check_id': 'hciegiihf',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.LiteLLM_HealthCheckTableWhereUniqueInput,
        include: Optional[types.LiteLLM_HealthCheckTableInclude] = None
    ) -> _PrismaModelT:
        """Find a unique LiteLLM_HealthCheckTable record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            LiteLLM_HealthCheckTable filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned LiteLLM_HealthCheckTable model

        Returns
        -------
        prisma.models.LiteLLM_HealthCheckTable
            The found LiteLLM_HealthCheckTable record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        litellm_healthchecktable = await LiteLLM_HealthCheckTable.prisma().find_unique_or_raise(
            where={
                'health_check_id': 'bahifjfga',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_HealthCheckTableWhereInput] = None,
        cursor: Optional[types.LiteLLM_HealthCheckTableWhereUniqueInput] = None,
        include: Optional[types.LiteLLM_HealthCheckTableInclude] = None,
        order: Optional[Union[types.LiteLLM_HealthCheckTableOrderByInput, List[types.LiteLLM_HealthCheckTableOrderByInput]]] = None,
        distinct: Optional[List[types.LiteLLM_HealthCheckTableScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple LiteLLM_HealthCheckTable records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of LiteLLM_HealthCheckTable records returned
        skip
            Ignore the first N results
        where
            LiteLLM_HealthCheckTable filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned LiteLLM_HealthCheckTable model
        order
            Order the returned LiteLLM_HealthCheckTable records by any field
        distinct
            Filter LiteLLM_HealthCheckTable records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.LiteLLM_HealthCheckTable]
            The list of all LiteLLM_HealthCheckTable records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 LiteLLM_HealthCheckTable records
        litellm_healthchecktables = await LiteLLM_HealthCheckTable.prisma().find_many(take=10)

        # find the first 5 LiteLLM_HealthCheckTable records ordered by the model_id field
        litellm_healthchecktables = await LiteLLM_HealthCheckTable.prisma().find_many(
            take=5,
            order={
                'model_id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_HealthCheckTableWhereInput] = None,
        cursor: Optional[types.LiteLLM_HealthCheckTableWhereUniqueInput] = None,
        include: Optional[types.LiteLLM_HealthCheckTableInclude] = None,
        order: Optional[Union[types.LiteLLM_HealthCheckTableOrderByInput, List[types.LiteLLM_HealthCheckTableOrderByInput]]] = None,
        distinct: Optional[List[types.LiteLLM_HealthCheckTableScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single LiteLLM_HealthCheckTable record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            LiteLLM_HealthCheckTable filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned LiteLLM_HealthCheckTable model
        order
            Order the returned LiteLLM_HealthCheckTable records by any field
        distinct
            Filter LiteLLM_HealthCheckTable records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.LiteLLM_HealthCheckTable
            The first LiteLLM_HealthCheckTable record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second LiteLLM_HealthCheckTable record ordered by the status field
        litellm_healthchecktable = await LiteLLM_HealthCheckTable.prisma().find_first(
            skip=1,
            order={
                'status': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_HealthCheckTableWhereInput] = None,
        cursor: Optional[types.LiteLLM_HealthCheckTableWhereUniqueInput] = None,
        include: Optional[types.LiteLLM_HealthCheckTableInclude] = None,
        order: Optional[Union[types.LiteLLM_HealthCheckTableOrderByInput, List[types.LiteLLM_HealthCheckTableOrderByInput]]] = None,
        distinct: Optional[List[types.LiteLLM_HealthCheckTableScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single LiteLLM_HealthCheckTable record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            LiteLLM_HealthCheckTable filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned LiteLLM_HealthCheckTable model
        order
            Order the returned LiteLLM_HealthCheckTable records by any field
        distinct
            Filter LiteLLM_HealthCheckTable records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.LiteLLM_HealthCheckTable
            The first LiteLLM_HealthCheckTable record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second LiteLLM_HealthCheckTable record ordered by the healthy_count field
        litellm_healthchecktable = await LiteLLM_HealthCheckTable.prisma().find_first_or_raise(
            skip=1,
            order={
                'healthy_count': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.LiteLLM_HealthCheckTableUpdateInput,
        where: types.LiteLLM_HealthCheckTableWhereUniqueInput,
        include: Optional[types.LiteLLM_HealthCheckTableInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single LiteLLM_HealthCheckTable record.

        Parameters
        ----------
        data
            LiteLLM_HealthCheckTable record data specifying what to update
        where
            LiteLLM_HealthCheckTable filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned LiteLLM_HealthCheckTable model

        Returns
        -------
        prisma.models.LiteLLM_HealthCheckTable
            The updated LiteLLM_HealthCheckTable record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        litellm_healthchecktable = await LiteLLM_HealthCheckTable.prisma().update(
            where={
                'health_check_id': 'baebfehjaf',
            },
            data={
                # data to update the LiteLLM_HealthCheckTable record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.LiteLLM_HealthCheckTableWhereUniqueInput,
        data: types.LiteLLM_HealthCheckTableUpsertInput,
        include: Optional[types.LiteLLM_HealthCheckTableInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            LiteLLM_HealthCheckTable filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned LiteLLM_HealthCheckTable model

        Returns
        -------
        prisma.models.LiteLLM_HealthCheckTable
            The created or updated LiteLLM_HealthCheckTable record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        litellm_healthchecktable = await LiteLLM_HealthCheckTable.prisma().upsert(
            where={
                'health_check_id': 'bjchdacjfa',
            },
            data={
                'create': {
                    'health_check_id': 'bjchdacjfa',
                    'model_name': 'bicgeaiaga',
                    'status': 'fajhhafab',
                },
                'update': {
                    'model_name': 'bicgeaiaga',
                    'status': 'fajhhafab',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.LiteLLM_HealthCheckTableUpdateManyMutationInput,
        where: types.LiteLLM_HealthCheckTableWhereInput,
    ) -> int:
        """Update multiple LiteLLM_HealthCheckTable records

        Parameters
        ----------
        data
            LiteLLM_HealthCheckTable data to update the selected LiteLLM_HealthCheckTable records to
        where
            Filter to select the LiteLLM_HealthCheckTable records to update

        Returns
        -------
        int
            The total number of LiteLLM_HealthCheckTable records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all LiteLLM_HealthCheckTable records
        total = await LiteLLM_HealthCheckTable.prisma().update_many(
            data={
                'unhealthy_count': 520320871
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_HealthCheckTableWhereInput] = None,
        cursor: Optional[types.LiteLLM_HealthCheckTableWhereUniqueInput] = None,
    ) -> int:
        """Count the number of LiteLLM_HealthCheckTable records present in the database

        Parameters
        ----------
        select
            Select the LiteLLM_HealthCheckTable fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            LiteLLM_HealthCheckTable filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.LiteLLM_HealthCheckTableCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await LiteLLM_HealthCheckTable.prisma().count()

        # results: prisma.types.LiteLLM_HealthCheckTableCountAggregateOutput
        results = await LiteLLM_HealthCheckTable.prisma().count(
            select={
                '_all': True,
                'error_message': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.LiteLLM_HealthCheckTableCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_HealthCheckTableWhereInput] = None,
        cursor: Optional[types.LiteLLM_HealthCheckTableWhereUniqueInput] = None,
    ) -> types.LiteLLM_HealthCheckTableCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.LiteLLM_HealthCheckTableCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_HealthCheckTableWhereInput] = None,
        cursor: Optional[types.LiteLLM_HealthCheckTableWhereUniqueInput] = None,
    ) -> Union[int, types.LiteLLM_HealthCheckTableCountAggregateOutput]:
        """Count the number of LiteLLM_HealthCheckTable records present in the database

        Parameters
        ----------
        select
            Select the LiteLLM_HealthCheckTable fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            LiteLLM_HealthCheckTable filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.LiteLLM_HealthCheckTableCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await LiteLLM_HealthCheckTable.prisma().count()

        # results: prisma.types.LiteLLM_HealthCheckTableCountAggregateOutput
        results = await LiteLLM_HealthCheckTable.prisma().count(
            select={
                '_all': True,
                'response_time_ms': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.LiteLLM_HealthCheckTableCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.LiteLLM_HealthCheckTableWhereInput] = None
    ) -> int:
        """Delete multiple LiteLLM_HealthCheckTable records.

        Parameters
        ----------
        where
            Optional LiteLLM_HealthCheckTable filter to find the records to be deleted

        Returns
        -------
        int
            The total number of LiteLLM_HealthCheckTable records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all LiteLLM_HealthCheckTable records
        total = await LiteLLM_HealthCheckTable.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.LiteLLM_HealthCheckTableScalarFieldKeys'],
        *,
        where: Optional['types.LiteLLM_HealthCheckTableWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.LiteLLM_HealthCheckTableAvgAggregateInput'] = None,
        sum: Optional['types.LiteLLM_HealthCheckTableSumAggregateInput'] = None,
        min: Optional['types.LiteLLM_HealthCheckTableMinAggregateInput'] = None,
        max: Optional['types.LiteLLM_HealthCheckTableMaxAggregateInput'] = None,
        having: Optional['types.LiteLLM_HealthCheckTableScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.LiteLLM_HealthCheckTableCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.LiteLLM_HealthCheckTableScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.LiteLLM_HealthCheckTableScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.LiteLLM_HealthCheckTableGroupByOutput']:
        """Group LiteLLM_HealthCheckTable records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar LiteLLM_HealthCheckTable fields to group records by
        where
            LiteLLM_HealthCheckTable filter to select records
        take
            Limit the maximum number of LiteLLM_HealthCheckTable records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.LiteLLM_HealthCheckTableGroupByOutput]
            A list of dictionaries representing the LiteLLM_HealthCheckTable record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group LiteLLM_HealthCheckTable records by details values
        # and count how many records are in each group
        results = await LiteLLM_HealthCheckTable.prisma().group_by(
            ['details'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]



def _select_fields(root: str, select: Mapping[str, Any]) -> str:
    """Helper to build a GraphQL selection string

    This is a work around until field selection is added to the query builder.
    """

    return root + ' {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))


from . import models
