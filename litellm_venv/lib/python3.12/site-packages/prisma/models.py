# -*- coding: utf-8 -*-
# code generated by Prisma. DO NOT EDIT.
# pyright: reportUnusedImport=false
# fmt: off

# global imports for type checking
from builtins import bool as _bool
from builtins import int as _int
from builtins import float as _float
from builtins import str as _str
import sys
import decimal
import datetime
from typing import (
    TYPE_CHECKING,
    Optional,
    Iterable,
    Iterator,
    Sequence,
    Callable,
    ClassVar,
    NoReturn,
    TypeVar,
    Generic,
    Mapping,
    Tuple,
    Union,
    List,
    Dict,
    Type,
    Any,
    Set,
    overload,
    cast,
)
from typing_extensions import TypedDict, Literal


LiteralString = str
# -- template models.py.jinja --
import os
import logging
import inspect
import warnings
from collections import OrderedDict

from pydantic import BaseModel, Field

from . import types, enums, errors, fields, bases
from ._types import FuncType
from ._compat import model_rebuild, field_validator
from .builder import serialize_base64
from .generator import partial_models_ctx, PartialModelField


log: logging.Logger = logging.getLogger(__name__)
_created_partial_types: Set[str] = set()

class LiteLLM_BudgetTable(bases.BaseLiteLLM_BudgetTable):
    """Represents a LiteLLM_BudgetTable record"""

    budget_id: _str
    max_budget: Optional[_float] = None
    soft_budget: Optional[_float] = None
    max_parallel_requests: Optional[_int] = None
    tpm_limit: Optional[_int] = None
    rpm_limit: Optional[_int] = None
    model_max_budget: Optional['fields.Json'] = None
    budget_duration: Optional[_str] = None
    budget_reset_at: Optional[datetime.datetime] = None
    created_at: datetime.datetime
    created_by: _str
    updated_at: datetime.datetime
    updated_by: _str
    organization: Optional[List['models.LiteLLM_OrganizationTable']] = None
    keys: Optional[List['models.LiteLLM_VerificationToken']] = None
    end_users: Optional[List['models.LiteLLM_EndUserTable']] = None
    team_membership: Optional[List['models.LiteLLM_TeamMembership']] = None
    organization_membership: Optional[List['models.LiteLLM_OrganizationMembership']] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.LiteLLM_BudgetTableKeys']] = None,
        exclude: Optional[Iterable['types.LiteLLM_BudgetTableKeys']] = None,
        required: Optional[Iterable['types.LiteLLM_BudgetTableKeys']] = None,
        optional: Optional[Iterable['types.LiteLLM_BudgetTableKeys']] = None,
        relations: Optional[Mapping['types.LiteLLM_BudgetTableRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.LiteLLM_BudgetTableKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _LiteLLM_BudgetTable_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _LiteLLM_BudgetTable_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _LiteLLM_BudgetTable_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _LiteLLM_BudgetTable_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _LiteLLM_BudgetTable_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _LiteLLM_BudgetTable_relational_fields:
                        raise errors.UnknownRelationalFieldError('LiteLLM_BudgetTable', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid LiteLLM_BudgetTable / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'LiteLLM_BudgetTable',
            }
        )
        _created_partial_types.add(name)


class LiteLLM_CredentialsTable(bases.BaseLiteLLM_CredentialsTable):
    """Represents a LiteLLM_CredentialsTable record"""

    credential_id: _str
    credential_name: _str
    credential_values: 'fields.Json'
    credential_info: Optional['fields.Json'] = None
    created_at: datetime.datetime
    created_by: _str
    updated_at: datetime.datetime
    updated_by: _str

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.LiteLLM_CredentialsTableKeys']] = None,
        exclude: Optional[Iterable['types.LiteLLM_CredentialsTableKeys']] = None,
        required: Optional[Iterable['types.LiteLLM_CredentialsTableKeys']] = None,
        optional: Optional[Iterable['types.LiteLLM_CredentialsTableKeys']] = None,
        relations: Optional[Mapping['types.LiteLLM_CredentialsTableRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.LiteLLM_CredentialsTableKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _LiteLLM_CredentialsTable_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _LiteLLM_CredentialsTable_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _LiteLLM_CredentialsTable_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _LiteLLM_CredentialsTable_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True


            if relations:
                raise ValueError('Model: "LiteLLM_CredentialsTable" has no relational fields.')
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid LiteLLM_CredentialsTable / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'LiteLLM_CredentialsTable',
            }
        )
        _created_partial_types.add(name)


class LiteLLM_ProxyModelTable(bases.BaseLiteLLM_ProxyModelTable):
    """Represents a LiteLLM_ProxyModelTable record"""

    model_id: _str
    model_name: _str
    litellm_params: 'fields.Json'
    model_info: Optional['fields.Json'] = None
    created_at: datetime.datetime
    created_by: _str
    updated_at: datetime.datetime
    updated_by: _str

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.LiteLLM_ProxyModelTableKeys']] = None,
        exclude: Optional[Iterable['types.LiteLLM_ProxyModelTableKeys']] = None,
        required: Optional[Iterable['types.LiteLLM_ProxyModelTableKeys']] = None,
        optional: Optional[Iterable['types.LiteLLM_ProxyModelTableKeys']] = None,
        relations: Optional[Mapping['types.LiteLLM_ProxyModelTableRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.LiteLLM_ProxyModelTableKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _LiteLLM_ProxyModelTable_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _LiteLLM_ProxyModelTable_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _LiteLLM_ProxyModelTable_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _LiteLLM_ProxyModelTable_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True


            if relations:
                raise ValueError('Model: "LiteLLM_ProxyModelTable" has no relational fields.')
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid LiteLLM_ProxyModelTable / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'LiteLLM_ProxyModelTable',
            }
        )
        _created_partial_types.add(name)


class LiteLLM_OrganizationTable(bases.BaseLiteLLM_OrganizationTable):
    """Represents a LiteLLM_OrganizationTable record"""

    organization_id: _str
    organization_alias: _str
    budget_id: _str
    metadata: 'fields.Json'
    models: List[_str]
    spend: _float
    model_spend: 'fields.Json'
    object_permission_id: Optional[_str] = None
    created_at: datetime.datetime
    created_by: _str
    updated_at: datetime.datetime
    updated_by: _str
    litellm_budget_table: Optional['models.LiteLLM_BudgetTable'] = None
    teams: Optional[List['models.LiteLLM_TeamTable']] = None
    users: Optional[List['models.LiteLLM_UserTable']] = None
    keys: Optional[List['models.LiteLLM_VerificationToken']] = None
    members: Optional[List['models.LiteLLM_OrganizationMembership']] = None
    object_permission: Optional['models.LiteLLM_ObjectPermissionTable'] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )

    @field_validator('models', pre=True, allow_reuse=True)
    @classmethod
    def _transform_required_list_fields(cls, value: object) -> object:
        # When using raw queries, some databases will return `None` for an array field that has not been set yet.
        #
        # In our case we want to use an empty list instead as that is the internal Prisma behaviour and we want
        # to use the same consistent structure between the core ORM and raw queries. For example, if we updated
        # our type definitions to include `None` for `List` fields then it would be misleading as it will only
        # ever be `None` in raw queries.
        if value is None:
            return []

        return value

    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.LiteLLM_OrganizationTableKeys']] = None,
        exclude: Optional[Iterable['types.LiteLLM_OrganizationTableKeys']] = None,
        required: Optional[Iterable['types.LiteLLM_OrganizationTableKeys']] = None,
        optional: Optional[Iterable['types.LiteLLM_OrganizationTableKeys']] = None,
        relations: Optional[Mapping['types.LiteLLM_OrganizationTableRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.LiteLLM_OrganizationTableKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _LiteLLM_OrganizationTable_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _LiteLLM_OrganizationTable_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _LiteLLM_OrganizationTable_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _LiteLLM_OrganizationTable_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _LiteLLM_OrganizationTable_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _LiteLLM_OrganizationTable_relational_fields:
                        raise errors.UnknownRelationalFieldError('LiteLLM_OrganizationTable', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid LiteLLM_OrganizationTable / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'LiteLLM_OrganizationTable',
            }
        )
        _created_partial_types.add(name)


class LiteLLM_ModelTable(bases.BaseLiteLLM_ModelTable):
    """Represents a LiteLLM_ModelTable record"""

    id: _int
    model_aliases: Optional['fields.Json'] = None
    created_at: datetime.datetime
    created_by: _str
    updated_at: datetime.datetime
    updated_by: _str
    team: Optional['models.LiteLLM_TeamTable'] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.LiteLLM_ModelTableKeys']] = None,
        exclude: Optional[Iterable['types.LiteLLM_ModelTableKeys']] = None,
        required: Optional[Iterable['types.LiteLLM_ModelTableKeys']] = None,
        optional: Optional[Iterable['types.LiteLLM_ModelTableKeys']] = None,
        relations: Optional[Mapping['types.LiteLLM_ModelTableRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.LiteLLM_ModelTableKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _LiteLLM_ModelTable_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _LiteLLM_ModelTable_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _LiteLLM_ModelTable_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _LiteLLM_ModelTable_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _LiteLLM_ModelTable_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _LiteLLM_ModelTable_relational_fields:
                        raise errors.UnknownRelationalFieldError('LiteLLM_ModelTable', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid LiteLLM_ModelTable / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'LiteLLM_ModelTable',
            }
        )
        _created_partial_types.add(name)


class LiteLLM_TeamTable(bases.BaseLiteLLM_TeamTable):
    """Represents a LiteLLM_TeamTable record"""

    team_id: _str
    team_alias: Optional[_str] = None
    organization_id: Optional[_str] = None
    object_permission_id: Optional[_str] = None
    admins: List[_str]
    members: List[_str]
    members_with_roles: 'fields.Json'
    metadata: 'fields.Json'
    max_budget: Optional[_float] = None
    spend: _float
    models: List[_str]
    max_parallel_requests: Optional[_int] = None
    tpm_limit: Optional[_int] = None
    rpm_limit: Optional[_int] = None
    budget_duration: Optional[_str] = None
    budget_reset_at: Optional[datetime.datetime] = None
    blocked: _bool
    created_at: datetime.datetime
    updated_at: datetime.datetime
    model_spend: 'fields.Json'
    model_max_budget: 'fields.Json'
    team_member_permissions: List[_str]
    model_id: Optional[_int] = None
    litellm_organization_table: Optional['models.LiteLLM_OrganizationTable'] = None
    litellm_model_table: Optional['models.LiteLLM_ModelTable'] = None
    object_permission: Optional['models.LiteLLM_ObjectPermissionTable'] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )

    @field_validator('admins', 'members', 'models', 'team_member_permissions', pre=True, allow_reuse=True)
    @classmethod
    def _transform_required_list_fields(cls, value: object) -> object:
        # When using raw queries, some databases will return `None` for an array field that has not been set yet.
        #
        # In our case we want to use an empty list instead as that is the internal Prisma behaviour and we want
        # to use the same consistent structure between the core ORM and raw queries. For example, if we updated
        # our type definitions to include `None` for `List` fields then it would be misleading as it will only
        # ever be `None` in raw queries.
        if value is None:
            return []

        return value

    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.LiteLLM_TeamTableKeys']] = None,
        exclude: Optional[Iterable['types.LiteLLM_TeamTableKeys']] = None,
        required: Optional[Iterable['types.LiteLLM_TeamTableKeys']] = None,
        optional: Optional[Iterable['types.LiteLLM_TeamTableKeys']] = None,
        relations: Optional[Mapping['types.LiteLLM_TeamTableRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.LiteLLM_TeamTableKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _LiteLLM_TeamTable_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _LiteLLM_TeamTable_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _LiteLLM_TeamTable_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _LiteLLM_TeamTable_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _LiteLLM_TeamTable_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _LiteLLM_TeamTable_relational_fields:
                        raise errors.UnknownRelationalFieldError('LiteLLM_TeamTable', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid LiteLLM_TeamTable / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'LiteLLM_TeamTable',
            }
        )
        _created_partial_types.add(name)


class LiteLLM_UserTable(bases.BaseLiteLLM_UserTable):
    """Represents a LiteLLM_UserTable record"""

    user_id: _str
    user_alias: Optional[_str] = None
    team_id: Optional[_str] = None
    sso_user_id: Optional[_str] = None
    organization_id: Optional[_str] = None
    object_permission_id: Optional[_str] = None
    password: Optional[_str] = None
    teams: List[_str]
    user_role: Optional[_str] = None
    max_budget: Optional[_float] = None
    spend: _float
    user_email: Optional[_str] = None
    models: List[_str]
    metadata: 'fields.Json'
    max_parallel_requests: Optional[_int] = None
    tpm_limit: Optional[_int] = None
    rpm_limit: Optional[_int] = None
    budget_duration: Optional[_str] = None
    budget_reset_at: Optional[datetime.datetime] = None
    allowed_cache_controls: List[_str]
    model_spend: 'fields.Json'
    model_max_budget: 'fields.Json'
    created_at: Optional[datetime.datetime] = None
    updated_at: Optional[datetime.datetime] = None
    litellm_organization_table: Optional['models.LiteLLM_OrganizationTable'] = None
    organization_memberships: Optional[List['models.LiteLLM_OrganizationMembership']] = None
    invitations_created: Optional[List['models.LiteLLM_InvitationLink']] = None
    invitations_updated: Optional[List['models.LiteLLM_InvitationLink']] = None
    invitations_user: Optional[List['models.LiteLLM_InvitationLink']] = None
    object_permission: Optional['models.LiteLLM_ObjectPermissionTable'] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )

    @field_validator('teams', 'models', 'allowed_cache_controls', pre=True, allow_reuse=True)
    @classmethod
    def _transform_required_list_fields(cls, value: object) -> object:
        # When using raw queries, some databases will return `None` for an array field that has not been set yet.
        #
        # In our case we want to use an empty list instead as that is the internal Prisma behaviour and we want
        # to use the same consistent structure between the core ORM and raw queries. For example, if we updated
        # our type definitions to include `None` for `List` fields then it would be misleading as it will only
        # ever be `None` in raw queries.
        if value is None:
            return []

        return value

    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.LiteLLM_UserTableKeys']] = None,
        exclude: Optional[Iterable['types.LiteLLM_UserTableKeys']] = None,
        required: Optional[Iterable['types.LiteLLM_UserTableKeys']] = None,
        optional: Optional[Iterable['types.LiteLLM_UserTableKeys']] = None,
        relations: Optional[Mapping['types.LiteLLM_UserTableRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.LiteLLM_UserTableKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _LiteLLM_UserTable_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _LiteLLM_UserTable_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _LiteLLM_UserTable_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _LiteLLM_UserTable_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _LiteLLM_UserTable_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _LiteLLM_UserTable_relational_fields:
                        raise errors.UnknownRelationalFieldError('LiteLLM_UserTable', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid LiteLLM_UserTable / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'LiteLLM_UserTable',
            }
        )
        _created_partial_types.add(name)


class LiteLLM_ObjectPermissionTable(bases.BaseLiteLLM_ObjectPermissionTable):
    """Represents a LiteLLM_ObjectPermissionTable record"""

    object_permission_id: _str
    mcp_servers: List[_str]
    mcp_access_groups: List[_str]
    vector_stores: List[_str]
    teams: Optional[List['models.LiteLLM_TeamTable']] = None
    verification_tokens: Optional[List['models.LiteLLM_VerificationToken']] = None
    organizations: Optional[List['models.LiteLLM_OrganizationTable']] = None
    users: Optional[List['models.LiteLLM_UserTable']] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )

    @field_validator('mcp_servers', 'mcp_access_groups', 'vector_stores', pre=True, allow_reuse=True)
    @classmethod
    def _transform_required_list_fields(cls, value: object) -> object:
        # When using raw queries, some databases will return `None` for an array field that has not been set yet.
        #
        # In our case we want to use an empty list instead as that is the internal Prisma behaviour and we want
        # to use the same consistent structure between the core ORM and raw queries. For example, if we updated
        # our type definitions to include `None` for `List` fields then it would be misleading as it will only
        # ever be `None` in raw queries.
        if value is None:
            return []

        return value

    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.LiteLLM_ObjectPermissionTableKeys']] = None,
        exclude: Optional[Iterable['types.LiteLLM_ObjectPermissionTableKeys']] = None,
        required: Optional[Iterable['types.LiteLLM_ObjectPermissionTableKeys']] = None,
        optional: Optional[Iterable['types.LiteLLM_ObjectPermissionTableKeys']] = None,
        relations: Optional[Mapping['types.LiteLLM_ObjectPermissionTableRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.LiteLLM_ObjectPermissionTableKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _LiteLLM_ObjectPermissionTable_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _LiteLLM_ObjectPermissionTable_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _LiteLLM_ObjectPermissionTable_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _LiteLLM_ObjectPermissionTable_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _LiteLLM_ObjectPermissionTable_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _LiteLLM_ObjectPermissionTable_relational_fields:
                        raise errors.UnknownRelationalFieldError('LiteLLM_ObjectPermissionTable', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid LiteLLM_ObjectPermissionTable / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'LiteLLM_ObjectPermissionTable',
            }
        )
        _created_partial_types.add(name)


class LiteLLM_MCPServerTable(bases.BaseLiteLLM_MCPServerTable):
    """Represents a LiteLLM_MCPServerTable record"""

    server_id: _str
    server_name: Optional[_str] = None
    alias: Optional[_str] = None
    description: Optional[_str] = None
    url: Optional[_str] = None
    transport: _str
    spec_version: _str
    auth_type: Optional[_str] = None
    created_at: Optional[datetime.datetime] = None
    created_by: Optional[_str] = None
    updated_at: Optional[datetime.datetime] = None
    updated_by: Optional[_str] = None
    mcp_info: Optional['fields.Json'] = None
    mcp_access_groups: List[_str]
    status: Optional[_str] = None
    last_health_check: Optional[datetime.datetime] = None
    health_check_error: Optional[_str] = None
    command: Optional[_str] = None
    args: List[_str]
    env: Optional['fields.Json'] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )

    @field_validator('mcp_access_groups', 'args', pre=True, allow_reuse=True)
    @classmethod
    def _transform_required_list_fields(cls, value: object) -> object:
        # When using raw queries, some databases will return `None` for an array field that has not been set yet.
        #
        # In our case we want to use an empty list instead as that is the internal Prisma behaviour and we want
        # to use the same consistent structure between the core ORM and raw queries. For example, if we updated
        # our type definitions to include `None` for `List` fields then it would be misleading as it will only
        # ever be `None` in raw queries.
        if value is None:
            return []

        return value

    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.LiteLLM_MCPServerTableKeys']] = None,
        exclude: Optional[Iterable['types.LiteLLM_MCPServerTableKeys']] = None,
        required: Optional[Iterable['types.LiteLLM_MCPServerTableKeys']] = None,
        optional: Optional[Iterable['types.LiteLLM_MCPServerTableKeys']] = None,
        relations: Optional[Mapping['types.LiteLLM_MCPServerTableRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.LiteLLM_MCPServerTableKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _LiteLLM_MCPServerTable_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _LiteLLM_MCPServerTable_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _LiteLLM_MCPServerTable_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _LiteLLM_MCPServerTable_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True


            if relations:
                raise ValueError('Model: "LiteLLM_MCPServerTable" has no relational fields.')
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid LiteLLM_MCPServerTable / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'LiteLLM_MCPServerTable',
            }
        )
        _created_partial_types.add(name)


class LiteLLM_VerificationToken(bases.BaseLiteLLM_VerificationToken):
    """Represents a LiteLLM_VerificationToken record"""

    token: _str
    key_name: Optional[_str] = None
    key_alias: Optional[_str] = None
    soft_budget_cooldown: _bool
    spend: _float
    expires: Optional[datetime.datetime] = None
    models: List[_str]
    aliases: 'fields.Json'
    config: 'fields.Json'
    user_id: Optional[_str] = None
    team_id: Optional[_str] = None
    permissions: 'fields.Json'
    max_parallel_requests: Optional[_int] = None
    metadata: 'fields.Json'
    blocked: Optional[_bool] = None
    tpm_limit: Optional[_int] = None
    rpm_limit: Optional[_int] = None
    max_budget: Optional[_float] = None
    budget_duration: Optional[_str] = None
    budget_reset_at: Optional[datetime.datetime] = None
    allowed_cache_controls: List[_str]
    allowed_routes: List[_str]
    model_spend: 'fields.Json'
    model_max_budget: 'fields.Json'
    budget_id: Optional[_str] = None
    organization_id: Optional[_str] = None
    object_permission_id: Optional[_str] = None
    created_at: Optional[datetime.datetime] = None
    created_by: Optional[_str] = None
    updated_at: Optional[datetime.datetime] = None
    updated_by: Optional[_str] = None
    litellm_budget_table: Optional['models.LiteLLM_BudgetTable'] = None
    litellm_organization_table: Optional['models.LiteLLM_OrganizationTable'] = None
    object_permission: Optional['models.LiteLLM_ObjectPermissionTable'] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )

    @field_validator('models', 'allowed_cache_controls', 'allowed_routes', pre=True, allow_reuse=True)
    @classmethod
    def _transform_required_list_fields(cls, value: object) -> object:
        # When using raw queries, some databases will return `None` for an array field that has not been set yet.
        #
        # In our case we want to use an empty list instead as that is the internal Prisma behaviour and we want
        # to use the same consistent structure between the core ORM and raw queries. For example, if we updated
        # our type definitions to include `None` for `List` fields then it would be misleading as it will only
        # ever be `None` in raw queries.
        if value is None:
            return []

        return value

    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.LiteLLM_VerificationTokenKeys']] = None,
        exclude: Optional[Iterable['types.LiteLLM_VerificationTokenKeys']] = None,
        required: Optional[Iterable['types.LiteLLM_VerificationTokenKeys']] = None,
        optional: Optional[Iterable['types.LiteLLM_VerificationTokenKeys']] = None,
        relations: Optional[Mapping['types.LiteLLM_VerificationTokenRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.LiteLLM_VerificationTokenKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _LiteLLM_VerificationToken_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _LiteLLM_VerificationToken_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _LiteLLM_VerificationToken_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _LiteLLM_VerificationToken_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _LiteLLM_VerificationToken_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _LiteLLM_VerificationToken_relational_fields:
                        raise errors.UnknownRelationalFieldError('LiteLLM_VerificationToken', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid LiteLLM_VerificationToken / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'LiteLLM_VerificationToken',
            }
        )
        _created_partial_types.add(name)


class LiteLLM_EndUserTable(bases.BaseLiteLLM_EndUserTable):
    """Represents a LiteLLM_EndUserTable record"""

    user_id: _str
    alias: Optional[_str] = None
    spend: _float
    allowed_model_region: Optional[_str] = None
    default_model: Optional[_str] = None
    budget_id: Optional[_str] = None
    litellm_budget_table: Optional['models.LiteLLM_BudgetTable'] = None
    blocked: _bool

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.LiteLLM_EndUserTableKeys']] = None,
        exclude: Optional[Iterable['types.LiteLLM_EndUserTableKeys']] = None,
        required: Optional[Iterable['types.LiteLLM_EndUserTableKeys']] = None,
        optional: Optional[Iterable['types.LiteLLM_EndUserTableKeys']] = None,
        relations: Optional[Mapping['types.LiteLLM_EndUserTableRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.LiteLLM_EndUserTableKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _LiteLLM_EndUserTable_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _LiteLLM_EndUserTable_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _LiteLLM_EndUserTable_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _LiteLLM_EndUserTable_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _LiteLLM_EndUserTable_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _LiteLLM_EndUserTable_relational_fields:
                        raise errors.UnknownRelationalFieldError('LiteLLM_EndUserTable', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid LiteLLM_EndUserTable / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'LiteLLM_EndUserTable',
            }
        )
        _created_partial_types.add(name)


class LiteLLM_Config(bases.BaseLiteLLM_Config):
    """Represents a LiteLLM_Config record"""

    param_name: _str
    param_value: Optional['fields.Json'] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.LiteLLM_ConfigKeys']] = None,
        exclude: Optional[Iterable['types.LiteLLM_ConfigKeys']] = None,
        required: Optional[Iterable['types.LiteLLM_ConfigKeys']] = None,
        optional: Optional[Iterable['types.LiteLLM_ConfigKeys']] = None,
        relations: Optional[Mapping['types.LiteLLM_ConfigRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.LiteLLM_ConfigKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _LiteLLM_Config_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _LiteLLM_Config_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _LiteLLM_Config_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _LiteLLM_Config_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True


            if relations:
                raise ValueError('Model: "LiteLLM_Config" has no relational fields.')
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid LiteLLM_Config / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'LiteLLM_Config',
            }
        )
        _created_partial_types.add(name)


class LiteLLM_SpendLogs(bases.BaseLiteLLM_SpendLogs):
    """Represents a LiteLLM_SpendLogs record"""

    request_id: _str
    call_type: _str
    api_key: _str
    spend: _float
    total_tokens: _int
    prompt_tokens: _int
    completion_tokens: _int
    startTime: datetime.datetime
    endTime: datetime.datetime
    completionStartTime: Optional[datetime.datetime] = None
    model: _str
    model_id: Optional[_str] = None
    model_group: Optional[_str] = None
    custom_llm_provider: Optional[_str] = None
    api_base: Optional[_str] = None
    user: Optional[_str] = None
    metadata: Optional['fields.Json'] = None
    cache_hit: Optional[_str] = None
    cache_key: Optional[_str] = None
    request_tags: Optional['fields.Json'] = None
    team_id: Optional[_str] = None
    end_user: Optional[_str] = None
    requester_ip_address: Optional[_str] = None
    messages: Optional['fields.Json'] = None
    response: Optional['fields.Json'] = None
    session_id: Optional[_str] = None
    status: Optional[_str] = None
    mcp_namespaced_tool_name: Optional[_str] = None
    proxy_server_request: Optional['fields.Json'] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.LiteLLM_SpendLogsKeys']] = None,
        exclude: Optional[Iterable['types.LiteLLM_SpendLogsKeys']] = None,
        required: Optional[Iterable['types.LiteLLM_SpendLogsKeys']] = None,
        optional: Optional[Iterable['types.LiteLLM_SpendLogsKeys']] = None,
        relations: Optional[Mapping['types.LiteLLM_SpendLogsRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.LiteLLM_SpendLogsKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _LiteLLM_SpendLogs_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _LiteLLM_SpendLogs_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _LiteLLM_SpendLogs_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _LiteLLM_SpendLogs_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True


            if relations:
                raise ValueError('Model: "LiteLLM_SpendLogs" has no relational fields.')
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid LiteLLM_SpendLogs / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'LiteLLM_SpendLogs',
            }
        )
        _created_partial_types.add(name)


class LiteLLM_ErrorLogs(bases.BaseLiteLLM_ErrorLogs):
    """Represents a LiteLLM_ErrorLogs record"""

    request_id: _str
    startTime: datetime.datetime
    endTime: datetime.datetime
    api_base: _str
    model_group: _str
    litellm_model_name: _str
    model_id: _str
    request_kwargs: 'fields.Json'
    exception_type: _str
    exception_string: _str
    status_code: _str

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.LiteLLM_ErrorLogsKeys']] = None,
        exclude: Optional[Iterable['types.LiteLLM_ErrorLogsKeys']] = None,
        required: Optional[Iterable['types.LiteLLM_ErrorLogsKeys']] = None,
        optional: Optional[Iterable['types.LiteLLM_ErrorLogsKeys']] = None,
        relations: Optional[Mapping['types.LiteLLM_ErrorLogsRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.LiteLLM_ErrorLogsKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _LiteLLM_ErrorLogs_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _LiteLLM_ErrorLogs_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _LiteLLM_ErrorLogs_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _LiteLLM_ErrorLogs_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True


            if relations:
                raise ValueError('Model: "LiteLLM_ErrorLogs" has no relational fields.')
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid LiteLLM_ErrorLogs / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'LiteLLM_ErrorLogs',
            }
        )
        _created_partial_types.add(name)


class LiteLLM_UserNotifications(bases.BaseLiteLLM_UserNotifications):
    """Represents a LiteLLM_UserNotifications record"""

    request_id: _str
    user_id: _str
    models: List[_str]
    justification: _str
    status: _str

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )

    @field_validator('models', pre=True, allow_reuse=True)
    @classmethod
    def _transform_required_list_fields(cls, value: object) -> object:
        # When using raw queries, some databases will return `None` for an array field that has not been set yet.
        #
        # In our case we want to use an empty list instead as that is the internal Prisma behaviour and we want
        # to use the same consistent structure between the core ORM and raw queries. For example, if we updated
        # our type definitions to include `None` for `List` fields then it would be misleading as it will only
        # ever be `None` in raw queries.
        if value is None:
            return []

        return value

    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.LiteLLM_UserNotificationsKeys']] = None,
        exclude: Optional[Iterable['types.LiteLLM_UserNotificationsKeys']] = None,
        required: Optional[Iterable['types.LiteLLM_UserNotificationsKeys']] = None,
        optional: Optional[Iterable['types.LiteLLM_UserNotificationsKeys']] = None,
        relations: Optional[Mapping['types.LiteLLM_UserNotificationsRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.LiteLLM_UserNotificationsKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _LiteLLM_UserNotifications_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _LiteLLM_UserNotifications_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _LiteLLM_UserNotifications_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _LiteLLM_UserNotifications_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True


            if relations:
                raise ValueError('Model: "LiteLLM_UserNotifications" has no relational fields.')
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid LiteLLM_UserNotifications / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'LiteLLM_UserNotifications',
            }
        )
        _created_partial_types.add(name)


class LiteLLM_TeamMembership(bases.BaseLiteLLM_TeamMembership):
    """Represents a LiteLLM_TeamMembership record"""

    user_id: _str
    team_id: _str
    spend: _float
    budget_id: Optional[_str] = None
    litellm_budget_table: Optional['models.LiteLLM_BudgetTable'] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.LiteLLM_TeamMembershipKeys']] = None,
        exclude: Optional[Iterable['types.LiteLLM_TeamMembershipKeys']] = None,
        required: Optional[Iterable['types.LiteLLM_TeamMembershipKeys']] = None,
        optional: Optional[Iterable['types.LiteLLM_TeamMembershipKeys']] = None,
        relations: Optional[Mapping['types.LiteLLM_TeamMembershipRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.LiteLLM_TeamMembershipKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _LiteLLM_TeamMembership_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _LiteLLM_TeamMembership_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _LiteLLM_TeamMembership_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _LiteLLM_TeamMembership_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _LiteLLM_TeamMembership_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _LiteLLM_TeamMembership_relational_fields:
                        raise errors.UnknownRelationalFieldError('LiteLLM_TeamMembership', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid LiteLLM_TeamMembership / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'LiteLLM_TeamMembership',
            }
        )
        _created_partial_types.add(name)


class LiteLLM_OrganizationMembership(bases.BaseLiteLLM_OrganizationMembership):
    """Represents a LiteLLM_OrganizationMembership record"""

    user_id: _str
    organization_id: _str
    user_role: Optional[_str] = None
    spend: Optional[_float] = None
    budget_id: Optional[_str] = None
    created_at: Optional[datetime.datetime] = None
    updated_at: Optional[datetime.datetime] = None
    user: Optional['models.LiteLLM_UserTable'] = None
    organization: Optional['models.LiteLLM_OrganizationTable'] = None
    litellm_budget_table: Optional['models.LiteLLM_BudgetTable'] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.LiteLLM_OrganizationMembershipKeys']] = None,
        exclude: Optional[Iterable['types.LiteLLM_OrganizationMembershipKeys']] = None,
        required: Optional[Iterable['types.LiteLLM_OrganizationMembershipKeys']] = None,
        optional: Optional[Iterable['types.LiteLLM_OrganizationMembershipKeys']] = None,
        relations: Optional[Mapping['types.LiteLLM_OrganizationMembershipRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.LiteLLM_OrganizationMembershipKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _LiteLLM_OrganizationMembership_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _LiteLLM_OrganizationMembership_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _LiteLLM_OrganizationMembership_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _LiteLLM_OrganizationMembership_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _LiteLLM_OrganizationMembership_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _LiteLLM_OrganizationMembership_relational_fields:
                        raise errors.UnknownRelationalFieldError('LiteLLM_OrganizationMembership', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid LiteLLM_OrganizationMembership / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'LiteLLM_OrganizationMembership',
            }
        )
        _created_partial_types.add(name)


class LiteLLM_InvitationLink(bases.BaseLiteLLM_InvitationLink):
    """Represents a LiteLLM_InvitationLink record"""

    id: _str
    user_id: _str
    is_accepted: _bool
    accepted_at: Optional[datetime.datetime] = None
    expires_at: datetime.datetime
    created_at: datetime.datetime
    created_by: _str
    updated_at: datetime.datetime
    updated_by: _str
    liteLLM_user_table_user: Optional['models.LiteLLM_UserTable'] = None
    liteLLM_user_table_created: Optional['models.LiteLLM_UserTable'] = None
    liteLLM_user_table_updated: Optional['models.LiteLLM_UserTable'] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.LiteLLM_InvitationLinkKeys']] = None,
        exclude: Optional[Iterable['types.LiteLLM_InvitationLinkKeys']] = None,
        required: Optional[Iterable['types.LiteLLM_InvitationLinkKeys']] = None,
        optional: Optional[Iterable['types.LiteLLM_InvitationLinkKeys']] = None,
        relations: Optional[Mapping['types.LiteLLM_InvitationLinkRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.LiteLLM_InvitationLinkKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _LiteLLM_InvitationLink_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _LiteLLM_InvitationLink_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _LiteLLM_InvitationLink_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _LiteLLM_InvitationLink_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _LiteLLM_InvitationLink_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _LiteLLM_InvitationLink_relational_fields:
                        raise errors.UnknownRelationalFieldError('LiteLLM_InvitationLink', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid LiteLLM_InvitationLink / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'LiteLLM_InvitationLink',
            }
        )
        _created_partial_types.add(name)


class LiteLLM_AuditLog(bases.BaseLiteLLM_AuditLog):
    """Represents a LiteLLM_AuditLog record"""

    id: _str
    updated_at: datetime.datetime
    changed_by: _str
    changed_by_api_key: _str
    action: _str
    table_name: _str
    object_id: _str
    before_value: Optional['fields.Json'] = None
    updated_values: Optional['fields.Json'] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.LiteLLM_AuditLogKeys']] = None,
        exclude: Optional[Iterable['types.LiteLLM_AuditLogKeys']] = None,
        required: Optional[Iterable['types.LiteLLM_AuditLogKeys']] = None,
        optional: Optional[Iterable['types.LiteLLM_AuditLogKeys']] = None,
        relations: Optional[Mapping['types.LiteLLM_AuditLogRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.LiteLLM_AuditLogKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _LiteLLM_AuditLog_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _LiteLLM_AuditLog_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _LiteLLM_AuditLog_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _LiteLLM_AuditLog_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True


            if relations:
                raise ValueError('Model: "LiteLLM_AuditLog" has no relational fields.')
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid LiteLLM_AuditLog / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'LiteLLM_AuditLog',
            }
        )
        _created_partial_types.add(name)


class LiteLLM_DailyUserSpend(bases.BaseLiteLLM_DailyUserSpend):
    """Represents a LiteLLM_DailyUserSpend record"""

    id: _str
    user_id: Optional[_str] = None
    date: _str
    api_key: _str
    model: Optional[_str] = None
    model_group: Optional[_str] = None
    custom_llm_provider: Optional[_str] = None
    mcp_namespaced_tool_name: Optional[_str] = None
    prompt_tokens: _int
    completion_tokens: _int
    cache_read_input_tokens: _int
    cache_creation_input_tokens: _int
    spend: _float
    api_requests: _int
    successful_requests: _int
    failed_requests: _int
    created_at: datetime.datetime
    updated_at: datetime.datetime

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.LiteLLM_DailyUserSpendKeys']] = None,
        exclude: Optional[Iterable['types.LiteLLM_DailyUserSpendKeys']] = None,
        required: Optional[Iterable['types.LiteLLM_DailyUserSpendKeys']] = None,
        optional: Optional[Iterable['types.LiteLLM_DailyUserSpendKeys']] = None,
        relations: Optional[Mapping['types.LiteLLM_DailyUserSpendRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.LiteLLM_DailyUserSpendKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _LiteLLM_DailyUserSpend_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _LiteLLM_DailyUserSpend_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _LiteLLM_DailyUserSpend_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _LiteLLM_DailyUserSpend_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True


            if relations:
                raise ValueError('Model: "LiteLLM_DailyUserSpend" has no relational fields.')
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid LiteLLM_DailyUserSpend / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'LiteLLM_DailyUserSpend',
            }
        )
        _created_partial_types.add(name)


class LiteLLM_DailyTeamSpend(bases.BaseLiteLLM_DailyTeamSpend):
    """Represents a LiteLLM_DailyTeamSpend record"""

    id: _str
    team_id: Optional[_str] = None
    date: _str
    api_key: _str
    model: Optional[_str] = None
    model_group: Optional[_str] = None
    custom_llm_provider: Optional[_str] = None
    mcp_namespaced_tool_name: Optional[_str] = None
    prompt_tokens: _int
    completion_tokens: _int
    cache_read_input_tokens: _int
    cache_creation_input_tokens: _int
    spend: _float
    api_requests: _int
    successful_requests: _int
    failed_requests: _int
    created_at: datetime.datetime
    updated_at: datetime.datetime

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.LiteLLM_DailyTeamSpendKeys']] = None,
        exclude: Optional[Iterable['types.LiteLLM_DailyTeamSpendKeys']] = None,
        required: Optional[Iterable['types.LiteLLM_DailyTeamSpendKeys']] = None,
        optional: Optional[Iterable['types.LiteLLM_DailyTeamSpendKeys']] = None,
        relations: Optional[Mapping['types.LiteLLM_DailyTeamSpendRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.LiteLLM_DailyTeamSpendKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _LiteLLM_DailyTeamSpend_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _LiteLLM_DailyTeamSpend_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _LiteLLM_DailyTeamSpend_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _LiteLLM_DailyTeamSpend_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True


            if relations:
                raise ValueError('Model: "LiteLLM_DailyTeamSpend" has no relational fields.')
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid LiteLLM_DailyTeamSpend / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'LiteLLM_DailyTeamSpend',
            }
        )
        _created_partial_types.add(name)


class LiteLLM_DailyTagSpend(bases.BaseLiteLLM_DailyTagSpend):
    """Represents a LiteLLM_DailyTagSpend record"""

    id: _str
    tag: Optional[_str] = None
    date: _str
    api_key: _str
    model: Optional[_str] = None
    model_group: Optional[_str] = None
    custom_llm_provider: Optional[_str] = None
    mcp_namespaced_tool_name: Optional[_str] = None
    prompt_tokens: _int
    completion_tokens: _int
    cache_read_input_tokens: _int
    cache_creation_input_tokens: _int
    spend: _float
    api_requests: _int
    successful_requests: _int
    failed_requests: _int
    created_at: datetime.datetime
    updated_at: datetime.datetime

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.LiteLLM_DailyTagSpendKeys']] = None,
        exclude: Optional[Iterable['types.LiteLLM_DailyTagSpendKeys']] = None,
        required: Optional[Iterable['types.LiteLLM_DailyTagSpendKeys']] = None,
        optional: Optional[Iterable['types.LiteLLM_DailyTagSpendKeys']] = None,
        relations: Optional[Mapping['types.LiteLLM_DailyTagSpendRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.LiteLLM_DailyTagSpendKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _LiteLLM_DailyTagSpend_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _LiteLLM_DailyTagSpend_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _LiteLLM_DailyTagSpend_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _LiteLLM_DailyTagSpend_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True


            if relations:
                raise ValueError('Model: "LiteLLM_DailyTagSpend" has no relational fields.')
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid LiteLLM_DailyTagSpend / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'LiteLLM_DailyTagSpend',
            }
        )
        _created_partial_types.add(name)


class LiteLLM_CronJob(bases.BaseLiteLLM_CronJob):
    """Represents a LiteLLM_CronJob record"""

    cronjob_id: _str
    pod_id: _str
    status: 'enums.JobStatus'
    last_updated: datetime.datetime
    ttl: datetime.datetime

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.LiteLLM_CronJobKeys']] = None,
        exclude: Optional[Iterable['types.LiteLLM_CronJobKeys']] = None,
        required: Optional[Iterable['types.LiteLLM_CronJobKeys']] = None,
        optional: Optional[Iterable['types.LiteLLM_CronJobKeys']] = None,
        relations: Optional[Mapping['types.LiteLLM_CronJobRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.LiteLLM_CronJobKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _LiteLLM_CronJob_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _LiteLLM_CronJob_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _LiteLLM_CronJob_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _LiteLLM_CronJob_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True


            if relations:
                raise ValueError('Model: "LiteLLM_CronJob" has no relational fields.')
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid LiteLLM_CronJob / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'LiteLLM_CronJob',
            }
        )
        _created_partial_types.add(name)


class LiteLLM_ManagedFileTable(bases.BaseLiteLLM_ManagedFileTable):
    """Represents a LiteLLM_ManagedFileTable record"""

    id: _str
    unified_file_id: _str
    file_object: Optional['fields.Json'] = None
    model_mappings: 'fields.Json'
    flat_model_file_ids: List[_str]
    created_at: datetime.datetime
    created_by: Optional[_str] = None
    updated_at: datetime.datetime
    updated_by: Optional[_str] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )

    @field_validator('flat_model_file_ids', pre=True, allow_reuse=True)
    @classmethod
    def _transform_required_list_fields(cls, value: object) -> object:
        # When using raw queries, some databases will return `None` for an array field that has not been set yet.
        #
        # In our case we want to use an empty list instead as that is the internal Prisma behaviour and we want
        # to use the same consistent structure between the core ORM and raw queries. For example, if we updated
        # our type definitions to include `None` for `List` fields then it would be misleading as it will only
        # ever be `None` in raw queries.
        if value is None:
            return []

        return value

    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.LiteLLM_ManagedFileTableKeys']] = None,
        exclude: Optional[Iterable['types.LiteLLM_ManagedFileTableKeys']] = None,
        required: Optional[Iterable['types.LiteLLM_ManagedFileTableKeys']] = None,
        optional: Optional[Iterable['types.LiteLLM_ManagedFileTableKeys']] = None,
        relations: Optional[Mapping['types.LiteLLM_ManagedFileTableRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.LiteLLM_ManagedFileTableKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _LiteLLM_ManagedFileTable_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _LiteLLM_ManagedFileTable_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _LiteLLM_ManagedFileTable_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _LiteLLM_ManagedFileTable_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True


            if relations:
                raise ValueError('Model: "LiteLLM_ManagedFileTable" has no relational fields.')
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid LiteLLM_ManagedFileTable / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'LiteLLM_ManagedFileTable',
            }
        )
        _created_partial_types.add(name)


class LiteLLM_ManagedObjectTable(bases.BaseLiteLLM_ManagedObjectTable):
    """Represents a LiteLLM_ManagedObjectTable record"""

    id: _str
    unified_object_id: _str
    model_object_id: _str
    file_object: 'fields.Json'
    file_purpose: _str
    status: Optional[_str] = None
    created_at: datetime.datetime
    created_by: Optional[_str] = None
    updated_at: datetime.datetime
    updated_by: Optional[_str] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.LiteLLM_ManagedObjectTableKeys']] = None,
        exclude: Optional[Iterable['types.LiteLLM_ManagedObjectTableKeys']] = None,
        required: Optional[Iterable['types.LiteLLM_ManagedObjectTableKeys']] = None,
        optional: Optional[Iterable['types.LiteLLM_ManagedObjectTableKeys']] = None,
        relations: Optional[Mapping['types.LiteLLM_ManagedObjectTableRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.LiteLLM_ManagedObjectTableKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _LiteLLM_ManagedObjectTable_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _LiteLLM_ManagedObjectTable_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _LiteLLM_ManagedObjectTable_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _LiteLLM_ManagedObjectTable_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True


            if relations:
                raise ValueError('Model: "LiteLLM_ManagedObjectTable" has no relational fields.')
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid LiteLLM_ManagedObjectTable / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'LiteLLM_ManagedObjectTable',
            }
        )
        _created_partial_types.add(name)


class LiteLLM_ManagedVectorStoresTable(bases.BaseLiteLLM_ManagedVectorStoresTable):
    """Represents a LiteLLM_ManagedVectorStoresTable record"""

    vector_store_id: _str
    custom_llm_provider: _str
    vector_store_name: Optional[_str] = None
    vector_store_description: Optional[_str] = None
    vector_store_metadata: Optional['fields.Json'] = None
    created_at: datetime.datetime
    updated_at: datetime.datetime
    litellm_credential_name: Optional[_str] = None
    litellm_params: Optional['fields.Json'] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.LiteLLM_ManagedVectorStoresTableKeys']] = None,
        exclude: Optional[Iterable['types.LiteLLM_ManagedVectorStoresTableKeys']] = None,
        required: Optional[Iterable['types.LiteLLM_ManagedVectorStoresTableKeys']] = None,
        optional: Optional[Iterable['types.LiteLLM_ManagedVectorStoresTableKeys']] = None,
        relations: Optional[Mapping['types.LiteLLM_ManagedVectorStoresTableRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.LiteLLM_ManagedVectorStoresTableKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _LiteLLM_ManagedVectorStoresTable_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _LiteLLM_ManagedVectorStoresTable_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _LiteLLM_ManagedVectorStoresTable_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _LiteLLM_ManagedVectorStoresTable_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True


            if relations:
                raise ValueError('Model: "LiteLLM_ManagedVectorStoresTable" has no relational fields.')
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid LiteLLM_ManagedVectorStoresTable / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'LiteLLM_ManagedVectorStoresTable',
            }
        )
        _created_partial_types.add(name)


class LiteLLM_GuardrailsTable(bases.BaseLiteLLM_GuardrailsTable):
    """Represents a LiteLLM_GuardrailsTable record"""

    guardrail_id: _str
    guardrail_name: _str
    litellm_params: 'fields.Json'
    guardrail_info: Optional['fields.Json'] = None
    created_at: datetime.datetime
    updated_at: datetime.datetime

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.LiteLLM_GuardrailsTableKeys']] = None,
        exclude: Optional[Iterable['types.LiteLLM_GuardrailsTableKeys']] = None,
        required: Optional[Iterable['types.LiteLLM_GuardrailsTableKeys']] = None,
        optional: Optional[Iterable['types.LiteLLM_GuardrailsTableKeys']] = None,
        relations: Optional[Mapping['types.LiteLLM_GuardrailsTableRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.LiteLLM_GuardrailsTableKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _LiteLLM_GuardrailsTable_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _LiteLLM_GuardrailsTable_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _LiteLLM_GuardrailsTable_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _LiteLLM_GuardrailsTable_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True


            if relations:
                raise ValueError('Model: "LiteLLM_GuardrailsTable" has no relational fields.')
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid LiteLLM_GuardrailsTable / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'LiteLLM_GuardrailsTable',
            }
        )
        _created_partial_types.add(name)


class LiteLLM_PromptTable(bases.BaseLiteLLM_PromptTable):
    """Represents a LiteLLM_PromptTable record"""

    id: _str
    prompt_id: _str
    litellm_params: 'fields.Json'
    prompt_info: Optional['fields.Json'] = None
    created_at: datetime.datetime
    updated_at: datetime.datetime

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.LiteLLM_PromptTableKeys']] = None,
        exclude: Optional[Iterable['types.LiteLLM_PromptTableKeys']] = None,
        required: Optional[Iterable['types.LiteLLM_PromptTableKeys']] = None,
        optional: Optional[Iterable['types.LiteLLM_PromptTableKeys']] = None,
        relations: Optional[Mapping['types.LiteLLM_PromptTableRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.LiteLLM_PromptTableKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _LiteLLM_PromptTable_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _LiteLLM_PromptTable_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _LiteLLM_PromptTable_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _LiteLLM_PromptTable_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True


            if relations:
                raise ValueError('Model: "LiteLLM_PromptTable" has no relational fields.')
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid LiteLLM_PromptTable / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'LiteLLM_PromptTable',
            }
        )
        _created_partial_types.add(name)


class LiteLLM_HealthCheckTable(bases.BaseLiteLLM_HealthCheckTable):
    """Represents a LiteLLM_HealthCheckTable record"""

    health_check_id: _str
    model_name: _str
    model_id: Optional[_str] = None
    status: _str
    healthy_count: _int
    unhealthy_count: _int
    error_message: Optional[_str] = None
    response_time_ms: Optional[_float] = None
    details: Optional['fields.Json'] = None
    checked_by: Optional[_str] = None
    checked_at: datetime.datetime
    created_at: datetime.datetime
    updated_at: datetime.datetime

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.LiteLLM_HealthCheckTableKeys']] = None,
        exclude: Optional[Iterable['types.LiteLLM_HealthCheckTableKeys']] = None,
        required: Optional[Iterable['types.LiteLLM_HealthCheckTableKeys']] = None,
        optional: Optional[Iterable['types.LiteLLM_HealthCheckTableKeys']] = None,
        relations: Optional[Mapping['types.LiteLLM_HealthCheckTableRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.LiteLLM_HealthCheckTableKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _LiteLLM_HealthCheckTable_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _LiteLLM_HealthCheckTable_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _LiteLLM_HealthCheckTable_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _LiteLLM_HealthCheckTable_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True


            if relations:
                raise ValueError('Model: "LiteLLM_HealthCheckTable" has no relational fields.')
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid LiteLLM_HealthCheckTable / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'LiteLLM_HealthCheckTable',
            }
        )
        _created_partial_types.add(name)



_LiteLLM_BudgetTable_relational_fields: Set[str] = {
        'organization',
        'keys',
        'end_users',
        'team_membership',
        'organization_membership',
    }
_LiteLLM_BudgetTable_fields: Dict['types.LiteLLM_BudgetTableKeys', PartialModelField] = OrderedDict(
    [
        ('budget_id', {
            'name': 'budget_id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('max_budget', {
            'name': 'max_budget',
            'is_list': False,
            'optional': True,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('soft_budget', {
            'name': 'soft_budget',
            'is_list': False,
            'optional': True,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('max_parallel_requests', {
            'name': 'max_parallel_requests',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('tpm_limit', {
            'name': 'tpm_limit',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('rpm_limit', {
            'name': 'rpm_limit',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('model_max_budget', {
            'name': 'model_max_budget',
            'is_list': False,
            'optional': True,
            'type': 'fields.Json',
            'is_relational': False,
            'documentation': None,
        }),
        ('budget_duration', {
            'name': 'budget_duration',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('budget_reset_at', {
            'name': 'budget_reset_at',
            'is_list': False,
            'optional': True,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('created_at', {
            'name': 'created_at',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('created_by', {
            'name': 'created_by',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('updated_at', {
            'name': 'updated_at',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updated_by', {
            'name': 'updated_by',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('organization', {
            'name': 'organization',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.LiteLLM_OrganizationTable\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('keys', {
            'name': 'keys',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.LiteLLM_VerificationToken\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('end_users', {
            'name': 'end_users',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.LiteLLM_EndUserTable\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('team_membership', {
            'name': 'team_membership',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.LiteLLM_TeamMembership\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('organization_membership', {
            'name': 'organization_membership',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.LiteLLM_OrganizationMembership\']',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_LiteLLM_CredentialsTable_relational_fields: Set[str] = set()  # pyright: ignore[reportUnusedVariable]
_LiteLLM_CredentialsTable_fields: Dict['types.LiteLLM_CredentialsTableKeys', PartialModelField] = OrderedDict(
    [
        ('credential_id', {
            'name': 'credential_id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('credential_name', {
            'name': 'credential_name',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('credential_values', {
            'name': 'credential_values',
            'is_list': False,
            'optional': False,
            'type': 'fields.Json',
            'is_relational': False,
            'documentation': None,
        }),
        ('credential_info', {
            'name': 'credential_info',
            'is_list': False,
            'optional': True,
            'type': 'fields.Json',
            'is_relational': False,
            'documentation': None,
        }),
        ('created_at', {
            'name': 'created_at',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('created_by', {
            'name': 'created_by',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('updated_at', {
            'name': 'updated_at',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updated_by', {
            'name': 'updated_by',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
    ],
)

_LiteLLM_ProxyModelTable_relational_fields: Set[str] = set()  # pyright: ignore[reportUnusedVariable]
_LiteLLM_ProxyModelTable_fields: Dict['types.LiteLLM_ProxyModelTableKeys', PartialModelField] = OrderedDict(
    [
        ('model_id', {
            'name': 'model_id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('model_name', {
            'name': 'model_name',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('litellm_params', {
            'name': 'litellm_params',
            'is_list': False,
            'optional': False,
            'type': 'fields.Json',
            'is_relational': False,
            'documentation': None,
        }),
        ('model_info', {
            'name': 'model_info',
            'is_list': False,
            'optional': True,
            'type': 'fields.Json',
            'is_relational': False,
            'documentation': None,
        }),
        ('created_at', {
            'name': 'created_at',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('created_by', {
            'name': 'created_by',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('updated_at', {
            'name': 'updated_at',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updated_by', {
            'name': 'updated_by',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
    ],
)

_LiteLLM_OrganizationTable_relational_fields: Set[str] = {
        'litellm_budget_table',
        'teams',
        'users',
        'keys',
        'members',
        'object_permission',
    }
_LiteLLM_OrganizationTable_fields: Dict['types.LiteLLM_OrganizationTableKeys', PartialModelField] = OrderedDict(
    [
        ('organization_id', {
            'name': 'organization_id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('organization_alias', {
            'name': 'organization_alias',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('budget_id', {
            'name': 'budget_id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('metadata', {
            'name': 'metadata',
            'is_list': False,
            'optional': False,
            'type': 'fields.Json',
            'is_relational': False,
            'documentation': None,
        }),
        ('models', {
            'name': 'models',
            'is_list': True,
            'optional': False,
            'type': 'List[_str]',
            'is_relational': False,
            'documentation': None,
        }),
        ('spend', {
            'name': 'spend',
            'is_list': False,
            'optional': False,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('model_spend', {
            'name': 'model_spend',
            'is_list': False,
            'optional': False,
            'type': 'fields.Json',
            'is_relational': False,
            'documentation': None,
        }),
        ('object_permission_id', {
            'name': 'object_permission_id',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('created_at', {
            'name': 'created_at',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('created_by', {
            'name': 'created_by',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('updated_at', {
            'name': 'updated_at',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updated_by', {
            'name': 'updated_by',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('litellm_budget_table', {
            'name': 'litellm_budget_table',
            'is_list': False,
            'optional': True,
            'type': 'models.LiteLLM_BudgetTable',
            'is_relational': True,
            'documentation': None,
        }),
        ('teams', {
            'name': 'teams',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.LiteLLM_TeamTable\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('users', {
            'name': 'users',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.LiteLLM_UserTable\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('keys', {
            'name': 'keys',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.LiteLLM_VerificationToken\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('members', {
            'name': 'members',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.LiteLLM_OrganizationMembership\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('object_permission', {
            'name': 'object_permission',
            'is_list': False,
            'optional': True,
            'type': 'models.LiteLLM_ObjectPermissionTable',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_LiteLLM_ModelTable_relational_fields: Set[str] = {
        'team',
    }
_LiteLLM_ModelTable_fields: Dict['types.LiteLLM_ModelTableKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('model_aliases', {
            'name': 'model_aliases',
            'is_list': False,
            'optional': True,
            'type': 'fields.Json',
            'is_relational': False,
            'documentation': None,
        }),
        ('created_at', {
            'name': 'created_at',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('created_by', {
            'name': 'created_by',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('updated_at', {
            'name': 'updated_at',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updated_by', {
            'name': 'updated_by',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('team', {
            'name': 'team',
            'is_list': False,
            'optional': True,
            'type': 'models.LiteLLM_TeamTable',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_LiteLLM_TeamTable_relational_fields: Set[str] = {
        'litellm_organization_table',
        'litellm_model_table',
        'object_permission',
    }
_LiteLLM_TeamTable_fields: Dict['types.LiteLLM_TeamTableKeys', PartialModelField] = OrderedDict(
    [
        ('team_id', {
            'name': 'team_id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('team_alias', {
            'name': 'team_alias',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('organization_id', {
            'name': 'organization_id',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('object_permission_id', {
            'name': 'object_permission_id',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('admins', {
            'name': 'admins',
            'is_list': True,
            'optional': False,
            'type': 'List[_str]',
            'is_relational': False,
            'documentation': None,
        }),
        ('members', {
            'name': 'members',
            'is_list': True,
            'optional': False,
            'type': 'List[_str]',
            'is_relational': False,
            'documentation': None,
        }),
        ('members_with_roles', {
            'name': 'members_with_roles',
            'is_list': False,
            'optional': False,
            'type': 'fields.Json',
            'is_relational': False,
            'documentation': None,
        }),
        ('metadata', {
            'name': 'metadata',
            'is_list': False,
            'optional': False,
            'type': 'fields.Json',
            'is_relational': False,
            'documentation': None,
        }),
        ('max_budget', {
            'name': 'max_budget',
            'is_list': False,
            'optional': True,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('spend', {
            'name': 'spend',
            'is_list': False,
            'optional': False,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('models', {
            'name': 'models',
            'is_list': True,
            'optional': False,
            'type': 'List[_str]',
            'is_relational': False,
            'documentation': None,
        }),
        ('max_parallel_requests', {
            'name': 'max_parallel_requests',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('tpm_limit', {
            'name': 'tpm_limit',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('rpm_limit', {
            'name': 'rpm_limit',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('budget_duration', {
            'name': 'budget_duration',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('budget_reset_at', {
            'name': 'budget_reset_at',
            'is_list': False,
            'optional': True,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('blocked', {
            'name': 'blocked',
            'is_list': False,
            'optional': False,
            'type': '_bool',
            'is_relational': False,
            'documentation': None,
        }),
        ('created_at', {
            'name': 'created_at',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updated_at', {
            'name': 'updated_at',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('model_spend', {
            'name': 'model_spend',
            'is_list': False,
            'optional': False,
            'type': 'fields.Json',
            'is_relational': False,
            'documentation': None,
        }),
        ('model_max_budget', {
            'name': 'model_max_budget',
            'is_list': False,
            'optional': False,
            'type': 'fields.Json',
            'is_relational': False,
            'documentation': None,
        }),
        ('team_member_permissions', {
            'name': 'team_member_permissions',
            'is_list': True,
            'optional': False,
            'type': 'List[_str]',
            'is_relational': False,
            'documentation': None,
        }),
        ('model_id', {
            'name': 'model_id',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('litellm_organization_table', {
            'name': 'litellm_organization_table',
            'is_list': False,
            'optional': True,
            'type': 'models.LiteLLM_OrganizationTable',
            'is_relational': True,
            'documentation': None,
        }),
        ('litellm_model_table', {
            'name': 'litellm_model_table',
            'is_list': False,
            'optional': True,
            'type': 'models.LiteLLM_ModelTable',
            'is_relational': True,
            'documentation': None,
        }),
        ('object_permission', {
            'name': 'object_permission',
            'is_list': False,
            'optional': True,
            'type': 'models.LiteLLM_ObjectPermissionTable',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_LiteLLM_UserTable_relational_fields: Set[str] = {
        'litellm_organization_table',
        'organization_memberships',
        'invitations_created',
        'invitations_updated',
        'invitations_user',
        'object_permission',
    }
_LiteLLM_UserTable_fields: Dict['types.LiteLLM_UserTableKeys', PartialModelField] = OrderedDict(
    [
        ('user_id', {
            'name': 'user_id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('user_alias', {
            'name': 'user_alias',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('team_id', {
            'name': 'team_id',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('sso_user_id', {
            'name': 'sso_user_id',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('organization_id', {
            'name': 'organization_id',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('object_permission_id', {
            'name': 'object_permission_id',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('password', {
            'name': 'password',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('teams', {
            'name': 'teams',
            'is_list': True,
            'optional': False,
            'type': 'List[_str]',
            'is_relational': False,
            'documentation': None,
        }),
        ('user_role', {
            'name': 'user_role',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('max_budget', {
            'name': 'max_budget',
            'is_list': False,
            'optional': True,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('spend', {
            'name': 'spend',
            'is_list': False,
            'optional': False,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('user_email', {
            'name': 'user_email',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('models', {
            'name': 'models',
            'is_list': True,
            'optional': False,
            'type': 'List[_str]',
            'is_relational': False,
            'documentation': None,
        }),
        ('metadata', {
            'name': 'metadata',
            'is_list': False,
            'optional': False,
            'type': 'fields.Json',
            'is_relational': False,
            'documentation': None,
        }),
        ('max_parallel_requests', {
            'name': 'max_parallel_requests',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('tpm_limit', {
            'name': 'tpm_limit',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('rpm_limit', {
            'name': 'rpm_limit',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('budget_duration', {
            'name': 'budget_duration',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('budget_reset_at', {
            'name': 'budget_reset_at',
            'is_list': False,
            'optional': True,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('allowed_cache_controls', {
            'name': 'allowed_cache_controls',
            'is_list': True,
            'optional': False,
            'type': 'List[_str]',
            'is_relational': False,
            'documentation': None,
        }),
        ('model_spend', {
            'name': 'model_spend',
            'is_list': False,
            'optional': False,
            'type': 'fields.Json',
            'is_relational': False,
            'documentation': None,
        }),
        ('model_max_budget', {
            'name': 'model_max_budget',
            'is_list': False,
            'optional': False,
            'type': 'fields.Json',
            'is_relational': False,
            'documentation': None,
        }),
        ('created_at', {
            'name': 'created_at',
            'is_list': False,
            'optional': True,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updated_at', {
            'name': 'updated_at',
            'is_list': False,
            'optional': True,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('litellm_organization_table', {
            'name': 'litellm_organization_table',
            'is_list': False,
            'optional': True,
            'type': 'models.LiteLLM_OrganizationTable',
            'is_relational': True,
            'documentation': None,
        }),
        ('organization_memberships', {
            'name': 'organization_memberships',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.LiteLLM_OrganizationMembership\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('invitations_created', {
            'name': 'invitations_created',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.LiteLLM_InvitationLink\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('invitations_updated', {
            'name': 'invitations_updated',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.LiteLLM_InvitationLink\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('invitations_user', {
            'name': 'invitations_user',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.LiteLLM_InvitationLink\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('object_permission', {
            'name': 'object_permission',
            'is_list': False,
            'optional': True,
            'type': 'models.LiteLLM_ObjectPermissionTable',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_LiteLLM_ObjectPermissionTable_relational_fields: Set[str] = {
        'teams',
        'verification_tokens',
        'organizations',
        'users',
    }
_LiteLLM_ObjectPermissionTable_fields: Dict['types.LiteLLM_ObjectPermissionTableKeys', PartialModelField] = OrderedDict(
    [
        ('object_permission_id', {
            'name': 'object_permission_id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('mcp_servers', {
            'name': 'mcp_servers',
            'is_list': True,
            'optional': False,
            'type': 'List[_str]',
            'is_relational': False,
            'documentation': None,
        }),
        ('mcp_access_groups', {
            'name': 'mcp_access_groups',
            'is_list': True,
            'optional': False,
            'type': 'List[_str]',
            'is_relational': False,
            'documentation': None,
        }),
        ('vector_stores', {
            'name': 'vector_stores',
            'is_list': True,
            'optional': False,
            'type': 'List[_str]',
            'is_relational': False,
            'documentation': None,
        }),
        ('teams', {
            'name': 'teams',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.LiteLLM_TeamTable\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('verification_tokens', {
            'name': 'verification_tokens',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.LiteLLM_VerificationToken\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('organizations', {
            'name': 'organizations',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.LiteLLM_OrganizationTable\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('users', {
            'name': 'users',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.LiteLLM_UserTable\']',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_LiteLLM_MCPServerTable_relational_fields: Set[str] = set()  # pyright: ignore[reportUnusedVariable]
_LiteLLM_MCPServerTable_fields: Dict['types.LiteLLM_MCPServerTableKeys', PartialModelField] = OrderedDict(
    [
        ('server_id', {
            'name': 'server_id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('server_name', {
            'name': 'server_name',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('alias', {
            'name': 'alias',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('description', {
            'name': 'description',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('url', {
            'name': 'url',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('transport', {
            'name': 'transport',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('spec_version', {
            'name': 'spec_version',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('auth_type', {
            'name': 'auth_type',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('created_at', {
            'name': 'created_at',
            'is_list': False,
            'optional': True,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('created_by', {
            'name': 'created_by',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('updated_at', {
            'name': 'updated_at',
            'is_list': False,
            'optional': True,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updated_by', {
            'name': 'updated_by',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('mcp_info', {
            'name': 'mcp_info',
            'is_list': False,
            'optional': True,
            'type': 'fields.Json',
            'is_relational': False,
            'documentation': None,
        }),
        ('mcp_access_groups', {
            'name': 'mcp_access_groups',
            'is_list': True,
            'optional': False,
            'type': 'List[_str]',
            'is_relational': False,
            'documentation': None,
        }),
        ('status', {
            'name': 'status',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('last_health_check', {
            'name': 'last_health_check',
            'is_list': False,
            'optional': True,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('health_check_error', {
            'name': 'health_check_error',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('command', {
            'name': 'command',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('args', {
            'name': 'args',
            'is_list': True,
            'optional': False,
            'type': 'List[_str]',
            'is_relational': False,
            'documentation': None,
        }),
        ('env', {
            'name': 'env',
            'is_list': False,
            'optional': True,
            'type': 'fields.Json',
            'is_relational': False,
            'documentation': None,
        }),
    ],
)

_LiteLLM_VerificationToken_relational_fields: Set[str] = {
        'litellm_budget_table',
        'litellm_organization_table',
        'object_permission',
    }
_LiteLLM_VerificationToken_fields: Dict['types.LiteLLM_VerificationTokenKeys', PartialModelField] = OrderedDict(
    [
        ('token', {
            'name': 'token',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('key_name', {
            'name': 'key_name',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('key_alias', {
            'name': 'key_alias',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('soft_budget_cooldown', {
            'name': 'soft_budget_cooldown',
            'is_list': False,
            'optional': False,
            'type': '_bool',
            'is_relational': False,
            'documentation': None,
        }),
        ('spend', {
            'name': 'spend',
            'is_list': False,
            'optional': False,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('expires', {
            'name': 'expires',
            'is_list': False,
            'optional': True,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('models', {
            'name': 'models',
            'is_list': True,
            'optional': False,
            'type': 'List[_str]',
            'is_relational': False,
            'documentation': None,
        }),
        ('aliases', {
            'name': 'aliases',
            'is_list': False,
            'optional': False,
            'type': 'fields.Json',
            'is_relational': False,
            'documentation': None,
        }),
        ('config', {
            'name': 'config',
            'is_list': False,
            'optional': False,
            'type': 'fields.Json',
            'is_relational': False,
            'documentation': None,
        }),
        ('user_id', {
            'name': 'user_id',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('team_id', {
            'name': 'team_id',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('permissions', {
            'name': 'permissions',
            'is_list': False,
            'optional': False,
            'type': 'fields.Json',
            'is_relational': False,
            'documentation': None,
        }),
        ('max_parallel_requests', {
            'name': 'max_parallel_requests',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('metadata', {
            'name': 'metadata',
            'is_list': False,
            'optional': False,
            'type': 'fields.Json',
            'is_relational': False,
            'documentation': None,
        }),
        ('blocked', {
            'name': 'blocked',
            'is_list': False,
            'optional': True,
            'type': '_bool',
            'is_relational': False,
            'documentation': None,
        }),
        ('tpm_limit', {
            'name': 'tpm_limit',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('rpm_limit', {
            'name': 'rpm_limit',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('max_budget', {
            'name': 'max_budget',
            'is_list': False,
            'optional': True,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('budget_duration', {
            'name': 'budget_duration',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('budget_reset_at', {
            'name': 'budget_reset_at',
            'is_list': False,
            'optional': True,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('allowed_cache_controls', {
            'name': 'allowed_cache_controls',
            'is_list': True,
            'optional': False,
            'type': 'List[_str]',
            'is_relational': False,
            'documentation': None,
        }),
        ('allowed_routes', {
            'name': 'allowed_routes',
            'is_list': True,
            'optional': False,
            'type': 'List[_str]',
            'is_relational': False,
            'documentation': None,
        }),
        ('model_spend', {
            'name': 'model_spend',
            'is_list': False,
            'optional': False,
            'type': 'fields.Json',
            'is_relational': False,
            'documentation': None,
        }),
        ('model_max_budget', {
            'name': 'model_max_budget',
            'is_list': False,
            'optional': False,
            'type': 'fields.Json',
            'is_relational': False,
            'documentation': None,
        }),
        ('budget_id', {
            'name': 'budget_id',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('organization_id', {
            'name': 'organization_id',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('object_permission_id', {
            'name': 'object_permission_id',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('created_at', {
            'name': 'created_at',
            'is_list': False,
            'optional': True,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('created_by', {
            'name': 'created_by',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('updated_at', {
            'name': 'updated_at',
            'is_list': False,
            'optional': True,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updated_by', {
            'name': 'updated_by',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('litellm_budget_table', {
            'name': 'litellm_budget_table',
            'is_list': False,
            'optional': True,
            'type': 'models.LiteLLM_BudgetTable',
            'is_relational': True,
            'documentation': None,
        }),
        ('litellm_organization_table', {
            'name': 'litellm_organization_table',
            'is_list': False,
            'optional': True,
            'type': 'models.LiteLLM_OrganizationTable',
            'is_relational': True,
            'documentation': None,
        }),
        ('object_permission', {
            'name': 'object_permission',
            'is_list': False,
            'optional': True,
            'type': 'models.LiteLLM_ObjectPermissionTable',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_LiteLLM_EndUserTable_relational_fields: Set[str] = {
        'litellm_budget_table',
    }
_LiteLLM_EndUserTable_fields: Dict['types.LiteLLM_EndUserTableKeys', PartialModelField] = OrderedDict(
    [
        ('user_id', {
            'name': 'user_id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('alias', {
            'name': 'alias',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('spend', {
            'name': 'spend',
            'is_list': False,
            'optional': False,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('allowed_model_region', {
            'name': 'allowed_model_region',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('default_model', {
            'name': 'default_model',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('budget_id', {
            'name': 'budget_id',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('litellm_budget_table', {
            'name': 'litellm_budget_table',
            'is_list': False,
            'optional': True,
            'type': 'models.LiteLLM_BudgetTable',
            'is_relational': True,
            'documentation': None,
        }),
        ('blocked', {
            'name': 'blocked',
            'is_list': False,
            'optional': False,
            'type': '_bool',
            'is_relational': False,
            'documentation': None,
        }),
    ],
)

_LiteLLM_Config_relational_fields: Set[str] = set()  # pyright: ignore[reportUnusedVariable]
_LiteLLM_Config_fields: Dict['types.LiteLLM_ConfigKeys', PartialModelField] = OrderedDict(
    [
        ('param_name', {
            'name': 'param_name',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('param_value', {
            'name': 'param_value',
            'is_list': False,
            'optional': True,
            'type': 'fields.Json',
            'is_relational': False,
            'documentation': None,
        }),
    ],
)

_LiteLLM_SpendLogs_relational_fields: Set[str] = set()  # pyright: ignore[reportUnusedVariable]
_LiteLLM_SpendLogs_fields: Dict['types.LiteLLM_SpendLogsKeys', PartialModelField] = OrderedDict(
    [
        ('request_id', {
            'name': 'request_id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('call_type', {
            'name': 'call_type',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('api_key', {
            'name': 'api_key',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('spend', {
            'name': 'spend',
            'is_list': False,
            'optional': False,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('total_tokens', {
            'name': 'total_tokens',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('prompt_tokens', {
            'name': 'prompt_tokens',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('completion_tokens', {
            'name': 'completion_tokens',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('startTime', {
            'name': 'startTime',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('endTime', {
            'name': 'endTime',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('completionStartTime', {
            'name': 'completionStartTime',
            'is_list': False,
            'optional': True,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('model', {
            'name': 'model',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('model_id', {
            'name': 'model_id',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('model_group', {
            'name': 'model_group',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('custom_llm_provider', {
            'name': 'custom_llm_provider',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('api_base', {
            'name': 'api_base',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('user', {
            'name': 'user',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('metadata', {
            'name': 'metadata',
            'is_list': False,
            'optional': True,
            'type': 'fields.Json',
            'is_relational': False,
            'documentation': None,
        }),
        ('cache_hit', {
            'name': 'cache_hit',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('cache_key', {
            'name': 'cache_key',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('request_tags', {
            'name': 'request_tags',
            'is_list': False,
            'optional': True,
            'type': 'fields.Json',
            'is_relational': False,
            'documentation': None,
        }),
        ('team_id', {
            'name': 'team_id',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('end_user', {
            'name': 'end_user',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('requester_ip_address', {
            'name': 'requester_ip_address',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('messages', {
            'name': 'messages',
            'is_list': False,
            'optional': True,
            'type': 'fields.Json',
            'is_relational': False,
            'documentation': None,
        }),
        ('response', {
            'name': 'response',
            'is_list': False,
            'optional': True,
            'type': 'fields.Json',
            'is_relational': False,
            'documentation': None,
        }),
        ('session_id', {
            'name': 'session_id',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('status', {
            'name': 'status',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('mcp_namespaced_tool_name', {
            'name': 'mcp_namespaced_tool_name',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('proxy_server_request', {
            'name': 'proxy_server_request',
            'is_list': False,
            'optional': True,
            'type': 'fields.Json',
            'is_relational': False,
            'documentation': None,
        }),
    ],
)

_LiteLLM_ErrorLogs_relational_fields: Set[str] = set()  # pyright: ignore[reportUnusedVariable]
_LiteLLM_ErrorLogs_fields: Dict['types.LiteLLM_ErrorLogsKeys', PartialModelField] = OrderedDict(
    [
        ('request_id', {
            'name': 'request_id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('startTime', {
            'name': 'startTime',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('endTime', {
            'name': 'endTime',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('api_base', {
            'name': 'api_base',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('model_group', {
            'name': 'model_group',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('litellm_model_name', {
            'name': 'litellm_model_name',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('model_id', {
            'name': 'model_id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('request_kwargs', {
            'name': 'request_kwargs',
            'is_list': False,
            'optional': False,
            'type': 'fields.Json',
            'is_relational': False,
            'documentation': None,
        }),
        ('exception_type', {
            'name': 'exception_type',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('exception_string', {
            'name': 'exception_string',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('status_code', {
            'name': 'status_code',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
    ],
)

_LiteLLM_UserNotifications_relational_fields: Set[str] = set()  # pyright: ignore[reportUnusedVariable]
_LiteLLM_UserNotifications_fields: Dict['types.LiteLLM_UserNotificationsKeys', PartialModelField] = OrderedDict(
    [
        ('request_id', {
            'name': 'request_id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('user_id', {
            'name': 'user_id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('models', {
            'name': 'models',
            'is_list': True,
            'optional': False,
            'type': 'List[_str]',
            'is_relational': False,
            'documentation': None,
        }),
        ('justification', {
            'name': 'justification',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('status', {
            'name': 'status',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
    ],
)

_LiteLLM_TeamMembership_relational_fields: Set[str] = {
        'litellm_budget_table',
    }
_LiteLLM_TeamMembership_fields: Dict['types.LiteLLM_TeamMembershipKeys', PartialModelField] = OrderedDict(
    [
        ('user_id', {
            'name': 'user_id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('team_id', {
            'name': 'team_id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('spend', {
            'name': 'spend',
            'is_list': False,
            'optional': False,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('budget_id', {
            'name': 'budget_id',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('litellm_budget_table', {
            'name': 'litellm_budget_table',
            'is_list': False,
            'optional': True,
            'type': 'models.LiteLLM_BudgetTable',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_LiteLLM_OrganizationMembership_relational_fields: Set[str] = {
        'user',
        'organization',
        'litellm_budget_table',
    }
_LiteLLM_OrganizationMembership_fields: Dict['types.LiteLLM_OrganizationMembershipKeys', PartialModelField] = OrderedDict(
    [
        ('user_id', {
            'name': 'user_id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('organization_id', {
            'name': 'organization_id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('user_role', {
            'name': 'user_role',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('spend', {
            'name': 'spend',
            'is_list': False,
            'optional': True,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('budget_id', {
            'name': 'budget_id',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('created_at', {
            'name': 'created_at',
            'is_list': False,
            'optional': True,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updated_at', {
            'name': 'updated_at',
            'is_list': False,
            'optional': True,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('user', {
            'name': 'user',
            'is_list': False,
            'optional': True,
            'type': 'models.LiteLLM_UserTable',
            'is_relational': True,
            'documentation': None,
        }),
        ('organization', {
            'name': 'organization',
            'is_list': False,
            'optional': True,
            'type': 'models.LiteLLM_OrganizationTable',
            'is_relational': True,
            'documentation': None,
        }),
        ('litellm_budget_table', {
            'name': 'litellm_budget_table',
            'is_list': False,
            'optional': True,
            'type': 'models.LiteLLM_BudgetTable',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_LiteLLM_InvitationLink_relational_fields: Set[str] = {
        'liteLLM_user_table_user',
        'liteLLM_user_table_created',
        'liteLLM_user_table_updated',
    }
_LiteLLM_InvitationLink_fields: Dict['types.LiteLLM_InvitationLinkKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('user_id', {
            'name': 'user_id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('is_accepted', {
            'name': 'is_accepted',
            'is_list': False,
            'optional': False,
            'type': '_bool',
            'is_relational': False,
            'documentation': None,
        }),
        ('accepted_at', {
            'name': 'accepted_at',
            'is_list': False,
            'optional': True,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('expires_at', {
            'name': 'expires_at',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('created_at', {
            'name': 'created_at',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('created_by', {
            'name': 'created_by',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('updated_at', {
            'name': 'updated_at',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updated_by', {
            'name': 'updated_by',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('liteLLM_user_table_user', {
            'name': 'liteLLM_user_table_user',
            'is_list': False,
            'optional': True,
            'type': 'models.LiteLLM_UserTable',
            'is_relational': True,
            'documentation': None,
        }),
        ('liteLLM_user_table_created', {
            'name': 'liteLLM_user_table_created',
            'is_list': False,
            'optional': True,
            'type': 'models.LiteLLM_UserTable',
            'is_relational': True,
            'documentation': None,
        }),
        ('liteLLM_user_table_updated', {
            'name': 'liteLLM_user_table_updated',
            'is_list': False,
            'optional': True,
            'type': 'models.LiteLLM_UserTable',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_LiteLLM_AuditLog_relational_fields: Set[str] = set()  # pyright: ignore[reportUnusedVariable]
_LiteLLM_AuditLog_fields: Dict['types.LiteLLM_AuditLogKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('updated_at', {
            'name': 'updated_at',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('changed_by', {
            'name': 'changed_by',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('changed_by_api_key', {
            'name': 'changed_by_api_key',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('action', {
            'name': 'action',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('table_name', {
            'name': 'table_name',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('object_id', {
            'name': 'object_id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('before_value', {
            'name': 'before_value',
            'is_list': False,
            'optional': True,
            'type': 'fields.Json',
            'is_relational': False,
            'documentation': None,
        }),
        ('updated_values', {
            'name': 'updated_values',
            'is_list': False,
            'optional': True,
            'type': 'fields.Json',
            'is_relational': False,
            'documentation': None,
        }),
    ],
)

_LiteLLM_DailyUserSpend_relational_fields: Set[str] = set()  # pyright: ignore[reportUnusedVariable]
_LiteLLM_DailyUserSpend_fields: Dict['types.LiteLLM_DailyUserSpendKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('user_id', {
            'name': 'user_id',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('date', {
            'name': 'date',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('api_key', {
            'name': 'api_key',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('model', {
            'name': 'model',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('model_group', {
            'name': 'model_group',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('custom_llm_provider', {
            'name': 'custom_llm_provider',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('mcp_namespaced_tool_name', {
            'name': 'mcp_namespaced_tool_name',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('prompt_tokens', {
            'name': 'prompt_tokens',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('completion_tokens', {
            'name': 'completion_tokens',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('cache_read_input_tokens', {
            'name': 'cache_read_input_tokens',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('cache_creation_input_tokens', {
            'name': 'cache_creation_input_tokens',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('spend', {
            'name': 'spend',
            'is_list': False,
            'optional': False,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('api_requests', {
            'name': 'api_requests',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('successful_requests', {
            'name': 'successful_requests',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('failed_requests', {
            'name': 'failed_requests',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('created_at', {
            'name': 'created_at',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updated_at', {
            'name': 'updated_at',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
    ],
)

_LiteLLM_DailyTeamSpend_relational_fields: Set[str] = set()  # pyright: ignore[reportUnusedVariable]
_LiteLLM_DailyTeamSpend_fields: Dict['types.LiteLLM_DailyTeamSpendKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('team_id', {
            'name': 'team_id',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('date', {
            'name': 'date',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('api_key', {
            'name': 'api_key',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('model', {
            'name': 'model',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('model_group', {
            'name': 'model_group',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('custom_llm_provider', {
            'name': 'custom_llm_provider',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('mcp_namespaced_tool_name', {
            'name': 'mcp_namespaced_tool_name',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('prompt_tokens', {
            'name': 'prompt_tokens',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('completion_tokens', {
            'name': 'completion_tokens',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('cache_read_input_tokens', {
            'name': 'cache_read_input_tokens',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('cache_creation_input_tokens', {
            'name': 'cache_creation_input_tokens',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('spend', {
            'name': 'spend',
            'is_list': False,
            'optional': False,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('api_requests', {
            'name': 'api_requests',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('successful_requests', {
            'name': 'successful_requests',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('failed_requests', {
            'name': 'failed_requests',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('created_at', {
            'name': 'created_at',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updated_at', {
            'name': 'updated_at',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
    ],
)

_LiteLLM_DailyTagSpend_relational_fields: Set[str] = set()  # pyright: ignore[reportUnusedVariable]
_LiteLLM_DailyTagSpend_fields: Dict['types.LiteLLM_DailyTagSpendKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('tag', {
            'name': 'tag',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('date', {
            'name': 'date',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('api_key', {
            'name': 'api_key',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('model', {
            'name': 'model',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('model_group', {
            'name': 'model_group',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('custom_llm_provider', {
            'name': 'custom_llm_provider',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('mcp_namespaced_tool_name', {
            'name': 'mcp_namespaced_tool_name',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('prompt_tokens', {
            'name': 'prompt_tokens',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('completion_tokens', {
            'name': 'completion_tokens',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('cache_read_input_tokens', {
            'name': 'cache_read_input_tokens',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('cache_creation_input_tokens', {
            'name': 'cache_creation_input_tokens',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('spend', {
            'name': 'spend',
            'is_list': False,
            'optional': False,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('api_requests', {
            'name': 'api_requests',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('successful_requests', {
            'name': 'successful_requests',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('failed_requests', {
            'name': 'failed_requests',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('created_at', {
            'name': 'created_at',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updated_at', {
            'name': 'updated_at',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
    ],
)

_LiteLLM_CronJob_relational_fields: Set[str] = set()  # pyright: ignore[reportUnusedVariable]
_LiteLLM_CronJob_fields: Dict['types.LiteLLM_CronJobKeys', PartialModelField] = OrderedDict(
    [
        ('cronjob_id', {
            'name': 'cronjob_id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('pod_id', {
            'name': 'pod_id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('status', {
            'name': 'status',
            'is_list': False,
            'optional': False,
            'type': 'enums.JobStatus',
            'is_relational': False,
            'documentation': None,
        }),
        ('last_updated', {
            'name': 'last_updated',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('ttl', {
            'name': 'ttl',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
    ],
)

_LiteLLM_ManagedFileTable_relational_fields: Set[str] = set()  # pyright: ignore[reportUnusedVariable]
_LiteLLM_ManagedFileTable_fields: Dict['types.LiteLLM_ManagedFileTableKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('unified_file_id', {
            'name': 'unified_file_id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('file_object', {
            'name': 'file_object',
            'is_list': False,
            'optional': True,
            'type': 'fields.Json',
            'is_relational': False,
            'documentation': None,
        }),
        ('model_mappings', {
            'name': 'model_mappings',
            'is_list': False,
            'optional': False,
            'type': 'fields.Json',
            'is_relational': False,
            'documentation': None,
        }),
        ('flat_model_file_ids', {
            'name': 'flat_model_file_ids',
            'is_list': True,
            'optional': False,
            'type': 'List[_str]',
            'is_relational': False,
            'documentation': None,
        }),
        ('created_at', {
            'name': 'created_at',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('created_by', {
            'name': 'created_by',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('updated_at', {
            'name': 'updated_at',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updated_by', {
            'name': 'updated_by',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
    ],
)

_LiteLLM_ManagedObjectTable_relational_fields: Set[str] = set()  # pyright: ignore[reportUnusedVariable]
_LiteLLM_ManagedObjectTable_fields: Dict['types.LiteLLM_ManagedObjectTableKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('unified_object_id', {
            'name': 'unified_object_id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('model_object_id', {
            'name': 'model_object_id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('file_object', {
            'name': 'file_object',
            'is_list': False,
            'optional': False,
            'type': 'fields.Json',
            'is_relational': False,
            'documentation': None,
        }),
        ('file_purpose', {
            'name': 'file_purpose',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('status', {
            'name': 'status',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('created_at', {
            'name': 'created_at',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('created_by', {
            'name': 'created_by',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('updated_at', {
            'name': 'updated_at',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updated_by', {
            'name': 'updated_by',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
    ],
)

_LiteLLM_ManagedVectorStoresTable_relational_fields: Set[str] = set()  # pyright: ignore[reportUnusedVariable]
_LiteLLM_ManagedVectorStoresTable_fields: Dict['types.LiteLLM_ManagedVectorStoresTableKeys', PartialModelField] = OrderedDict(
    [
        ('vector_store_id', {
            'name': 'vector_store_id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('custom_llm_provider', {
            'name': 'custom_llm_provider',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('vector_store_name', {
            'name': 'vector_store_name',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('vector_store_description', {
            'name': 'vector_store_description',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('vector_store_metadata', {
            'name': 'vector_store_metadata',
            'is_list': False,
            'optional': True,
            'type': 'fields.Json',
            'is_relational': False,
            'documentation': None,
        }),
        ('created_at', {
            'name': 'created_at',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updated_at', {
            'name': 'updated_at',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('litellm_credential_name', {
            'name': 'litellm_credential_name',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('litellm_params', {
            'name': 'litellm_params',
            'is_list': False,
            'optional': True,
            'type': 'fields.Json',
            'is_relational': False,
            'documentation': None,
        }),
    ],
)

_LiteLLM_GuardrailsTable_relational_fields: Set[str] = set()  # pyright: ignore[reportUnusedVariable]
_LiteLLM_GuardrailsTable_fields: Dict['types.LiteLLM_GuardrailsTableKeys', PartialModelField] = OrderedDict(
    [
        ('guardrail_id', {
            'name': 'guardrail_id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('guardrail_name', {
            'name': 'guardrail_name',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('litellm_params', {
            'name': 'litellm_params',
            'is_list': False,
            'optional': False,
            'type': 'fields.Json',
            'is_relational': False,
            'documentation': None,
        }),
        ('guardrail_info', {
            'name': 'guardrail_info',
            'is_list': False,
            'optional': True,
            'type': 'fields.Json',
            'is_relational': False,
            'documentation': None,
        }),
        ('created_at', {
            'name': 'created_at',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updated_at', {
            'name': 'updated_at',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
    ],
)

_LiteLLM_PromptTable_relational_fields: Set[str] = set()  # pyright: ignore[reportUnusedVariable]
_LiteLLM_PromptTable_fields: Dict['types.LiteLLM_PromptTableKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('prompt_id', {
            'name': 'prompt_id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('litellm_params', {
            'name': 'litellm_params',
            'is_list': False,
            'optional': False,
            'type': 'fields.Json',
            'is_relational': False,
            'documentation': None,
        }),
        ('prompt_info', {
            'name': 'prompt_info',
            'is_list': False,
            'optional': True,
            'type': 'fields.Json',
            'is_relational': False,
            'documentation': None,
        }),
        ('created_at', {
            'name': 'created_at',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updated_at', {
            'name': 'updated_at',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
    ],
)

_LiteLLM_HealthCheckTable_relational_fields: Set[str] = set()  # pyright: ignore[reportUnusedVariable]
_LiteLLM_HealthCheckTable_fields: Dict['types.LiteLLM_HealthCheckTableKeys', PartialModelField] = OrderedDict(
    [
        ('health_check_id', {
            'name': 'health_check_id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('model_name', {
            'name': 'model_name',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('model_id', {
            'name': 'model_id',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('status', {
            'name': 'status',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('healthy_count', {
            'name': 'healthy_count',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('unhealthy_count', {
            'name': 'unhealthy_count',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('error_message', {
            'name': 'error_message',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('response_time_ms', {
            'name': 'response_time_ms',
            'is_list': False,
            'optional': True,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('details', {
            'name': 'details',
            'is_list': False,
            'optional': True,
            'type': 'fields.Json',
            'is_relational': False,
            'documentation': None,
        }),
        ('checked_by', {
            'name': 'checked_by',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('checked_at', {
            'name': 'checked_at',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('created_at', {
            'name': 'created_at',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updated_at', {
            'name': 'updated_at',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
    ],
)



# we have to import ourselves as relation types are namespaced to models
# e.g. models.Post
from . import models, actions

# required to support relationships between models
model_rebuild(LiteLLM_BudgetTable)
model_rebuild(LiteLLM_CredentialsTable)
model_rebuild(LiteLLM_ProxyModelTable)
model_rebuild(LiteLLM_OrganizationTable)
model_rebuild(LiteLLM_ModelTable)
model_rebuild(LiteLLM_TeamTable)
model_rebuild(LiteLLM_UserTable)
model_rebuild(LiteLLM_ObjectPermissionTable)
model_rebuild(LiteLLM_MCPServerTable)
model_rebuild(LiteLLM_VerificationToken)
model_rebuild(LiteLLM_EndUserTable)
model_rebuild(LiteLLM_Config)
model_rebuild(LiteLLM_SpendLogs)
model_rebuild(LiteLLM_ErrorLogs)
model_rebuild(LiteLLM_UserNotifications)
model_rebuild(LiteLLM_TeamMembership)
model_rebuild(LiteLLM_OrganizationMembership)
model_rebuild(LiteLLM_InvitationLink)
model_rebuild(LiteLLM_AuditLog)
model_rebuild(LiteLLM_DailyUserSpend)
model_rebuild(LiteLLM_DailyTeamSpend)
model_rebuild(LiteLLM_DailyTagSpend)
model_rebuild(LiteLLM_CronJob)
model_rebuild(LiteLLM_ManagedFileTable)
model_rebuild(LiteLLM_ManagedObjectTable)
model_rebuild(LiteLLM_ManagedVectorStoresTable)
model_rebuild(LiteLLM_GuardrailsTable)
model_rebuild(LiteLLM_PromptTable)
model_rebuild(LiteLLM_HealthCheckTable)
