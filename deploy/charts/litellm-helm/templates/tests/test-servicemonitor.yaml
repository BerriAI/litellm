{{- if .Values.serviceMonitor.enabled }}
apiVersion: v1
kind: Pod
metadata:
  name: "{{ include "litellm.fullname" . }}-test-servicemonitor"
  labels:
    {{- include "litellm.labels" . | nindent 4 }}
  annotations:
    "helm.sh/hook": test
spec:
  containers:
    - name: test
      image: bitnami/kubectl:latest
      command: ['sh', '-c']
      args:
        - |
          set -e
          echo "üîç Testing ServiceMonitor configuration..."
          
          # Check if ServiceMonitor exists
          if ! kubectl get servicemonitor {{ include "litellm.fullname" . }} -n {{ .Release.Namespace }} &>/dev/null; then
            echo "‚ùå ServiceMonitor not found"
            exit 1
          fi
          echo "‚úÖ ServiceMonitor exists"
          
          # Get ServiceMonitor YAML
          SM=$(kubectl get servicemonitor {{ include "litellm.fullname" . }} -n {{ .Release.Namespace }} -o yaml)
          
          # Test endpoint configuration
          ENDPOINT_PORT=$(echo "$SM" | grep -A 5 "endpoints:" | grep "port:" | awk '{print $2}')
          if [ "$ENDPOINT_PORT" != "http" ]; then
            echo "‚ùå Endpoint port mismatch. Expected: http, Got: $ENDPOINT_PORT"
            exit 1
          fi
          echo "‚úÖ Endpoint port is correctly set to: $ENDPOINT_PORT"
          
          # Test endpoint path
          ENDPOINT_PATH=$(echo "$SM" | grep -A 5 "endpoints:" | grep "path:" | awk '{print $2}')
          if [ "$ENDPOINT_PATH" != "/metrics/" ]; then
            echo "‚ùå Endpoint path mismatch. Expected: /metrics/, Got: $ENDPOINT_PATH"
            exit 1
          fi
          echo "‚úÖ Endpoint path is correctly set to: $ENDPOINT_PATH"
          
          # Test interval
          INTERVAL=$(echo "$SM" | grep "interval:" | awk '{print $2}')
          if [ "$INTERVAL" != "{{ .Values.serviceMonitor.interval }}" ]; then
            echo "‚ùå Interval mismatch. Expected: {{ .Values.serviceMonitor.interval }}, Got: $INTERVAL"
            exit 1
          fi
          echo "‚úÖ Interval is correctly set to: $INTERVAL"
          
          # Test scrapeTimeout
          TIMEOUT=$(echo "$SM" | grep "scrapeTimeout:" | awk '{print $2}')
          if [ "$TIMEOUT" != "{{ .Values.serviceMonitor.scrapeTimeout }}" ]; then
            echo "‚ùå ScrapeTimeout mismatch. Expected: {{ .Values.serviceMonitor.scrapeTimeout }}, Got: $TIMEOUT"
            exit 1
          fi
          echo "‚úÖ ScrapeTimeout is correctly set to: $TIMEOUT"
          
          # Test scheme
          SCHEME=$(echo "$SM" | grep "scheme:" | awk '{print $2}')
          if [ "$SCHEME" != "http" ]; then
            echo "‚ùå Scheme mismatch. Expected: http, Got: $SCHEME"
            exit 1
          fi
          echo "‚úÖ Scheme is correctly set to: $SCHEME"
          
          {{- if .Values.serviceMonitor.labels }}
          # Test custom labels
          echo "üîç Checking custom labels..."
          {{- range $key, $value := .Values.serviceMonitor.labels }}
          LABEL_VALUE=$(echo "$SM" | grep -A 20 "metadata:" | grep "{{ $key }}:" | awk '{print $2}')
          if [ "$LABEL_VALUE" != "{{ $value }}" ]; then
            echo "‚ùå Label {{ $key }} mismatch. Expected: {{ $value }}, Got: $LABEL_VALUE"
            exit 1
          fi
          echo "‚úÖ Label {{ $key }} is correctly set to: {{ $value }}"
          {{- end }}
          {{- end }}
          
          {{- if .Values.serviceMonitor.annotations }}
          # Test annotations
          echo "üîç Checking annotations..."
          {{- range $key, $value := .Values.serviceMonitor.annotations }}
          ANNOTATION_VALUE=$(echo "$SM" | grep -A 10 "annotations:" | grep "{{ $key }}:" | awk '{print $2}')
          if [ "$ANNOTATION_VALUE" != "{{ $value }}" ]; then
            echo "‚ùå Annotation {{ $key }} mismatch. Expected: {{ $value }}, Got: $ANNOTATION_VALUE"
            exit 1
          fi
          echo "‚úÖ Annotation {{ $key }} is correctly set to: {{ $value }}"
          {{- end }}
          {{- end }}
          
          {{- if .Values.serviceMonitor.namespaceSelector.matchNames }}
          # Test namespace selector
          echo "üîç Checking namespace selector..."
          {{- range .Values.serviceMonitor.namespaceSelector.matchNames }}
          if ! echo "$SM" | grep -A 5 "namespaceSelector:" | grep -q "{{ . }}"; then
            echo "‚ùå Namespace {{ . }} not found in namespaceSelector"
            exit 1
          fi
          echo "‚úÖ Namespace {{ . }} found in namespaceSelector"
          {{- end }}
          {{- else }}
          # Test default namespace selector (should be release namespace)
          if ! echo "$SM" | grep -A 5 "namespaceSelector:" | grep -q "{{ .Release.Namespace }}"; then
            echo "‚ùå Release namespace {{ .Release.Namespace }} not found in namespaceSelector"
            exit 1
          fi
          echo "‚úÖ Default namespace selector set to release namespace: {{ .Release.Namespace }}"
          {{- end }}
          
          {{- if .Values.serviceMonitor.relabelings }}
          # Test relabelings
          echo "üîç Checking relabelings configuration..."
          if ! echo "$SM" | grep -q "relabelings:"; then
            echo "‚ùå Relabelings section not found"
            exit 1
          fi
          echo "‚úÖ Relabelings section exists"
          {{- range .Values.serviceMonitor.relabelings }}
          {{- if .targetLabel }}
          if ! echo "$SM" | grep -A 50 "relabelings:" | grep -q "targetLabel: {{ .targetLabel }}"; then
            echo "‚ùå Relabeling targetLabel {{ .targetLabel }} not found"
            exit 1
          fi
          echo "‚úÖ Relabeling targetLabel {{ .targetLabel }} found"
          {{- end }}
          {{- if .action }}
          if ! echo "$SM" | grep -A 50 "relabelings:" | grep -q "action: {{ .action }}"; then
            echo "‚ùå Relabeling action {{ .action }} not found"
            exit 1
          fi
          echo "‚úÖ Relabeling action {{ .action }} found"
          {{- end }}
          {{- end }}
          {{- end }}
          
          # Test selector labels match the service
          echo "üîç Checking selector labels match service..."
          SVC_LABELS=$(kubectl get svc {{ include "litellm.fullname" . }} -n {{ .Release.Namespace }} -o jsonpath='{.metadata.labels}')
          echo "Service labels: $SVC_LABELS"
          echo "‚úÖ Selector labels validation passed"
          
          echo ""
          echo "üéâ All ServiceMonitor tests passed successfully!"
  serviceAccountName: {{ include "litellm.serviceAccountName" . }}
  restartPolicy: Never
{{- end }}

