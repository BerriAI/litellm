import jwt
import unittest
from unittest.mock import MagicMock, patch

# Mocking master_key for testing
MOCK_MASTER_KEY = "sk-1234567890"

def mock_jwt_decode_logic(token, master_key):
    """
    This simulates the refined logic implemented in ui_sso.py
    """
    try:
        header = jwt.get_unverified_header(token)
        if header.get("alg") == "HS256":
            # Internal LiteLLM tokens MUST be verified with master_key
            payload = jwt.decode(
                token,
                key=master_key,
                algorithms=["HS256"],
            )
        else:
            # Fallback to unverified decode for OIDC tokens
            payload = jwt.decode(
                token, options={"verify_signature": False}
            )
        return payload
    except jwt.InvalidSignatureError:
        # Authentication failed for internal token - DO NOT FALLBACK
        raise Exception("Invalid JWT signature for internal token")
    except Exception as e:
        # Final fallback to unverified decode for other types of errors (e.g. malformed JWT)
        return jwt.decode(token, options={"verify_signature": False})

class TestJWTSignatureBypass(unittest.TestCase):
    def test_valid_token(self):
        # 1. Generate a valid HS256 JWT
        payload = {"user_role": "proxy_admin", "user_id": "admin"}
        token = jwt.encode(payload, MOCK_MASTER_KEY, algorithm="HS256")
        
        # 2. Verify it's accepted with signature verification
        decoded = mock_jwt_decode_logic(token, MOCK_MASTER_KEY)
        self.assertEqual(decoded["user_role"], "proxy_admin")

    def test_forged_token_wrong_key(self):
        # 1. Generate a forged JWT with wrong key
        payload = {"user_role": "proxy_admin", "user_id": "admin"}
        token = jwt.encode(payload, "wrong-key", algorithm="HS256")
        
        # 2. Verify it's REJECTED (raises exception)
        with self.assertRaises(Exception) as cm:
            mock_jwt_decode_logic(token, MOCK_MASTER_KEY)
        self.assertIn("Invalid JWT signature for internal token", str(cm.exception))

    def test_oidc_fallback(self):
        # 1. Generate a non-HS256 token (simulating OIDC)
        # Using a dummy RSA-like alg or just anything not HS256
        payload = {"user_role": "user", "user_id": "oidc-user"}
        # Note: PyJWT might complain if we don't have real keys for RS256, 
        # so we'll just use a token that has a different alg in header
        # but is encoded with something we can decode unverified.
        token = jwt.encode(payload, "dummy", algorithm="HS256")
        # Manually swap header to something else
        parts = token.split(".")
        import base64
        import json
        header = json.loads(base64.b64decode(parts[0] + "==").decode())
        header["alg"] = "RS256"
        parts[0] = base64.b64encode(json.dumps(header).encode()).decode().strip("=")
        token = ".".join(parts)

        # 2. Verify it falls back to unverified decode
        decoded = mock_jwt_decode_logic(token, MOCK_MASTER_KEY)
        self.assertEqual(decoded["user_id"], "oidc-user")

if __name__ == "__main__":
    unittest.main()
