name: CARTO - Slack Changelog

################################################################################
# Event-Driven Slack Changelog
################################################################################
#
# Posts changelog updates to Slack when PRs are merged to carto/main.
# Also supports manual trigger for repo status post.
#
# Modes:
# - pr_merge: Analyzes merged PR and posts AI-generated summary
# - repo_status: Posts current fork status (manual trigger)
#
# Security:
# - Read-only tools for Claude (no file modifications)
# - Rate limited: max-turns 20, 10-min timeout
# - Uses existing SLACK_KEY and ANTHROPIC_API_KEY secrets

on:
  # Trigger on PR merge to carto/main (claude-code-action supports pull_request)
  push:
    branches: [carto/main]
  pull_request:
    types: [closed]
    branches: [carto/main]
  workflow_dispatch:
    inputs:
      mode:
        description: 'What to post'
        type: choice
        options:
          - repo_status
          - last_commits
        default: 'repo_status'

jobs:
  post-changelog:
    runs-on: ubuntu-latest
    # Only run if PR was merged (not just closed) OR if manually triggered
    if: github.event.pull_request.merged == true || github.event_name == 'workflow_dispatch'
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Determine mode and gather data
        id: context
        env:
          MANUAL_MODE: ${{ inputs.mode }}
          PR_NUMBER: ${{ github.event.pull_request.number }}
          PR_TITLE: ${{ github.event.pull_request.title }}
          PR_AUTHOR: ${{ github.event.pull_request.user.login }}
          PR_URL: ${{ github.event.pull_request.html_url }}
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -eu
          echo "::group::Determining context"

          # Get current versions
          UPSTREAM_VERSION=$(grep -E "^version\s*=" pyproject.toml | head -1 | sed -E 's/.*"([^"]+)".*/\1/')
          LATEST_TAG=$(git tag -l "v*-carto.*" | sort -V | tail -n 1 || echo "none")
          echo "upstream_version=${UPSTREAM_VERSION}" >> $GITHUB_OUTPUT
          echo "latest_tag=${LATEST_TAG}" >> $GITHUB_OUTPUT

          if [[ "${{ github.event_name }}" == "pull_request" ]]; then
            echo "mode=pr_merge" >> $GITHUB_OUTPUT
            echo "pr_number=${PR_NUMBER}" >> $GITHUB_OUTPUT
            echo "pr_title=${PR_TITLE}" >> $GITHUB_OUTPUT
            echo "pr_author=${PR_AUTHOR}" >> $GITHUB_OUTPUT
            echo "pr_url=${PR_URL}" >> $GITHUB_OUTPUT

            echo "Mode: PR Merge (#${PR_NUMBER})"
            echo "PR Title: ${PR_TITLE}"
            echo "PR Author: ${PR_AUTHOR}"

            # Get full PR details for Claude
            echo "::group::PR details (gh pr view)"
            gh pr view "$PR_NUMBER" --json number,title,body,author,files,labels,mergedAt \
              > /tmp/pr_details.json 2>/dev/null || echo "{}" > /tmp/pr_details.json

            # Extract individual fields for easy reading
            gh pr view "$PR_NUMBER" --json title --jq '.title' > /tmp/pr_title.txt 2>/dev/null || echo "${PR_TITLE}" > /tmp/pr_title.txt
            gh pr view "$PR_NUMBER" --json body --jq '.body // ""' > /tmp/pr_body.txt 2>/dev/null || echo "" > /tmp/pr_body.txt
            gh pr view "$PR_NUMBER" --json files --jq '.files[].path' > /tmp/pr_files.txt 2>/dev/null || echo "" > /tmp/pr_files.txt
            gh pr view "$PR_NUMBER" --json author --jq '.author.login' > /tmp/pr_author.txt 2>/dev/null || echo "${PR_AUTHOR}" > /tmp/pr_author.txt
            gh pr view "$PR_NUMBER" --json labels --jq '.labels[].name' > /tmp/pr_labels.txt 2>/dev/null || echo "" > /tmp/pr_labels.txt

            echo "Files changed: $(wc -l < /tmp/pr_files.txt | tr -d ' ')"
            echo "::endgroup::"

          else
            echo "mode=${MANUAL_MODE}" >> $GITHUB_OUTPUT
            echo "Mode: Manual (${MANUAL_MODE})"

            # For repo_status: get recent CARTO commits
            echo "::group::Recent CARTO commits"
            CARTO_COMMITS=$(git log HEAD \
              --author="@carto.com" --author="@cartodb.com" \
              --oneline --no-merges -20 2>/dev/null | \
              grep -vE "(sync:|Merge|merge upstream)" || echo "No CARTO commits found")
            echo "${CARTO_COMMITS}"
            echo "::endgroup::"

            # Get recent merged PRs
            echo "::group::Recent merged PRs"
            RECENT_PRS=$(gh pr list --state merged --base carto/main --limit 10 \
              --json number,title,author,mergedAt \
              --jq '.[] | "• #\(.number): \(.title) (@\(.author.login), \(.mergedAt | split("T")[0]))"' 2>/dev/null || echo "")
            echo "${RECENT_PRS}"
            echo "::endgroup::"

            # Get releases
            echo "::group::Recent releases"
            RELEASES=$(gh release list --limit 5 2>/dev/null || echo "No releases yet")
            echo "${RELEASES}"
            echo "::endgroup::"

            # Save to files for Claude to read
            echo "${CARTO_COMMITS}" > /tmp/carto_commits.txt
            echo "${RECENT_PRS}" > /tmp/recent_prs.txt
            echo "${RELEASES}" > /tmp/releases.txt
          fi

          echo "::endgroup::"

      - name: Generate changelog with Claude
        id: changelog
        uses: anthropics/claude-code-action@v1
        with:
          anthropic_api_key: ${{ secrets.ANTHROPIC_API_KEY }}
          github_token: ${{ secrets.GITHUB_TOKEN }}
          show_full_output: false
          claude_args: "--model claude-haiku-4-5-20251101 --max-turns 20 --allowed-tools Read,Write,Bash,Grep,Glob"
          prompt: |
            # Slack Changelog Generation

            ## Mode: ${{ steps.context.outputs.mode }}

            ## Context
            - **Repository:** CartoDB/litellm (fork of BerriAI/litellm)
            - **Upstream Version:** ${{ steps.context.outputs.upstream_version }}
            - **Latest CARTO Tag:** ${{ steps.context.outputs.latest_tag }}
            - **Output file:** Create `slack_message.txt`

            ## Data Files (already gathered)
            The workflow has already gathered the data into files. Read them based on mode:

            **For PR merges (mode=pr_merge):**
            - `/tmp/pr_details.json` - Full PR details as JSON
            - `/tmp/pr_title.txt` - PR title
            - `/tmp/pr_body.txt` - PR description/body (rich context!)
            - `/tmp/pr_files.txt` - Files changed (one per line)
            - `/tmp/pr_author.txt` - PR author username
            - `/tmp/pr_labels.txt` - PR labels (if any)

            **Repo status mode files (mode=repo_status):**
            - `/tmp/carto_commits.txt` - Recent CARTO-authored commits
            - `/tmp/recent_prs.txt` - Recent merged PRs
            - `/tmp/releases.txt` - Recent releases

            ---

            ## IF MODE IS "pr_merge":

            **PR Number:** ${{ steps.context.outputs.pr_number }}
            **PR Title:** ${{ steps.context.outputs.pr_title }}
            **PR Author:** ${{ steps.context.outputs.pr_author }}
            **PR URL:** ${{ steps.context.outputs.pr_url }}

            ### Task:
            1. Read: `/tmp/pr_title.txt`, `/tmp/pr_body.txt`, `/tmp/pr_files.txt`, `/tmp/pr_author.txt`
            2. Use PR body to understand what the PR does (it has the best context!)
            3. Determine type from PR title:
               - **Upstream Sync**: "sync:", "upstream", merge from upstream
               - **Feature**: "feat:", "feature:"
               - **Bug Fix**: "fix:", "bugfix:"
               - **Infrastructure**: Changes to .github/, docker/, CI/CD
               - **Chore**: Other

            4. Write to `slack_message.txt`:
               ```
               :clipboard: *LiteLLM Fork Update*

               *PR #${{ steps.context.outputs.pr_number }}:* [PR title from /tmp/pr_title.txt]

               *Type:* [type]
               *Author:* @[author from /tmp/pr_author.txt]

               *Summary:*
               [1-2 sentence summary based on PR body - extract the key purpose]

               *Key Changes:*
               • [Most important files from /tmp/pr_files.txt, max 5]

               :link: <${{ steps.context.outputs.pr_url }}|View PR>
               ```

            ---

            ## IF MODE IS "repo_status":

            ### Task:
            1. Read the data files: `/tmp/carto_commits.txt`, `/tmp/recent_prs.txt`, `/tmp/releases.txt`

            2. Write to `slack_message.txt`:
               ```
               :bar_chart: *LiteLLM Fork Status*

               *Current Versions:*
               • Upstream Base: LiteLLM v${{ steps.context.outputs.upstream_version }}
               • Latest CARTO Release: ${{ steps.context.outputs.latest_tag }}

               *What is this fork?*
               CARTO's fork of LiteLLM - the unified LLM proxy for 100+ providers used for all AI features.

               *Recent CARTO Commits:*
               [from /tmp/carto_commits.txt - list top 10]

               *Recent PRs:*
               [from /tmp/recent_prs.txt]

               *Recent Releases:*
               [from /tmp/releases.txt]

               :link: Links:
               • <https://github.com/CartoDB/litellm|Repository>
               • <https://github.com/CartoDB/litellm/releases|Releases>
               • <https://github.com/BerriAI/litellm|Upstream LiteLLM>
               ```

            ---

            ## Guidelines:
            - Keep messages concise - Slack has character limits
            - Use Slack mrkdwn: *bold*, <url|text> for links
            - Use • for bullets (not -)
            - Emoji codes: :clipboard: :bar_chart: :link: :rocket:
            - No markdown code blocks

            Read the files and write `slack_message.txt` now.
        timeout-minutes: 10
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Verify message was created
        id: verify
        run: |
          if [ -f "slack_message.txt" ]; then
            echo "✅ Message generated successfully"
            echo "message_exists=true" >> $GITHUB_OUTPUT
            echo "--- Message content ---"
            cat slack_message.txt
            echo "--- End message ---"
          else
            echo "❌ Message file not found"
            echo "message_exists=false" >> $GITHUB_OUTPUT
            exit 1
          fi

      - name: Post to Slack
        if: steps.verify.outputs.message_exists == 'true'
        env:
          SLACK_CHANNEL: "C0A11FKJHDK"  # #litellm-changelog
        run: |
          set -eu

          echo "::group::Preparing Slack notification"

          # Check if SLACK_KEY secret is configured
          if [[ -z "${{ secrets.SLACK_KEY }}" ]]; then
            echo "::warning::SLACK_KEY secret not configured - skipping notification"
            exit 0
          fi

          # Read message content
          MESSAGE=$(cat slack_message.txt)

          echo "[Slack] Sending to channel ${SLACK_CHANNEL}"
          echo "::endgroup::"

          echo "::group::Posting to Slack"

          # Retry logic (up to 3 attempts)
          SUCCESS=false
          for attempt in 1 2 3; do
            echo "[Slack] Attempt ${attempt}/3..."

            # Send to Slack API
            RESPONSE=$(curl -s -w "\n%{http_code}" \
              -F "text=${MESSAGE}" \
              -F "channel=${SLACK_CHANNEL}" \
              -H "Authorization: Bearer ${{ secrets.SLACK_KEY }}" \
              -X POST https://slack.com/api/chat.postMessage)

            # Extract HTTP code and body
            HTTP_CODE=$(echo "$RESPONSE" | tail -n1)
            BODY=$(echo "$RESPONSE" | head -n-1)

            echo "[Slack] HTTP ${HTTP_CODE}"

            # Check if successful
            if [ "$HTTP_CODE" = "200" ]; then
              if echo "$BODY" | grep -q '"ok":true'; then
                echo "✅ [Slack] Message posted successfully"
                SUCCESS=true
                break
              else
                ERROR=$(echo "$BODY" | grep -o '"error":"[^"]*"' || echo "unknown error")
                echo "⚠️ [Slack] Slack API error: ${ERROR}"
              fi
            else
              echo "⚠️ [Slack] HTTP error: ${HTTP_CODE}"
            fi

            # Wait before retry
            if [ $attempt -lt 3 ]; then
              echo "[Slack] Retrying in 5 seconds..."
              sleep 5
            fi
          done

          if [ "$SUCCESS" = "false" ]; then
            echo "::error::Failed to send Slack notification after 3 attempts"
            echo "::notice::Check SLACK_KEY secret and channel permissions"
            exit 1
          fi

          echo "::endgroup::"

      - name: Summary
        if: always()
        run: |
          echo "## Slack Changelog Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Mode:** ${{ steps.context.outputs.mode }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          if [ -f "slack_message.txt" ]; then
            echo "### Message Posted" >> $GITHUB_STEP_SUMMARY
            echo '```' >> $GITHUB_STEP_SUMMARY
            cat slack_message.txt >> $GITHUB_STEP_SUMMARY
            echo '```' >> $GITHUB_STEP_SUMMARY
          else
            echo "❌ Message generation failed" >> $GITHUB_STEP_SUMMARY
          fi
