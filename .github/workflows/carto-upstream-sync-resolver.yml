name: CARTO Upstream Sync - Conflict Resolver

# This workflow uses Claude Code to automatically create conflict resolution proposals
# for upstream sync PRs that have merge conflicts.
#
# Security features:
# - Only runs when triggered by authorized users (Cartofante, mateo-di)
# - Only runs on PRs labeled 'upstream-sync'
# - Only runs on main branch (upstream sync PRs)
# - Only runs when conflicts are detected
# - Blocks external forks
# - Rate limited (max-turns: 250, job timeout: 90 mins)

on:
  pull_request:
    types: [opened, labeled, synchronize]
    branches:
      - carto/main
  workflow_dispatch:
    inputs:
      pr-number:
        description: "PR number to resolve conflicts for"
        required: true
        default: ""
      debug:
        description: "Enable debug logging"
        type: boolean
        default: false

# Prevent duplicate runs on the same PR
concurrency:
  group: upstream-sync-resolver-${{ github.event.pull_request.number || github.run_id }}
  cancel-in-progress: false

permissions:
  contents: write      
  pull-requests: write

jobs:
  # Job 1: Security verification - MUST PASS before any other checks
  security-check:
    name: Security Verification
    runs-on: ubuntu-latest

    outputs:
      authorized: ${{ steps.verify.outputs.authorized }}

    steps:
      - name: Verify actor and PR source
        id: verify
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          set -eu

          echo "::group::Security verification"

          # Security Check 1: Only allow specific authorized users
          ACTOR="${{ github.actor }}"
          ALLOWED_ACTORS="Cartofante mateo-di"

          # Check if actor is in allowed list (case-insensitive)
          ACTOR_LOWER="${ACTOR,,}"
          ALLOWED=false
          for allowed in ${ALLOWED_ACTORS}; do
            if [[ "${ACTOR_LOWER}" == "${allowed,,}" ]]; then
              ALLOWED=true
              break
            fi
          done

          if [[ "${ALLOWED}" == "false" ]]; then
            echo "[Security] ‚ùå Unauthorized actor: ${ACTOR}"
            echo "[Security] Allowed actors: ${ALLOWED_ACTORS}"
            echo "authorized=false" >> $GITHUB_OUTPUT
            exit 0
          fi
          echo "[Security] ‚úÖ Actor verified: ${ACTOR}"

          # Security Check 2: Verify branch flow (main ‚Üí carto/main)
          if [[ "${{ github.event_name }}" == "pull_request" ]]; then
            # Automatic trigger: validate PR directly from event
            HEAD_BRANCH="${{ github.event.pull_request.head.ref }}"
            BASE_BRANCH="${{ github.event.pull_request.base.ref }}"
            HEAD_REPO="${{ github.event.pull_request.head.repo.full_name }}"
            BASE_REPO="${{ github.repository }}"

            # Check fork - head repo must match base repo
            if [[ "${HEAD_REPO}" != "${BASE_REPO}" ]]; then
              echo "[Security] ‚ùå External fork detected: ${HEAD_REPO}"
              echo "[Security] Only internal branches allowed"
              echo "authorized=false" >> $GITHUB_OUTPUT
              exit 0
            fi
            echo "[Security] ‚úÖ PR source verified: internal branch"

            # Check branch flow
            if [[ "${HEAD_BRANCH}" != "main" ]] || [[ "${BASE_BRANCH}" != "carto/main" ]]; then
              echo "[Security] ‚ùå Invalid branch flow: ${HEAD_BRANCH} ‚Üí ${BASE_BRANCH}"
              echo "[Security] Required: main ‚Üí carto/main"
              echo "authorized=false" >> $GITHUB_OUTPUT
              exit 0
            fi
            echo "[Security] ‚úÖ Branch flow verified: main ‚Üí carto/main"
          else
            # Manual trigger: fetch PR details via gh CLI
            PR_NUMBER="${{ github.event.inputs.pr-number }}"
            if [[ -z "${PR_NUMBER}" ]]; then
              echo "[Security] ‚ùå PR number required for manual dispatch"
              echo "authorized=false" >> $GITHUB_OUTPUT
              exit 0
            fi

            echo "[Security] Manual dispatch for PR #${PR_NUMBER}"

            # Fetch PR details
            PR_JSON=$(gh pr view ${PR_NUMBER} --repo ${{ github.repository }} --json headRefName,baseRefName,headRepositoryOwner,isCrossRepository)
            HEAD_BRANCH=$(echo "${PR_JSON}" | jq -r '.headRefName')
            BASE_BRANCH=$(echo "${PR_JSON}" | jq -r '.baseRefName')
            IS_FORK=$(echo "${PR_JSON}" | jq -r '.isCrossRepository')

            # Check fork - isCrossRepository is true for external forks
            if [[ "${IS_FORK}" == "true" ]]; then
              REPO_OWNER=$(echo "${PR_JSON}" | jq -r '.headRepositoryOwner.login')
              echo "[Security] ‚ùå External fork detected from: ${REPO_OWNER}"
              echo "[Security] Only internal branches allowed"
              echo "authorized=false" >> $GITHUB_OUTPUT
              exit 0
            fi
            echo "[Security] ‚úÖ PR source verified: internal branch"

            # Check branch flow
            if [[ "${HEAD_BRANCH}" != "main" ]] || [[ "${BASE_BRANCH}" != "carto/main" ]]; then
              echo "[Security] ‚ùå Invalid branch flow: ${HEAD_BRANCH} ‚Üí ${BASE_BRANCH}"
              echo "[Security] Required: main ‚Üí carto/main"
              echo "authorized=false" >> $GITHUB_OUTPUT
              exit 0
            fi
            echo "[Security] ‚úÖ Branch flow verified: main ‚Üí carto/main"
          fi

          # All security checks passed
          echo "[Security] ‚úÖ All security checks passed"
          echo "authorized=true" >> $GITHUB_OUTPUT
          echo "::endgroup::"

  # Job 2: Check if this PR is eligible for automated conflict resolution
  check-eligibility:
    name: Check PR Eligibility
    runs-on: ubuntu-latest
    needs: security-check
    if: needs.security-check.outputs.authorized == 'true'

    outputs:
      eligible: ${{ steps.check.outputs.eligible }}
      pr-number: ${{ steps.check.outputs.pr-number }}
      has-conflicts: ${{ steps.check.outputs.has-conflicts }}
      is-sync-pr: ${{ steps.check.outputs.is-sync-pr }}

    steps:
      - name: Check PR criteria
        id: check
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          set -eu

          # Get PR number based on trigger type
          if [[ "${{ github.event_name }}" == "pull_request" ]]; then
            PR_NUMBER="${{ github.event.pull_request.number }}"
          else
            PR_NUMBER="${{ github.event.inputs.pr-number }}"
          fi

          echo "::group::Checking PR eligibility for conflict resolution"
          echo "[Resolver] Checking PR #${PR_NUMBER}"

          # Get PR details
          PR_JSON=$(gh pr view ${PR_NUMBER} --repo ${{ github.repository }} --json labels,mergeable,headRefName,baseRefName)

          # Extract details
          echo "${PR_JSON}"
          BASE_BRANCH=$(echo "${PR_JSON}" | jq -r '.baseRefName')
          echo "BASE_BRANCH: ${BASE_BRANCH}"
          HEAD_BRANCH=$(echo "${PR_JSON}" | jq -r '.headRefName')
          echo "HEAD_BRANCH: ${HEAD_BRANCH}"
          MERGEABLE=$(echo "${PR_JSON}" | jq -r '.mergeable')
          echo "MERGEABLE: ${MERGEABLE}"
          LABELS=$(echo "${PR_JSON}" | jq -r '.labels[].name' | tr '\n' ' ')
          echo "LABELS: ${LABELS}"

          echo "[Resolver] Base: ${BASE_BRANCH}, Head: ${HEAD_BRANCH}"
          echo "[Resolver] Mergeable status: ${MERGEABLE}"
          echo "[Resolver] Labels: ${LABELS}"

          # Check 1: Must be to carto/main
          if [[ "${BASE_BRANCH}" != "carto/main" ]]; then
            echo "[Resolver] ‚ùå Not targeting carto/main - skipping"
            echo "eligible=false" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Check 2: Must have upstream-sync label
          if [[ ! "${LABELS}" =~ "upstream-sync" ]]; then
            echo "[Resolver] ‚ùå Missing 'upstream-sync' label - skipping"
            echo "is-sync-pr=false" >> $GITHUB_OUTPUT
            echo "eligible=false" >> $GITHUB_OUTPUT
            exit 0
          fi
          echo "is-sync-pr=true" >> $GITHUB_OUTPUT

          # Check 3: Must have conflicts (or manual trigger)
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            # Manual trigger: skip conflict check (user knows there are conflicts)
            echo "[Resolver] ‚ö†Ô∏è Manual trigger - skipping conflict check (status: ${MERGEABLE})"
            echo "[Resolver] Assuming conflicts exist (user manually triggered)"
            echo "has-conflicts=true" >> $GITHUB_OUTPUT
          elif [[ "${MERGEABLE}" == "CONFLICTING" ]]; then
            # Automatic trigger: conflicts detected
            echo "[Resolver] ‚ö†Ô∏è Conflicts detected (mergeable: ${MERGEABLE})"
            echo "has-conflicts=true" >> $GITHUB_OUTPUT
          elif [[ "${MERGEABLE}" == "UNKNOWN" ]]; then
            # Status not computed yet - treat as potential conflict
            echo "[Resolver] ‚ö†Ô∏è Mergeable status unknown - will attempt resolution"
            echo "has-conflicts=true" >> $GITHUB_OUTPUT
          else
            # Clean merge - no action needed
            echo "[Resolver] ‚úÖ No conflicts detected (mergeable: ${MERGEABLE})"
            echo "has-conflicts=false" >> $GITHUB_OUTPUT
            echo "eligible=false" >> $GITHUB_OUTPUT
            exit 0
          fi

          # All checks passed
          echo "[Resolver] ‚úÖ PR is eligible for conflict resolution"
          echo "eligible=true" >> $GITHUB_OUTPUT
          echo "pr-number=${PR_NUMBER}" >> $GITHUB_OUTPUT
          echo "::endgroup::"

  # Job 3: Use Claude Code to resolve conflicts
  claude-resolve:
    name: Claude Code Conflict Resolution
    runs-on: ubuntu-latest
    timeout-minutes: 90  # Job timeout is the real limit (not max-turns)
    needs: [security-check, check-eligibility]
    if: needs.security-check.outputs.authorized == 'true' && needs.check-eligibility.outputs.eligible == 'true'

    steps:
      - name: Get PR head branch
        id: pr-info
        env:
          GH_TOKEN: ${{ secrets.X_GITHUB_SUPERCARTOFANTE }}
        run: |
          # Get head ref based on trigger type
          if [[ "${{ github.event_name }}" == "pull_request" ]]; then
            HEAD_REF="${{ github.event.pull_request.head.ref }}"
          else
            # For workflow_dispatch, fetch from PR
            PR_NUMBER="${{ needs.check-eligibility.outputs.pr-number }}"
            HEAD_REF=$(gh pr view ${PR_NUMBER} --repo ${{ github.repository }} --json headRefName --jq '.headRefName')
          fi

          echo "head-ref=${HEAD_REF}" >> $GITHUB_OUTPUT
          echo "[Resolver] Will checkout branch: ${HEAD_REF}"

      - name: Checkout repository (base branch - target of PR)
        uses: actions/checkout@v4
        with:
          ref: ${{ steps.pr-info.outputs.base-ref }}
          fetch-depth: 0
          token: ${{ secrets.X_GITHUB_SUPERCARTOFANTE }}

      - name: Configure git
        run: |
          git config --global user.name "Cartofante"
          git config --global user.email "cartofante@carto.com"

      - name: Attempt merge to create conflicts
        run: |
          echo "::group::Attempting merge of ${{ steps.pr-info.outputs.head-ref }} into ${{ steps.pr-info.outputs.base-ref }}"

          # Fetch the head branch
          git fetch origin ${{ steps.pr-info.outputs.head-ref }}:${{ steps.pr-info.outputs.head-ref }}

          # Attempt merge (will fail if conflicts exist)
          if git merge ${{ steps.pr-info.outputs.head-ref }} --no-commit --no-ff; then
            echo "[Resolver] ‚úÖ Clean merge - no conflicts found"
            echo "[Resolver] This PR should be mergeable without Claude's help"
            git merge --abort || true
            exit 1
          else
            echo "[Resolver] ‚ö†Ô∏è Conflicts detected - Claude will resolve them"
            echo "[Resolver] Conflicted files:"
            git diff --name-only --diff-filter=U
          fi

          echo "::endgroup::"

      - name: Comment on original PR - Starting
        env:
          GH_TOKEN: ${{ secrets.X_GITHUB_SUPERCARTOFANTE }}
        run: |
          gh pr comment ${{ needs.check-eligibility.outputs.pr-number }} \
            --repo ${{ github.repository }} \
            --body "$(cat <<'EOF'
          ## ü§ñ Automated Conflict Resolution Started

          Claude Code is now resolving conflicts for this PR.

          **Process:**
          1. üîç Analyzing conflicts in all files
          2. üìã Reading CARTO customization guidelines
          3. ‚öñÔ∏è Applying resolution priorities (CARTO first, then upstream)
          4. ‚úèÔ∏è Resolving conflicts file by file
          5. üß™ Running tests (lint, mypy, unit tests)
          6. üîÄ Creating resolution PR

          **Status:** In progress...

          _This process may take 30-90 minutes for large PRs._

          [View workflow run ‚Üí](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})
          EOF
          )"

      - name: Run Claude Code for conflict resolution
        id: claude-run
        uses: anthropics/claude-code-action@v1
        with:
          github_token: ${{ secrets.X_GITHUB_SUPERCARTOFANTE }}
          anthropic_api_key: ${{ secrets.ANTHROPIC_API_KEY }}
          show_full_output: true
          claude_args: "--model claude-sonnet-4-5-20250929 --max-turns 250 --allowed-tools Read,Write,Edit,Bash,Grep,Glob ${{ github.event.inputs.debug == 'true' && '--debug' || '' }}"
          prompt: |
            # Upstream Sync Conflict Resolution Task

            ## üìö IMPORTANT: Read Project Guidelines First
            Before starting, read `CARTO_CLAUDE.md` to understand CARTO-specific conventions,
            coding standards, and infrastructure patterns. This file contains essential context
            about how CARTO customizes LiteLLM.

            ## Branch Strategy & Your Context

            ```
            upstream/main          ‚Üí BerriAI's development branch (may be unstable)
                    ‚Üì
                  main             ‚Üí Mirrors upstream/main (pure upstream copy)
                    ‚Üì (merge with conflicts)
                carto/main         ‚Üí Production branch (stable + CARTO mods) < YOU ARE HERE
                    ‚Üì
                feature/*          ‚Üí Development branches
            ```

            **What happened:**
            1. `main` branch was synced from upstream BerriAI/litellm
            2. PR #${{ needs.check-eligibility.outputs.pr-number }} was created: `main ‚Üí carto/main`
            3. Merge attempt failed due to conflicts (CARTO customizations vs upstream changes)
            4. You are now on `carto/main` branch with `main` already merged (in conflicted state)

            **Your task:** Resolve the conflicts and create a resolution PR back to `carto/main`

            ## Context
            - **Current branch**: `carto/main` (with conflicted merge from `main`)
            - **Project Guidelines**: See CARTO_CLAUDE.md for detailed conventions
            - **Original PR**: #${{ needs.check-eligibility.outputs.pr-number }} (main ‚Üí carto/main)
            - **Your mission**: Resolve conflicts, create PR: `upstream-sync-resolver/{{ needs.check-eligibility.outputs.pr-number }} ‚Üí carto/main`

            ## ‚ö†Ô∏è CRITICAL: Resolution Priorities (In Order)

            When resolving conflicts, follow this strict priority order:

            ### Priority 1: üè¢ CARTO Customizations (HIGHEST PRIORITY)
            **ALWAYS preserve CARTO customizations from carto/main**
            - Any code marked with `# CARTO:` comments ‚Üí KEEP CARTO version
            - CARTO-specific workflows, configs, documentation ‚Üí KEEP CARTO version
            - CARTO infrastructure code (Docker, DB scripts) ‚Üí KEEP CARTO customizations
            - When in doubt between CARTO vs upstream customization ‚Üí KEEP CARTO

            ### Priority 2: üîß LiteLLM Core Functionalities
            **Accept upstream improvements to core library**
            - Bug fixes in `litellm/` core ‚Üí ACCEPT upstream
            - New LLM provider support ‚Üí ACCEPT upstream
            - API improvements and new features ‚Üí ACCEPT upstream
            - Performance optimizations ‚Üí ACCEPT upstream

            ### Priority 3: ‚öñÔ∏è Conflict Resolution Strategy
            **When both CARTO and upstream modified the same functionality:**
            1. If CARTO modified for infrastructure/deployment ‚Üí KEEP CARTO
            2. If upstream improved core LiteLLM functionality ‚Üí ACCEPT upstream
            3. If both are substantive changes ‚Üí MANUALLY MERGE both (combine carefully)
            4. Document your reasoning in commit message

            ## Your Task

            ### Step 1: Verify Current State & Read Guidelines
            ```bash
            # FIRST: Read CARTO project guidelines
            cat CARTO_CLAUDE.md

            # Verify you're on carto/main with conflicted merge
            git status
            # Should show: "You have unmerged paths" or similar

            # List all conflicted files
            git diff --name-only --diff-filter=U

            # Review a sample conflict (optional)
            # git diff <conflicted-file>
            ```

            ### Step 2: Understand File-Specific Rules

            **‚úÖ ALWAYS KEEP CARTO VERSION (ours):**
            - `.github/workflows/carto_*.yaml` - CARTO workflows
            - `.github/workflows/carto-*.yml` - CARTO workflows
            - `CARTO_*.md` - CARTO documentation
            - `docs/CARTO_*.md` - CARTO documentation
            - Any file with CARTO-specific infrastructure code

            **üîÑ ALWAYS ACCEPT UPSTREAM (theirs):**
            - `pyproject.toml` - Version field (use upstream version)
            - `litellm/llms/**` - LLM provider implementations
            - `litellm/main.py` - Core completion functions
            - `litellm/router.py` - Router logic
            - `tests/` - Upstream test files (unless CARTO added custom tests)
            - `requirements.txt` - Dependencies (unless CARTO added specific versions)

            **‚ö†Ô∏è CAREFULLY MERGE BOTH (manual resolution):**
            - `Dockerfile` - Look for `# CARTO:` comments
              - Keep CARTO sections marked with comments
              - Accept upstream improvements to base image/dependencies
            - `docker/Dockerfile.non_root` - CARTO customizations
              - Preserve CARTO user/permissions setup
              - Accept upstream dependencies/entrypoint improvements
              - `db_scripts/` - May have CARTO custom scripts
              - Keep CARTO scripts
              - Accept upstream schema improvements

            ### Step 2: Create Resolution Branch (from conflicted state)
            ```bash
            # Create branch from current conflicted state
            git checkout -b upstream-sync-resolver/${{ needs.check-eligibility.outputs.pr-number }}
            ```

            ### Step 3: Resolve Each Conflict

            For each conflicted file:

            1. **Open the file and locate conflict markers:**
               ```
               <<<<<<< HEAD (current: carto/main with CARTO customizations)
               [CARTO version - this is what's currently in carto/main]
               =======
               [upstream version - this is what's coming from main branch]
               >>>>>>> main (or commit hash - upstream changes)
               ```

            2. **Apply the priority rules above**
               - Keep CARTO infrastructure customizations
               - Accept upstream core functionality improvements
               - Manually merge when both are important

            3. **Remove ALL conflict markers** (`<<<<<<<`, `=======`, `>>>>>>>`)

            4. **Verify syntax** - ensure file is valid (use linter if needed)

            5. **Stage the resolved file:**
               ```bash
               git add <resolved-file>
               ```

            6. **Repeat for all conflicted files** until `git status` shows no unmerged paths

            ### Step 4: Comprehensive Testing (CRITICAL)

            **YOU MUST RUN ALL THESE TESTS AND ENSURE THEY PASS:**

            ```bash
            # 1. Install dependencies
            make install-dev

            # 2. Linting (MUST PASS)
            make lint

            # 3. Type checking (MUST PASS)
            make lint-mypy

            # 4. Unit tests (MUST PASS)
            make test-unit

            # 5. If time permits, run integration tests
            # make test-integration
            ```

            **If any test fails:**
            - Investigate the failure
            - Fix the issue (likely a conflict resolution error)
            - Re-run tests until ALL pass
            - DO NOT proceed to PR creation if tests fail

            ### Step 5: Commit Your Changes
            ```bash
            git commit -m "fix: resolve upstream sync conflicts for PR #${{ needs.check-eligibility.outputs.pr-number }}

            Conflict resolution strategy:
            - Preserved CARTO customizations in infrastructure files
            - Accepted upstream improvements to core LiteLLM functionality
            - Manually merged files with both CARTO and upstream changes

            Testing:
            - ‚úÖ make lint passed
            - ‚úÖ make lint-mypy passed
            - ‚úÖ make test-unit passed

            Files with manual merge:
            [List files where you combined both versions]
            "
            ```

            ### Step 6: Push Branch
            ```bash
            git push -u origin upstream-sync-resolver/${{ needs.check-eligibility.outputs.pr-number }}
            ```

            ### Step 7: Create Pull Request

            **CRITICAL: PR must target carto/main (base branch)**

            Use `gh pr create` with this template:

            ```bash
            gh pr create \
              --repo ${{ github.repository }} \
              --base ${{ steps.pr-info.outputs.base-ref }} \
              --head upstream-sync-resolver/${{ needs.check-eligibility.outputs.pr-number }} \
              --title "fix: resolve conflicts for upstream sync PR #${{ needs.check-eligibility.outputs.pr-number }}" \
              --label "conflict-resolution" \
              --label "automated" \
              --label "needs-review" \
              --body "$(cat <<'PRBODY'
            ## üîß Automated Conflict Resolution

            This PR resolves merge conflicts in #${{ needs.check-eligibility.outputs.pr-number }}.

            ### üéØ Resolution Strategy

            Followed strict priority order:
            1. **üè¢ CARTO Customizations** - Preserved all CARTO-specific infrastructure
            2. **üîß LiteLLM Core** - Accepted upstream improvements to core functionality
            3. **‚öñÔ∏è Manual Merge** - Combined both when needed

            ### üìã Files Modified

            **CARTO versions kept:**
            [List files where you kept CARTO version]

            **Upstream versions accepted:**
            [List files where you accepted upstream]

            **Manually merged:**
            [List files where you combined both - explain reasoning]

            ### ‚úÖ Testing Results

            - [x] `make lint` - PASSED
            - [x] `make lint-mypy` - PASSED
            - [x] `make test-unit` - PASSED
            - [ ] Manual review of Dockerfile CARTO customizations
            - [ ] Manual review of Makefile CARTO sections

            ### üîç Review Guidelines

            **Please verify:**
            1. ‚úÖ CARTO workflows intact (`.github/workflows/carto_*.yaml`)
            2. ‚úÖ Dockerfile CARTO customizations preserved (`# CARTO:` comments)
            3. ‚úÖ Makefile CARTO sections intact
            4. ‚úÖ Core LiteLLM functionality improved with upstream changes
            5. ‚úÖ All tests passing

            ### üìù Notes

            [Add any important notes about complex conflict resolutions here]

            ### üîÑ What Happens After Merge

            **When this PR is merged into `carto/main`:**
            1. ‚úÖ All upstream changes from `main` will be in `carto/main` (with conflicts resolved)
            2. ‚úÖ CARTO customizations will be preserved
            3. ‚ùå **Close PR #${{ needs.check-eligibility.outputs.pr-number }}** - it becomes redundant (changes already merged)
            4. üéâ Upstream sync complete!

            **Branch flow:**
            ```
            upstream ‚Üí main (mirror) ‚Üí carto/main (via this PR)
            ```

            ---
            ü§ñ *Automated conflict resolution by Claude Code*
            Resolves conflicts in #${{ needs.check-eligibility.outputs.pr-number }}
            PRBODY
            )"
            ```

            ## üö® CRITICAL REQUIREMENTS

            1. **ALL TESTS MUST PASS** - Do not create PR if tests fail
            2. **PRIORITIZE CARTO** - When unsure, preserve CARTO customizations
            3. **DOCUMENT REASONING** - Explain complex merge decisions in PR body
            4. **NO CONFLICT MARKERS** - Ensure all `<<<<<<<`, `=======`, `>>>>>>>` removed
            5. **VERIFY SYNTAX** - All files must be syntactically valid

            ## Success Criteria Checklist

            - [ ] All conflicts resolved (no conflict markers remain)
            - [ ] `make lint` passes
            - [ ] `make lint-mypy` passes
            - [ ] `make test-unit` passes
            - [ ] CARTO customizations preserved
            - [ ] Core LiteLLM functionality improved
            - [ ] PR created with comprehensive description
            - [ ] Branch pushed successfully

            ---

            **Begin conflict resolution now!**

        env:
          GH_TOKEN: ${{ secrets.X_GITHUB_SUPERCARTOFANTE }}
          GITHUB_TOKEN: ${{ secrets.X_GITHUB_SUPERCARTOFANTE }}

      - name: Summary
        if: always()
        run: |
          echo "::group::Claude Code Execution Summary"
          echo "[Resolver] Claude Code conflict resolution completed"
          echo "[Resolver] Check the action logs above for details"
          echo "[Resolver] A new PR should have been created if successful"
          echo "::endgroup::"

          cat >> $GITHUB_STEP_SUMMARY << 'EOF'
          ## ü§ñ Claude Code Conflict Resolution

          Claude Code has attempted to resolve conflicts in PR #${{ needs.check-eligibility.outputs.pr-number }}.

          **Configuration:**
          - Model: Sonnet 4.5
          - Max turns: 250 (very generous - timeout is real limit)
          - Job timeout: 90 minutes (workflow-level)
          - Tools: Read, Write, Edit, Bash, Grep, Glob (restricted)
          - Estimated cost: Limited by 90-min timeout (~$3-10 max)

          **Resolution Priorities Applied:**
          1. üè¢ CARTO customizations (highest priority)
          2. üîß LiteLLM core functionality improvements
          3. ‚öñÔ∏è Manual merge when both are important

          **Testing Requirements:**
          - ‚úÖ All linting and type checks must pass
          - ‚úÖ All unit tests must pass
          - ‚úÖ CARTO customizations must be preserved

          **Next Steps:**
          1. Review the PR created by Claude Code
          2. Verify conflict resolutions follow priorities
          3. Check test results in the PR
          4. Merge the resolution PR to update the sync PR

          **Review Checklist:**
          - [ ] CARTO workflows preserved
          - [ ] Dockerfile CARTO customizations intact (`# CARTO:` comments)
          - [ ] Makefile CARTO sections preserved
          - [ ] Core LiteLLM improvements accepted
          - [ ] All tests passing (`make lint`, `make lint-mypy`, `make test-unit`)
          EOF

      - name: Comment on original PR - Completion
        if: always()
        env:
          GH_TOKEN: ${{ secrets.X_GITHUB_SUPERCARTOFANTE }}
        run: |
          # Determine if Claude succeeded or failed
          if [ "${{ steps.claude-run.outcome }}" == "success" ]; then
            # Try to find the resolution PR that Claude created
            RESOLUTION_PR=$(gh pr list \
              --repo ${{ github.repository }} \
              --head upstream-sync-resolver/${{ needs.check-eligibility.outputs.pr-number }} \
              --json number,url \
              --jq '.[0].url' || echo "")

            if [ -n "${RESOLUTION_PR}" ]; then
              # Success with PR created
              gh pr comment ${{ needs.check-eligibility.outputs.pr-number }} \
                --repo ${{ github.repository }} \
                --body "$(cat <<EOF
          ## ‚úÖ Conflict Resolution Complete

          Claude Code has successfully resolved conflicts and created a resolution PR.

          **Resolution PR:** ${RESOLUTION_PR}

          **Next Steps:**
          1. Review the resolution PR
          2. Verify CARTO customizations are preserved
          3. Check that all tests pass
          4. Merge the resolution PR to update this PR

          **Workflow Run:** ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
          EOF
          )"
            else
              # Success but no PR found (might still be creating)
              gh pr comment ${{ needs.check-eligibility.outputs.pr-number }} \
                --repo ${{ github.repository }} \
                --body "$(cat <<EOF
          ## ‚ö†Ô∏è Conflict Resolution Status

          Claude Code completed execution, but no resolution PR was found yet.

          This might mean:
          - PR is still being created
          - No conflicts were found
          - Check the workflow logs for details

          **Workflow Run:** ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
          EOF
          )"
            fi
          else
            # Failure
            gh pr comment ${{ needs.check-eligibility.outputs.pr-number }} \
              --repo ${{ github.repository }} \
              --body "$(cat <<EOF
          ## ‚ùå Conflict Resolution Failed

          Claude Code encountered an error while resolving conflicts.

          **Please check:**
          - Workflow logs for error details
          - May need manual conflict resolution
          - Consider adjusting max-turns or timeout if job was interrupted

          **Workflow Run:** ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}

          **Manual Resolution Steps:**
          1. Checkout main branch locally
          2. Create resolution branch
          3. Resolve conflicts following CARTO_CLAUDE.md guidelines
          4. Run tests and create PR
          EOF
          )"
          fi

      - name: Close original PR (conflicts now resolved via resolution PR)
        if: steps.claude-run.outcome == 'success'
        env:
          GH_TOKEN: ${{ secrets.X_GITHUB_SUPERCARTOFANTE }}
        run: |
          # Check if resolution PR was created
          RESOLUTION_PR=$(gh pr list \
            --repo ${{ github.repository }} \
            --head upstream-sync-resolver/${{ needs.check-eligibility.outputs.pr-number }} \
            --json number,url \
            --jq '.[0].url' || echo "")

          if [ -n "${RESOLUTION_PR}" ]; then
            RESOLUTION_PR_NUMBER=$(gh pr list \
              --repo ${{ github.repository }} \
              --head upstream-sync-resolver/${{ needs.check-eligibility.outputs.pr-number }} \
              --json number \
              --jq '.[0].number' || echo "")

            echo "[Resolver] ‚úÖ Resolution PR found: ${RESOLUTION_PR}"
            echo "[Resolver] üö´ Closing original PR #${{ needs.check-eligibility.outputs.pr-number }} (superseded by resolution PR)"

            # Add final comment before closing
            gh pr comment ${{ needs.check-eligibility.outputs.pr-number }} \
              --repo ${{ github.repository }} \
              --body "$(cat <<EOF
          ## üîí PR Closed - Superseded by Resolution PR

          This PR has been automatically closed because conflicts have been resolved in a separate PR.

          **‚úÖ Resolution PR:** #${RESOLUTION_PR_NUMBER} (${RESOLUTION_PR})

          **Why was this closed?**
          - Conflicts were resolved by Claude Code in the resolution PR
          - Merging the resolution PR will bring all changes into \`carto/main\`
          - This PR becomes redundant once resolution PR is merged
          - Prevents confusion about which PR to merge

          **Next Steps:**
          1. ‚úÖ Review and merge the resolution PR: #${RESOLUTION_PR_NUMBER}
          2. üéâ All upstream changes will be in \`carto/main\` (sync complete!)

          ---
          ü§ñ *Automatically closed by [carto-upstream-sync-resolver](https://github.com/${{ github.repository }}/actions/workflows/carto-upstream-sync-resolver.yml)*
          EOF
          )"

            # Close the PR
            gh pr close ${{ needs.check-eligibility.outputs.pr-number }} \
              --repo ${{ github.repository }} \
              --comment "Conflicts resolved via #${RESOLUTION_PR_NUMBER}"

            echo "[Resolver] ‚úÖ Original PR #${{ needs.check-eligibility.outputs.pr-number }} closed successfully"
          else
            echo "[Resolver] ‚ö†Ô∏è No resolution PR found - keeping original PR open"
          fi
