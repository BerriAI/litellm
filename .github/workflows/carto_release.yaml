name: CARTO - Create Release

################################################################################
# CARTO Release Workflow with Intelligent Release Notes
################################################################################
#
# This workflow creates CARTO releases with AI-powered, product-focused
# release notes that automatically filter out infrastructure changes.
#
# Features:
# - Security verification: Only authorized users can trigger releases
# - Intelligent release notes: Uses Claude Code to analyze commits and
#   generate user-friendly release notes that exclude CI/CD, sync automation,
#   and dev tooling changes
# - Automatic versioning: Detects version from commits or uses manual input
# - Docker build: Creates and pushes non-root Docker image
#
# Security measures:
# - Actor authorization check (Cartofante, mateo-di only)
# - Read-only tools for Claude (Bash, Read, Grep, Glob)
# - Rate limiting: max-turns: 50, 20-min timeout (~$0.50-2 per release)
# - No write access to repository during notes generation
#
# Uses X_GITHUB_SUPERCARTOFANTE token where workflow modifications are needed.

on:
  workflow_dispatch:
    inputs:
      bump_type:
        description: 'Version bump type (leave "auto" to detect from commits)'
        required: true
        type: choice
        options:
          - auto
          - patch
          - minor
          - major
        default: 'auto'

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  # Security verification - MUST PASS before any release operations
  security-check:
    name: Security Verification
    runs-on: ubuntu-latest
    outputs:
      authorized: ${{ steps.verify.outputs.authorized }}

    steps:
      - name: Verify actor authorization
        id: verify
        run: |
          set -eu

          echo "::group::Security verification"

          # Security Check: Only allow specific authorized users to create releases
          ACTOR="${{ github.actor }}"
          ALLOWED_ACTORS="Cartofante mateo-di"

          # Check if actor is in allowed list (case-insensitive)
          ACTOR_LOWER="${ACTOR,,}"
          ALLOWED=false
          for allowed in ${ALLOWED_ACTORS}; do
            if [[ "${ACTOR_LOWER}" == "${allowed,,}" ]]; then
              ALLOWED=true
              break
            fi
          done

          if [[ "${ALLOWED}" == "false" ]]; then
            echo "[Security] ‚ùå Unauthorized actor: ${ACTOR}"
            echo "[Security] Allowed actors: ${ALLOWED_ACTORS}"
            echo "authorized=false" >> $GITHUB_OUTPUT
            echo "::error::Unauthorized user attempted to create release"
            exit 1
          fi

          echo "[Security] ‚úÖ Actor verified: ${ACTOR}"
          echo "authorized=true" >> $GITHUB_OUTPUT
          echo "::endgroup::"

  create-release:
    runs-on: ubuntu-latest
    needs: security-check
    if: needs.security-check.outputs.authorized == 'true'
    permissions:
      contents: write
      packages: write
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Fetch all history for tags

      - name: Detect upstream version from pyproject.toml
        id: detect-upstream
        run: |
          # Extract version from pyproject.toml
          UPSTREAM_VERSION=$(grep -E "^version\s*=" pyproject.toml | head -1 | sed -E 's/.*"([^"]+)".*/\1/')
          echo "upstream_version=${UPSTREAM_VERSION}" >> $GITHUB_OUTPUT
          echo "Detected upstream version: ${UPSTREAM_VERSION}"

      - name: Get latest CARTO tag (new format)
        id: get-latest-tag
        run: |
          # Search for new format tags: v{upstream}-carto.X.Y.Z
          # Example: v1.79.1-carto.1.7.1
          LATEST_TAG=$(git tag -l "v*-carto.*" | sort -V | tail -n 1)

          if [ -z "$LATEST_TAG" ]; then
            echo "No new-format tags found - this is the FIRST release with new versioning"
            echo "Will analyze all CARTO commits to calculate initial version"
            echo "latest_tag=" >> $GITHUB_OUTPUT
            echo "current_version=0.0.0" >> $GITHUB_OUTPUT
          else
            echo "Found latest tag: ${LATEST_TAG}"
            echo "latest_tag=${LATEST_TAG}" >> $GITHUB_OUTPUT

            # Extract CARTO version for display (format: v1.79.1-carto.1.7.1 ‚Üí 1.7.1)
            CARTO_VERSION=$(echo "$LATEST_TAG" | sed -E 's/.*-carto\.([0-9]+\.[0-9]+\.[0-9]+)/\1/')
            echo "current_version=${CARTO_VERSION}" >> $GITHUB_OUTPUT
            echo "Current CARTO version: ${CARTO_VERSION}"
          fi

      - name: Auto-detect bump type from commits
        id: semver
        if: github.event.inputs.bump_type == 'auto'
        run: |
          UPSTREAM_VERSION="${{ steps.detect-upstream.outputs.upstream_version }}"
          LATEST_TAG="${{ steps.get-latest-tag.outputs.latest_tag }}"

          echo "::group::Analyzing commits for version bump"

          # Get commit range to analyze
          if [ -z "$LATEST_TAG" ]; then
            echo "No previous tag found - analyzing last 30 commits"
            COMMITS=$(git log --oneline --no-merges -30)
          else
            echo "Analyzing commits since ${LATEST_TAG}"
            COMMITS=$(git log ${LATEST_TAG}..HEAD --oneline --no-merges)
          fi

          # Count commits by type
          BREAKING_COUNT=$(echo "$COMMITS" | grep -iE "^[a-f0-9]+ (BREAKING CHANGE:|breaking:|major:)" | wc -l || echo 0)
          FEAT_COUNT=$(echo "$COMMITS" | grep -iE "^[a-f0-9]+ (feat:|feature:)" | wc -l || echo 0)
          FIX_COUNT=$(echo "$COMMITS" | grep -iE "^[a-f0-9]+ (fix:|bugfix:)" | wc -l || echo 0)

          # Determine bump type
          if [ "$BREAKING_COUNT" -gt 0 ]; then
            BUMP_TYPE="major"
            echo "üî¥ Detected $BREAKING_COUNT breaking changes ‚Üí MAJOR bump"
          elif [ "$FEAT_COUNT" -gt 0 ]; then
            BUMP_TYPE="minor"
            echo "üü° Detected $FEAT_COUNT features ‚Üí MINOR bump"
          elif [ "$FIX_COUNT" -gt 0 ]; then
            BUMP_TYPE="patch"
            echo "üü¢ Detected $FIX_COUNT fixes ‚Üí PATCH bump"
          else
            BUMP_TYPE="patch"
            echo "‚ö™ No conventional commits detected ‚Üí Default PATCH bump"
          fi

          echo "bump_type=${BUMP_TYPE}" >> $GITHUB_OUTPUT
          echo "::endgroup::"

      - name: Calculate next CARTO version
        id: calc-version
        run: |
          UPSTREAM_VERSION="${{ steps.detect-upstream.outputs.upstream_version }}"
          LATEST_TAG="${{ steps.get-latest-tag.outputs.latest_tag }}"

          echo "::group::Calculating CARTO version"

          # Make script executable
          chmod +x .github/scripts/calculate_carto_version.sh

          # Calculate new version using script
          RELEASE_TAG=$(./.github/scripts/calculate_carto_version.sh "${LATEST_TAG}" "${UPSTREAM_VERSION}")

          echo "Calculated release tag: ${RELEASE_TAG}"

          # Extract CARTO version from tag for display
          CARTO_VERSION=$(echo "$RELEASE_TAG" | sed -E 's/.*-carto\.([0-9]+\.[0-9]+\.[0-9]+)/\1/')

          # Detect if this is an upstream sync (first release for this upstream version)
          if [ -z "$LATEST_TAG" ]; then
            echo "First release for upstream v${UPSTREAM_VERSION} - this is an upstream sync"
            IS_UPSTREAM_SYNC="true"
            PREVIOUS_UPSTREAM="unknown"
          else
            # Extract upstream version from previous tag
            PREVIOUS_UPSTREAM=$(echo "$LATEST_TAG" | sed -E 's/v([0-9]+\.[0-9]+\.[0-9]+)-carto\..*/\1/')
            if [ "$PREVIOUS_UPSTREAM" != "$UPSTREAM_VERSION" ]; then
              echo "Upstream version changed: ${PREVIOUS_UPSTREAM} ‚Üí ${UPSTREAM_VERSION}"
              echo "This is an upstream sync release"
              IS_UPSTREAM_SYNC="true"
            else
              echo "Same upstream version: ${UPSTREAM_VERSION}"
              echo "This is a CARTO-only release"
              IS_UPSTREAM_SYNC="false"
            fi
          fi

          # Output variables
          echo "release_tag=${RELEASE_TAG}" >> $GITHUB_OUTPUT
          echo "carto_version=${CARTO_VERSION}" >> $GITHUB_OUTPUT
          echo "is_upstream_sync=${IS_UPSTREAM_SYNC}" >> $GITHUB_OUTPUT
          echo "previous_upstream=${PREVIOUS_UPSTREAM}" >> $GITHUB_OUTPUT

          echo "::endgroup::"

          echo "üì¶ Release tag: ${RELEASE_TAG}"
          echo "   CARTO version: ${CARTO_VERSION}"
          echo "   Upstream sync: ${IS_UPSTREAM_SYNC}"

      - name: Generate intelligent release notes with Claude
        id: release-notes
        uses: anthropics/claude-code-action@v1
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          anthropic_api_key: ${{ secrets.ANTHROPIC_API_KEY }}
          show_full_output: false
          claude_args: "--model claude-sonnet-4-5-20250929 --max-turns 50 --allowed-tools Read,Bash,Grep,Glob"
          prompt: |
            # Intelligent Release Notes Generation with Upstream Sync Detection

            ## Your Task
            Generate product-focused release notes for LiteLLM CARTO fork that separates CARTO-specific changes from upstream LiteLLM improvements.

            ## Context
            - **Current Upstream Version**: ${{ steps.detect-upstream.outputs.upstream_version }}
            - **Is Upstream Sync**: ${{ steps.calc-version.outputs.is_upstream_sync }}
            - **Previous Upstream Version**: ${{ steps.calc-version.outputs.previous_upstream }}
            - **CARTO Version**: ${{ steps.calc-version.outputs.carto_version }}
            - **Release Tag**: ${{ steps.calc-version.outputs.release_tag }}
            - **Output File**: `release_notes.md` (create this file)

            ## Step 1: Determine Release Type

            **Upstream Sync:** ${{ steps.calc-version.outputs.is_upstream_sync }}

            ```bash
            if [ "${{ steps.calc-version.outputs.is_upstream_sync }}" = "true" ]; then
              echo "üîÑ UPSTREAM SYNC DETECTED"
              echo "From: v${{ steps.calc-version.outputs.previous_upstream }}"
              echo "To: v${{ steps.detect-upstream.outputs.upstream_version }}"

              # Get upstream releases between versions
              echo "Fetching upstream releases..."
              gh release list --repo BerriAI/litellm --limit 50 | \
                grep "stable" | \
                head -10
            else
              echo "üìù Regular CARTO release (not an upstream sync)"
            fi
            ```

            ## Step 2: Analyze CARTO Commits

            Find the last CARTO release tag and analyze commits since then:

            ```bash
            # Get last CARTO release tag
            LAST_TAG=$(git tag -l "v*-carto.*" | sort -V | tail -n 1)

            if [ -n "$LAST_TAG" ]; then
              echo "Analyzing CARTO commits since ${LAST_TAG}..."
              git log ${LAST_TAG}..HEAD --oneline --no-merges | \
                grep -vE "(sync:|Merge|merge upstream)"
            else
              echo "First CARTO release - analyzing recent commits..."
              git log --oneline --no-merges -30 | \
                grep -vE "(sync:|Merge|merge upstream)"
            fi
            ```

            ## Step 2: Filter Out Non-Product Commits
            **EXCLUDE these types of commits:**
            1. ‚ùå **CI/CD & Workflows**: Changes to `.github/workflows/`, GitHub Actions, CI configurations
               - Examples: "fix: workflow", "ci:", "chore(workflow)", "Add Claude conflict resolution"
            2. ‚ùå **Upstream Sync Automation**: Sync infrastructure, conflict resolution automation
               - Examples: "sync:", "upstream sync", "resolver workflow", "merge upstream"
            3. ‚ùå **Internal Documentation**: CARTO_*.md files, maintainer guides, development docs
               - Examples: "Improve CARTO_CLAUDE.md", "docs: update release process"
            4. ‚ùå **Development Tooling**: Makefile changes, linting configs, dev scripts
               - Examples: "chore: update Makefile", "refactor: improve dev scripts"

            **INCLUDE these types of commits:**
            1. ‚úÖ **Bug Fixes**: Fixes to LiteLLM core functionality, proxy, providers
               - Look for: "fix:", "bugfix:", fixes to `litellm/`, `proxy/`
            2. ‚úÖ **Features**: New LiteLLM features, provider support, API improvements
               - Look for: "feat:", "feature:", new capabilities for end-users
            3. ‚úÖ **Breaking Changes**: Changes that affect API, configuration, behavior
               - Look for: "BREAKING CHANGE:", "breaking:", changes to public APIs
            4. ‚úÖ **Cherry-picks from Upstream**: Important upstream fixes merged into CARTO
               - Look for: "cherry-pick", "[sc-XXXXX]" with LiteLLM functionality changes

            ## Step 3: Analyze Each Commit
            For each commit:
            1. Read the commit message
            2. If needed, check what files were changed: `git show --name-only <commit-hash>`
            3. Determine if it's product-relevant (affects LiteLLM functionality for users)
            4. If yes, categorize it: Feature / Bug Fix / Breaking Change / Security

            ## Step 4: Generate Markdown Release Notes

            **IF UPSTREAM SYNC DETECTED** (first release for this upstream version), use this structure:

            ```markdown
            ## üöÄ CARTO Release for LiteLLM v${{ steps.detect-upstream.outputs.upstream_version }}

            **Base Version:** LiteLLM v${{ steps.detect-upstream.outputs.upstream_version }} (synced from v{previous_version})

            ### üîÑ Upstream Sync

            This release includes a **major upstream sync** from LiteLLM v{previous} to v{current}.

            **Upstream Releases Included:**
            - [v{version}-stable](link) ({date}) - [Brief summary of key changes]
            - [v{version}-stable](link) ({date}) - [Brief summary of key changes]

            **Compare Upstream Changes:**
            - [v{previous}-stable...v{current}-stable](comparison_link)

            **Key Upstream Improvements:**
            - **Category**: Brief description of major upstream changes
            - **Category**: Another major upstream improvement
            - *For full upstream changes, see the links above*

            **Sync Strategy:**
            - ‚úÖ Preserved all CARTO customizations
            - ‚úÖ Accepted all upstream core improvements
            - ‚úÖ Resolved conflicts favoring CARTO infrastructure + upstream functionality

            ### ‚ú® CARTO-Specific Features
            - [Only CARTO-developed features, if any]
            - *Or: No CARTO-specific features in this release*

            ### üêõ CARTO-Specific Bug Fixes
            - [Only CARTO-developed fixes, if any]
            - *Or: No CARTO-specific fixes in this release*

            ### üîí Security
            - [CARTO-specific security changes, if any]
            - *Or: No CARTO-specific security changes. All upstream security fixes included.*

            ### ‚ö†Ô∏è Breaking Changes
            - [CARTO-specific breaking changes, if any]
            - *Or: No CARTO-specific breaking changes. See upstream release notes for upstream breaking changes.*

            ---
            *This release includes upstream sync + X CARTO-specific changes. Infrastructure and CI changes are not listed.*
            ```

            **IF REGULAR CARTO RELEASE** (not first release for this upstream version), use this structure:

            ```markdown
            ## üöÄ CARTO Release for LiteLLM v${{ steps.detect-upstream.outputs.upstream_version }}

            **Base Version:** LiteLLM v${{ steps.detect-upstream.outputs.upstream_version }}

            ### ‚ú® Features
            - [Brief description of feature]

            ### üêõ Bug Fixes
            - [Brief description of fix]

            ### üîí Security
            - [If any security-related changes]

            ### ‚ö†Ô∏è Breaking Changes
            - [If any breaking changes]

            ---
            *This release includes X product-relevant changes. Infrastructure and CI changes are not listed here.*
            ```

            ## Important Guidelines

            ### General Guidelines
            1. **Be concise but clear**: Each bullet should explain WHAT changed and WHY it matters to users
            2. **Group related changes**: If multiple commits fix the same issue, combine into one bullet
            3. **Skip internal details**: Don't mention workflow files, CI configs, documentation updates for maintainers
            4. **Add context**: Transform raw commit messages into user-friendly descriptions
            5. **Empty sections**: If no features/fixes, write "No changes in this category"

            ### Upstream Sync Guidelines
            6. **Separate CARTO from upstream**: Clearly distinguish CARTO-developed changes from upstream improvements
            7. **Summarize upstream changes**: Don't list every upstream commit - provide high-level categories (e.g., "New provider support", "Performance improvements")
            8. **Link to upstream releases**: Always include links to upstream release notes for full details
            9. **Highlight key upstream features**: Mention 2-3 most important upstream improvements that affect users
            10. **Cherry-picks**: If CARTO cherry-picked specific upstream fixes before the sync, mention them in CARTO-Specific section

            ## Example Transformations

            ### Upstream Sync Example:
            ‚ùå BAD: "Merged upstream v1.79.1"
            ‚úÖ GOOD:
            ```
            ### üîÑ Upstream Sync
            This release includes a major upstream sync from LiteLLM v1.75.2 to v1.79.1.

            **Upstream Releases Included:**
            - [v1.78.5-stable](link) (2025-10-26) - Performance improvements and bug fixes
            - [v1.79.0-stable](link) (2025-11-01) - New provider support for Anthropic Claude 3.5
            - [v1.79.1-stable](link) (2025-11-08) - Security updates and stability improvements

            **Key Upstream Improvements:**
            - **New Providers**: Added support for Anthropic Claude 3.5 Sonnet and Haiku models
            - **Performance**: 30% faster response times for streaming endpoints
            - **Bug Fixes**: Resolved 45+ issues including token counting accuracy and rate limiting
            ```

            ### CARTO-Specific Change Example:
            ‚ùå BAD (raw commit): "fix: cherry-pick upstream metadata None check [sc-521238]"
            ‚úÖ GOOD (user-friendly): "Fixed crash when LiteLLM proxy encounters null metadata in Vertex AI provider responses (cherry-picked from upstream)"

            ### Exclusion Example:
            ‚ùå BAD (should exclude): "feat: create separate CI fixer workflow with upstream test check"
            ‚úÖ GOOD (excluded): Not included in release notes (CI infrastructure change)

            ## Output
            Write the final release notes to `release_notes.md` and confirm it was created successfully.

            **Start now!**
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        timeout-minutes: 20

      - name: Create Git tag
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git tag -a "${{ steps.calc-version.outputs.release_tag }}" -m "Release ${{ steps.calc-version.outputs.release_tag }}"
          git push origin "${{ steps.calc-version.outputs.release_tag }}"

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v1
        with:
          tag_name: ${{ steps.calc-version.outputs.release_tag }}
          name: ${{ steps.calc-version.outputs.release_tag }}
          body_path: release_notes.md
          draft: false
          prerelease: false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Log in to Container registry
        uses: docker/login-action@65b78e6e13532edd9afa3aa52ac7964289d1a9c1
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Set up QEMU
        uses: docker/setup-qemu-action@e0e4588fad221d38ee467c0bffd91115366dc0c5

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@edfb0fe6204400c56fbfd3feba3fe9ad1adfa345

      - name: Extract metadata for Docker
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}-non_root
          tags: |
            type=raw,value=${{ steps.calc-version.outputs.release_tag }}
            type=raw,value=carto-stable
            type=raw,value=carto-v${{ steps.detect-upstream.outputs.upstream_version }}-latest

      - name: Build and push Docker image
        uses: docker/build-push-action@f2a1d5e99d037542a71f64918e516c093c6f3fc4
        with:
          context: .
          file: ./docker/Dockerfile.non_root
          push: true
          cache-from: type=gha
          cache-to: type=gha,mode=max
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          platforms: linux/amd64

      - name: Release Summary
        run: |
          echo "## üéâ Release Created Successfully!" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Upstream Version:** \`${{ steps.detect-upstream.outputs.upstream_version }}\`" >> $GITHUB_STEP_SUMMARY
          echo "**Tag:** \`${{ steps.calc-version.outputs.release_tag }}\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### üìù Release Notes" >> $GITHUB_STEP_SUMMARY
          echo "Release notes were generated using Claude Code AI analysis." >> $GITHUB_STEP_SUMMARY
          echo "Only product-relevant changes are included (CI/CD and infrastructure changes excluded)." >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### üê≥ Docker Tags" >> $GITHUB_STEP_SUMMARY
          echo "- \`ghcr.io/${{ env.IMAGE_NAME }}-non_root:${{ steps.calc-version.outputs.release_tag }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- \`ghcr.io/${{ env.IMAGE_NAME }}-non_root:carto-stable\`" >> $GITHUB_STEP_SUMMARY
          echo "- \`ghcr.io/${{ env.IMAGE_NAME }}-non_root:carto-v${{ steps.detect-upstream.outputs.upstream_version }}-latest\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### üîí Security" >> $GITHUB_STEP_SUMMARY
          echo "- ‚úÖ Actor authorization verified" >> $GITHUB_STEP_SUMMARY
          echo "- ‚úÖ Claude Code used read-only tools" >> $GITHUB_STEP_SUMMARY
          echo "- ‚úÖ Rate limited (max 50 turns, 20-min timeout)" >> $GITHUB_STEP_SUMMARY

      - name: Notify Slack of new release
        if: success()
        env:
          SLACK_CHANNEL: "C09K0M5MP7V" # cartodb-ops
        run: |
          set -eu

          echo "::group::Preparing Slack notification"

          # Check if SLACK_KEY secret is configured
          if [[ -z "${{ secrets.SLACK_KEY }}" ]]; then
            echo "::warning::SLACK_KEY secret not configured - skipping notification"
            echo "::endgroup::"
            exit 0
          fi

          # Prepare notification data
          RELEASE_TAG="${{ steps.calc-version.outputs.release_tag }}"
          CARTO_VERSION="${{ steps.calc-version.outputs.carto_version }}"
          UPSTREAM_VERSION="${{ steps.detect-upstream.outputs.upstream_version }}"
          IS_UPSTREAM_SYNC="${{ steps.calc-version.outputs.is_upstream_sync }}"
          RELEASE_URL="https://github.com/${{ github.repository }}/releases/tag/${RELEASE_TAG}"
          DOCKER_IMAGE="ghcr.io/${{ github.repository }}-non_root:carto-stable"

          # Determine release type
          if [ "$IS_UPSTREAM_SYNC" = "true" ]; then
            PREVIOUS_UPSTREAM="${{ steps.calc-version.outputs.previous_upstream }}"
            TYPE_LABEL="Upstream Sync (v${PREVIOUS_UPSTREAM} ‚Üí v${UPSTREAM_VERSION})"
            EMOJI=":arrows_counterclockwise:"
          else
            TYPE_LABEL="CARTO Customization"
            EMOJI=":rocket:"
          fi

          # Build Slack message with context
          MESSAGE="${EMOJI} *LiteLLM CARTO Release* - ${RELEASE_TAG}

          *Release Details:*
          - Type: ${TYPE_LABEL}
          - CARTO Version: ${CARTO_VERSION}
          - Upstream Base: LiteLLM v${UPSTREAM_VERSION}
          - Release Notes: ${RELEASE_URL}
          - Docker Image: ${DOCKER_IMAGE}"

          echo "[Slack] Sending notification to channel ${SLACK_CHANNEL}"
          echo "::endgroup::"

          echo "::group::Posting to Slack"

          # Retry logic (up to 3 attempts)
          SUCCESS=false
          for attempt in 1 2 3; do
            echo "[Slack] Attempt ${attempt}/3..."

            # Send to Slack API
            RESPONSE=$(curl -s -w "\n%{http_code}" \
              -F "text=${MESSAGE}" \
              -F "channel=${SLACK_CHANNEL}" \
              -H "Authorization: Bearer ${{ secrets.SLACK_KEY }}" \
              -X POST https://slack.com/api/chat.postMessage)

            # Extract HTTP code and body
            HTTP_CODE=$(echo "$RESPONSE" | tail -n1)
            BODY=$(echo "$RESPONSE" | head -n-1)

            echo "[Slack] HTTP ${HTTP_CODE}"
            echo "[Slack] Response: ${BODY}"

            # Check if successful
            if [ "$HTTP_CODE" = "200" ]; then
              # Check Slack API response
              if echo "$BODY" | grep -q '"ok":true'; then
                echo "‚úÖ [Slack] Release notification sent successfully"
                SUCCESS=true
                break
              else
                ERROR=$(echo "$BODY" | grep -o '"error":"[^"]*"' || echo "unknown error")
                echo "‚ö†Ô∏è [Slack] Slack API error: ${ERROR}"
              fi
            else
              echo "‚ö†Ô∏è [Slack] HTTP error: ${HTTP_CODE}"
            fi

            # Wait before retry
            if [ $attempt -lt 3 ]; then
              echo "[Slack] Retrying in 5 seconds..."
              sleep 5
            fi
          done

          if [ "$SUCCESS" = "false" ]; then
            echo "::error::Failed to send Slack notification after 3 attempts"
            echo "::notice::Check SLACK_KEY secret and channel permissions"
          fi

          echo "::endgroup::"
