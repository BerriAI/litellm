name: CARTO - Create Release

################################################################################
# CARTO Release Workflow with Intelligent Release Notes
################################################################################
#
# This workflow creates CARTO releases with AI-powered, product-focused
# release notes that automatically filter out infrastructure changes.
#
# Features:
# - Security verification: Only authorized users can trigger releases
# - Intelligent release notes: Uses Claude Code to analyze commits and
#   generate user-friendly release notes that exclude CI/CD, sync automation,
#   and dev tooling changes
# - Automatic versioning: Detects version from commits or uses manual input
# - Docker build: Creates and pushes non-root Docker image
#
# Security measures:
# - Actor authorization check (Cartofante, mateo-di only)
# - Read-only tools for Claude (Bash, Read, Grep, Glob)
# - Rate limiting: max-turns: 50, 20-min timeout (~$0.50-2 per release)
# - No write access to repository during notes generation
#
# Uses X_GITHUB_SUPERCARTOFANTE token where workflow modifications are needed.

on:
  workflow_dispatch:
    inputs:
      bump_type:
        description: 'Version bump type (leave "auto" to detect from commits)'
        required: true
        type: choice
        options:
          - auto
          - patch
          - minor
          - major
        default: 'auto'

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  # Security verification - MUST PASS before any release operations
  security-check:
    name: Security Verification
    runs-on: ubuntu-latest
    outputs:
      authorized: ${{ steps.verify.outputs.authorized }}

    steps:
      - name: Verify actor authorization
        id: verify
        run: |
          set -eu

          echo "::group::Security verification"

          # Security Check: Only allow specific authorized users to create releases
          ACTOR="${{ github.actor }}"
          ALLOWED_ACTORS="Cartofante mateo-di"

          # Check if actor is in allowed list (case-insensitive)
          ACTOR_LOWER="${ACTOR,,}"
          ALLOWED=false
          for allowed in ${ALLOWED_ACTORS}; do
            if [[ "${ACTOR_LOWER}" == "${allowed,,}" ]]; then
              ALLOWED=true
              break
            fi
          done

          if [[ "${ALLOWED}" == "false" ]]; then
            echo "[Security] ‚ùå Unauthorized actor: ${ACTOR}"
            echo "[Security] Allowed actors: ${ALLOWED_ACTORS}"
            echo "authorized=false" >> $GITHUB_OUTPUT
            echo "::error::Unauthorized user attempted to create release"
            exit 1
          fi

          echo "[Security] ‚úÖ Actor verified: ${ACTOR}"
          echo "authorized=true" >> $GITHUB_OUTPUT
          echo "::endgroup::"

  create-release:
    runs-on: ubuntu-latest
    needs: security-check
    if: needs.security-check.outputs.authorized == 'true'
    permissions:
      contents: write
      packages: write
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Fetch all history for tags

      - name: Detect upstream version from pyproject.toml
        id: detect-upstream
        run: |
          # Extract version from pyproject.toml
          UPSTREAM_VERSION=$(grep -E "^version\s*=" pyproject.toml | head -1 | sed -E 's/.*"([^"]+)".*/\1/')
          echo "upstream_version=${UPSTREAM_VERSION}" >> $GITHUB_OUTPUT
          echo "Detected upstream version: ${UPSTREAM_VERSION}"

      - name: Get latest CARTO tag for this upstream version
        id: get-latest-tag
        run: |
          # Get all tags matching the pattern carto-v{upstream_version}-*
          UPSTREAM_VERSION="${{ steps.detect-upstream.outputs.upstream_version }}"
          PREFIX="carto-v${UPSTREAM_VERSION}-"

          # Get the latest tag with this prefix
          LATEST_TAG=$(git tag -l "${PREFIX}*" | sort -V | tail -n 1)

          if [ -z "$LATEST_TAG" ]; then
            echo "No existing tags found for ${PREFIX}, starting with 0.0.0"
            echo "latest_tag=" >> $GITHUB_OUTPUT
            echo "current_version=0.0.0" >> $GITHUB_OUTPUT
          else
            echo "latest_tag=${LATEST_TAG}" >> $GITHUB_OUTPUT
            # Extract the semver part (everything after the prefix)
            CURRENT_VERSION="${LATEST_TAG#${PREFIX}}"
            echo "current_version=${CURRENT_VERSION}" >> $GITHUB_OUTPUT
            echo "Found latest tag: ${LATEST_TAG} (version: ${CURRENT_VERSION})"
          fi

      - name: Prepare semver config with dynamic prefix
        if: github.event.inputs.bump_type == 'auto'
        run: |
          UPSTREAM_VERSION="${{ steps.detect-upstream.outputs.upstream_version }}"
          cat > semver_dynamic.yaml << EOF
          bump:
            major:
              - "BREAKING CHANGE:"
              - "breaking:"
              - "major:"
            minor:
              - "feat:"
              - "feature:"
            patch:
              - "fix:"
              - "bugfix:"
              - "patch:"
              - "chore:"
              - "docs:"
              - "refactor:"
          default: patch
          tag_prefix: "carto-v${UPSTREAM_VERSION}-"
          EOF
          cat semver_dynamic.yaml

      - name: Calculate next version with semver-generator
        id: semver
        if: github.event.inputs.bump_type == 'auto'
        uses: lukaszraczylo/semver-generator@1.12.379
        with:
          config_file: semver_dynamic.yaml
          repository_local: true
          github_username: ${{ github.actor }}
          github_token: ${{ secrets.GITHUB_TOKEN }}

      - name: Calculate next version (manual or auto)
        id: calc-version
        run: |
          UPSTREAM_VERSION="${{ steps.detect-upstream.outputs.upstream_version }}"
          BUMP_TYPE="${{ github.event.inputs.bump_type }}"

          if [ "$BUMP_TYPE" = "auto" ]; then
            # Use semver-generator output
            NEXT_VERSION="${{ steps.semver.outputs.semantic_version }}"
            echo "Auto-detected version from commits: ${NEXT_VERSION}"
          else
            # Manual bump
            CURRENT="${{ steps.get-latest-tag.outputs.current_version }}"
            IFS='.' read -r MAJOR MINOR PATCH <<< "$CURRENT"

            case "$BUMP_TYPE" in
              major)
                MAJOR=$((MAJOR + 1))
                MINOR=0
                PATCH=0
                ;;
              minor)
                MINOR=$((MINOR + 1))
                PATCH=0
                ;;
              patch)
                PATCH=$((PATCH + 1))
                ;;
            esac

            NEXT_VERSION="${MAJOR}.${MINOR}.${PATCH}"
            echo "Manual bump (${BUMP_TYPE}): ${NEXT_VERSION}"
          fi

          RELEASE_TAG="carto-v${UPSTREAM_VERSION}-${NEXT_VERSION}"

          echo "next_version=${NEXT_VERSION}" >> $GITHUB_OUTPUT
          echo "release_tag=${RELEASE_TAG}" >> $GITHUB_OUTPUT
          echo "Release tag: ${RELEASE_TAG}"

      - name: Generate intelligent release notes with Claude
        id: release-notes
        uses: anthropics/claude-code-action@v1
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          anthropic_api_key: ${{ secrets.ANTHROPIC_API_KEY }}
          show_full_output: false
          claude_args: "--model claude-sonnet-4-5-20250929 --max-turns 50 --allowed-tools Read,Bash,Grep,Glob"
          prompt: |
            # Intelligent Release Notes Generation

            ## Your Task
            Generate product-focused release notes for LiteLLM CARTO fork that ONLY include changes relevant to end-users and product functionality.

            ## Context
            - **Upstream Version**: ${{ steps.detect-upstream.outputs.upstream_version }}
            - **Previous Tag**: Find it with: `git tag -l "carto-v${{ steps.detect-upstream.outputs.upstream_version }}-*" | sort -V | tail -n 1`
            - **Output File**: `release_notes.md` (create this file)

            ## Step 1: Find Commits to Analyze
            ```bash
            # Get the latest CARTO tag for this upstream version
            UPSTREAM_VERSION="${{ steps.detect-upstream.outputs.upstream_version }}"
            LATEST_TAG=$(git tag -l "carto-v${UPSTREAM_VERSION}-*" | sort -V | tail -n 1)

            if [ -z "$LATEST_TAG" ]; then
              # First release - get last 30 commits
              git log --oneline --no-merges -30
            else
              # Get commits since last tag
              git log ${LATEST_TAG}..HEAD --oneline --no-merges
            fi
            ```

            ## Step 2: Filter Out Non-Product Commits
            **EXCLUDE these types of commits:**
            1. ‚ùå **CI/CD & Workflows**: Changes to `.github/workflows/`, GitHub Actions, CI configurations
               - Examples: "fix: workflow", "ci:", "chore(workflow)", "Add Claude conflict resolution"
            2. ‚ùå **Upstream Sync Automation**: Sync infrastructure, conflict resolution automation
               - Examples: "sync:", "upstream sync", "resolver workflow", "merge upstream"
            3. ‚ùå **Internal Documentation**: CARTO_*.md files, maintainer guides, development docs
               - Examples: "Improve CARTO_CLAUDE.md", "docs: update release process"
            4. ‚ùå **Development Tooling**: Makefile changes, linting configs, dev scripts
               - Examples: "chore: update Makefile", "refactor: improve dev scripts"

            **INCLUDE these types of commits:**
            1. ‚úÖ **Bug Fixes**: Fixes to LiteLLM core functionality, proxy, providers
               - Look for: "fix:", "bugfix:", fixes to `litellm/`, `proxy/`
            2. ‚úÖ **Features**: New LiteLLM features, provider support, API improvements
               - Look for: "feat:", "feature:", new capabilities for end-users
            3. ‚úÖ **Breaking Changes**: Changes that affect API, configuration, behavior
               - Look for: "BREAKING CHANGE:", "breaking:", changes to public APIs
            4. ‚úÖ **Cherry-picks from Upstream**: Important upstream fixes merged into CARTO
               - Look for: "cherry-pick", "[sc-XXXXX]" with LiteLLM functionality changes

            ## Step 3: Analyze Each Commit
            For each commit:
            1. Read the commit message
            2. If needed, check what files were changed: `git show --name-only <commit-hash>`
            3. Determine if it's product-relevant (affects LiteLLM functionality for users)
            4. If yes, categorize it: Feature / Bug Fix / Breaking Change / Security

            ## Step 4: Generate Markdown Release Notes

            Create `release_notes.md` with this structure:

            ```markdown
            ## üöÄ CARTO Release for LiteLLM v${{ steps.detect-upstream.outputs.upstream_version }}

            **Base Version:** LiteLLM v${{ steps.detect-upstream.outputs.upstream_version }}

            ### ‚ú® Features
            - [Brief description of feature - explain what it does for users, not technical commit details]
            - [Another feature]

            ### üêõ Bug Fixes
            - [Brief description of fix - explain what issue was resolved]
            - [Another fix]

            ### üîí Security
            - [If any security-related changes]

            ### ‚ö†Ô∏è Breaking Changes
            - [If any breaking changes - explain impact and migration path]

            ---
            *This release includes X product-relevant changes. Infrastructure and CI changes are not listed here.*
            ```

            ## Important Guidelines
            1. **Be concise but clear**: Each bullet should explain WHAT changed and WHY it matters to users
            2. **Group related changes**: If multiple commits fix the same issue, combine into one bullet
            3. **Skip internal details**: Don't mention workflow files, CI configs, documentation updates for maintainers
            4. **Add context**: Transform raw commit messages into user-friendly descriptions
            5. **Empty sections**: If no features/fixes, write "No changes in this category"

            ## Example Transformation
            ‚ùå BAD (raw commit): "fix: cherry-pick upstream metadata None check [sc-521238]"
            ‚úÖ GOOD (user-friendly): "Fixed crash when LiteLLM proxy encounters null metadata in provider responses"

            ‚ùå BAD (should exclude): "feat: create separate CI fixer workflow with upstream test check"
            ‚úÖ GOOD (excluded): Not included in release notes (CI infrastructure change)

            ## Output
            Write the final release notes to `release_notes.md` and confirm it was created successfully.

            **Start now!**
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        timeout-minutes: 20

      - name: Create Git tag
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git tag -a "${{ steps.calc-version.outputs.release_tag }}" -m "Release ${{ steps.calc-version.outputs.release_tag }}"
          git push origin "${{ steps.calc-version.outputs.release_tag }}"

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v1
        with:
          tag_name: ${{ steps.calc-version.outputs.release_tag }}
          name: ${{ steps.calc-version.outputs.release_tag }}
          body_path: release_notes.md
          draft: false
          prerelease: false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Log in to Container registry
        uses: docker/login-action@65b78e6e13532edd9afa3aa52ac7964289d1a9c1
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Set up QEMU
        uses: docker/setup-qemu-action@e0e4588fad221d38ee467c0bffd91115366dc0c5

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@edfb0fe6204400c56fbfd3feba3fe9ad1adfa345

      - name: Extract metadata for Docker
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}-non_root
          tags: |
            type=raw,value=${{ steps.calc-version.outputs.release_tag }}
            type=raw,value=carto-stable
            type=raw,value=carto-v${{ steps.detect-upstream.outputs.upstream_version }}-latest

      - name: Build and push Docker image
        uses: docker/build-push-action@f2a1d5e99d037542a71f64918e516c093c6f3fc4
        with:
          context: .
          file: ./docker/Dockerfile.non_root
          push: true
          cache-from: type=gha
          cache-to: type=gha,mode=max
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          platforms: linux/amd64

      - name: Release Summary
        run: |
          echo "## üéâ Release Created Successfully!" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Upstream Version:** \`${{ steps.detect-upstream.outputs.upstream_version }}\`" >> $GITHUB_STEP_SUMMARY
          echo "**Tag:** \`${{ steps.calc-version.outputs.release_tag }}\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### üìù Release Notes" >> $GITHUB_STEP_SUMMARY
          echo "Release notes were generated using Claude Code AI analysis." >> $GITHUB_STEP_SUMMARY
          echo "Only product-relevant changes are included (CI/CD and infrastructure changes excluded)." >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### üê≥ Docker Tags" >> $GITHUB_STEP_SUMMARY
          echo "- \`ghcr.io/${{ env.IMAGE_NAME }}-non_root:${{ steps.calc-version.outputs.release_tag }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- \`ghcr.io/${{ env.IMAGE_NAME }}-non_root:carto-stable\`" >> $GITHUB_STEP_SUMMARY
          echo "- \`ghcr.io/${{ env.IMAGE_NAME }}-non_root:carto-v${{ steps.detect-upstream.outputs.upstream_version }}-latest\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### üîí Security" >> $GITHUB_STEP_SUMMARY
          echo "- ‚úÖ Actor authorization verified" >> $GITHUB_STEP_SUMMARY
          echo "- ‚úÖ Claude Code used read-only tools" >> $GITHUB_STEP_SUMMARY
          echo "- ‚úÖ Rate limited (max 50 turns, 20-min timeout)" >> $GITHUB_STEP_SUMMARY
