name: CARTO - Create Release

################################################################################
# CARTO Release Workflow with Intelligent Release Notes
################################################################################
#
# This workflow creates CARTO releases with AI-powered, product-focused
# release notes that automatically filter out infrastructure changes.
#
# Release Types:
# - patch:         Bug fixes and small improvements (CARTO-specific)
# - feature:       New features and capabilities (CARTO-specific)
# - upstream_sync: Release after merging an upstream sync PR
#
# Workflow Integration:
# 1. carto-upstream-sync.yml runs weekly ‚Üí creates PR to carto/main
# 2. Human reviews and merges upstream sync PR
# 3. Trigger this workflow with release_type="upstream_sync"
#
# For CARTO-only releases (no upstream changes), use "patch" or "feature"
#
# Features:
# - Security verification: Only authorized users can trigger releases
# - Intelligent release notes: Uses Claude Code to analyze commits
# - Explicit release type selection (no auto-detection)
# - Displays latest release info and pending upstream sync PRs
# - Docker build: Creates and pushes non-root Docker image
#
# Security measures:
# - Actor authorization check (Cartofante, mateo-di only)
# - Read-only tools for Claude (Bash, Read, Grep, Glob)
# - Rate limiting: max-turns: 50, 20-min timeout (~$0.50-2 per release)
# - No write access to repository during notes generation
#
# Uses X_GITHUB_SUPERCARTOFANTE token where workflow modifications are needed.

on:
  workflow_dispatch:
    inputs:
      release_type:
        description: 'Type of release (patch=bug fixes, feature=new features, upstream_sync=after merging upstream)'
        required: true
        type: choice
        options:
          - patch
          - feature
          - upstream_sync
        default: 'patch'
      branch:
        description: 'Branch to release from (default: carto/main)'
        required: true
        type: string
        default: 'carto/main'

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  # Security verification - MUST PASS before any release operations
  security-check:
    name: Security Verification
    runs-on: ubuntu-latest
    outputs:
      authorized: ${{ steps.verify.outputs.authorized }}

    steps:
      - name: Verify actor authorization
        id: verify
        run: |
          set -eu

          echo "::group::Security verification"

          # Security Check: Only allow specific authorized users to create releases
          ACTOR="${{ github.actor }}"
          ALLOWED_ACTORS="Cartofante mateo-di"

          # Check if actor is in allowed list (case-insensitive)
          ACTOR_LOWER="${ACTOR,,}"
          ALLOWED=false
          for allowed in ${ALLOWED_ACTORS}; do
            if [[ "${ACTOR_LOWER}" == "${allowed,,}" ]]; then
              ALLOWED=true
              break
            fi
          done

          if [[ "${ALLOWED}" == "false" ]]; then
            echo "[Security] ‚ùå Unauthorized actor: ${ACTOR}"
            echo "[Security] Allowed actors: ${ALLOWED_ACTORS}"
            echo "authorized=false" >> $GITHUB_OUTPUT
            echo "::error::Unauthorized user attempted to create release"
            exit 1
          fi

          echo "[Security] ‚úÖ Actor verified: ${ACTOR}"
          echo "authorized=true" >> $GITHUB_OUTPUT
          echo "::endgroup::"

  create-release:
    runs-on: ubuntu-latest
    needs: security-check
    if: needs.security-check.outputs.authorized == 'true'
    permissions:
      contents: write
      packages: write
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.inputs.branch }}
          fetch-depth: 0  # Fetch all history for tags

      - name: Display release context
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -eu

          echo "::group::Release Context"

          echo "üìã **Release Configuration:**"
          echo "   Release Type: ${{ github.event.inputs.release_type }}"
          echo "   Branch: ${{ github.event.inputs.branch }}"
          echo "   Actor: ${{ github.actor }}"
          echo ""

          # Get latest CARTO release
          echo "üì¶ **Latest CARTO Release:**"
          LATEST_RELEASE=$(gh release list --limit 1 --json tagName,publishedAt,name 2>/dev/null | jq -r '.[0] // empty')

          if [ -n "$LATEST_RELEASE" ]; then
            TAG=$(echo "$LATEST_RELEASE" | jq -r '.tagName')
            DATE=$(echo "$LATEST_RELEASE" | jq -r '.publishedAt')
            echo "   Tag: ${TAG}"
            echo "   Published: ${DATE}"
          else
            echo "   No previous CARTO releases found"
          fi
          echo ""

          # Get current pyproject.toml version
          CURRENT_VERSION=$(grep -E "^version\s*=" pyproject.toml | head -1 | sed -E 's/.*"([^"]+)".*/\1/')
          echo "üìã **Current Upstream Version (pyproject.toml):** ${CURRENT_VERSION}"
          echo ""

          # Check for pending upstream sync PRs
          echo "üîÑ **Pending Upstream Sync PRs:**"
          SYNC_PRS=$(gh pr list --label "upstream-sync" --state open --json number,title 2>/dev/null || true)

          if [ -n "$SYNC_PRS" ] && [ "$SYNC_PRS" != "[]" ]; then
            echo "   ‚ö†Ô∏è PENDING UPSTREAM SYNC PRs DETECTED:"
            gh pr list --label "upstream-sync" --state open
            echo ""
            echo "   üí° If you're releasing after merging an upstream sync PR,"
            echo "      make sure you selected release_type='upstream_sync'"
          else
            echo "   ‚úÖ No pending upstream sync PRs"
          fi

          echo "::endgroup::"

      - name: Detect upstream version from pyproject.toml
        id: detect-upstream
        run: |
          # Extract version from pyproject.toml
          UPSTREAM_VERSION=$(grep -E "^version\s*=" pyproject.toml | head -1 | sed -E 's/.*"([^"]+)".*/\1/')
          echo "upstream_version=${UPSTREAM_VERSION}" >> $GITHUB_OUTPUT
          echo "Detected upstream version: ${UPSTREAM_VERSION}"

      - name: Get latest CARTO tag (new format)
        id: get-latest-tag
        run: |
          # Search for new format tags: v{upstream}-carto.X.Y.Z
          # Example: v1.79.1-carto.1.7.1
          LATEST_TAG=$(git tag -l "v*-carto.*" | sort -V | tail -n 1)

          if [ -z "$LATEST_TAG" ]; then
            echo "No new-format tags found - this is the FIRST release with new versioning"
            echo "Will analyze all CARTO commits to calculate initial version"
            echo "latest_tag=" >> $GITHUB_OUTPUT
            echo "current_version=0.0.0" >> $GITHUB_OUTPUT
          else
            echo "Found latest tag: ${LATEST_TAG}"
            echo "latest_tag=${LATEST_TAG}" >> $GITHUB_OUTPUT

            # Extract CARTO version for display (format: v1.79.1-carto.1.7.1 ‚Üí 1.7.1)
            CARTO_VERSION=$(echo "$LATEST_TAG" | sed -E 's/.*-carto\.([0-9]+\.[0-9]+\.[0-9]+)/\1/')
            echo "current_version=${CARTO_VERSION}" >> $GITHUB_OUTPUT
            echo "Current CARTO version: ${CARTO_VERSION}"
          fi

      - name: Calculate next CARTO version
        id: calc-version
        run: |
          UPSTREAM_VERSION="${{ steps.detect-upstream.outputs.upstream_version }}"
          LATEST_TAG="${{ steps.get-latest-tag.outputs.latest_tag }}"

          echo "::group::Calculating CARTO version"

          # Make script executable
          chmod +x .github/scripts/calculate_carto_version.sh

          # Calculate new version using script
          RELEASE_TAG=$(./.github/scripts/calculate_carto_version.sh "${LATEST_TAG}" "${UPSTREAM_VERSION}")

          echo "Calculated release tag: ${RELEASE_TAG}"

          # Extract CARTO version from tag for display
          CARTO_VERSION=$(echo "$RELEASE_TAG" | sed -E 's/.*-carto\.([0-9]+\.[0-9]+\.[0-9]+)/\1/')

          # Use release type from workflow input (explicit, not auto-detected)
          RELEASE_TYPE="${{ github.event.inputs.release_type }}"
          echo "Release type (from input): ${RELEASE_TYPE}"

          if [ "$RELEASE_TYPE" = "upstream_sync" ]; then
            IS_UPSTREAM_SYNC="true"
            # Try to get previous upstream version from last tag for comparison display
            if [ -n "$LATEST_TAG" ]; then
              PREVIOUS_UPSTREAM=$(echo "$LATEST_TAG" | sed -E 's/v([0-9]+\.[0-9]+\.[0-9]+)-carto\..*/\1/')
            else
              PREVIOUS_UPSTREAM="unknown"
            fi
            echo "üîÑ Upstream Sync release (v${PREVIOUS_UPSTREAM} ‚Üí v${UPSTREAM_VERSION})"
          else
            IS_UPSTREAM_SYNC="false"
            PREVIOUS_UPSTREAM="${UPSTREAM_VERSION}"
            if [ "$RELEASE_TYPE" = "feature" ]; then
              echo "‚ú® Feature release (CARTO-specific)"
            else
              echo "üîß Patch release (CARTO-specific)"
            fi
          fi

          # Output variables
          echo "release_tag=${RELEASE_TAG}" >> $GITHUB_OUTPUT
          echo "carto_version=${CARTO_VERSION}" >> $GITHUB_OUTPUT
          echo "is_upstream_sync=${IS_UPSTREAM_SYNC}" >> $GITHUB_OUTPUT
          echo "previous_upstream=${PREVIOUS_UPSTREAM}" >> $GITHUB_OUTPUT
          echo "release_type=${RELEASE_TYPE}" >> $GITHUB_OUTPUT

          echo "::endgroup::"

          echo "üì¶ Release tag: ${RELEASE_TAG}"
          echo "   CARTO version: ${CARTO_VERSION}"
          echo "   Release type: ${RELEASE_TYPE}"
          echo "   Is upstream sync: ${IS_UPSTREAM_SYNC}"

      - name: Generate intelligent release notes with Claude
        id: release-notes
        uses: anthropics/claude-code-action@v1
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          anthropic_api_key: ${{ secrets.ANTHROPIC_API_KEY }}
          show_full_output: false
          claude_args: "--model claude-sonnet-4-5-20250929 --max-turns 50 --allowed-tools Read,Bash,Grep,Glob"
          prompt: |
            # Intelligent Release Notes Generation with Upstream Sync Detection

            ## Your Task
            Generate product-focused release notes for LiteLLM CARTO fork that separates CARTO-specific changes from upstream LiteLLM improvements.

            ## Context
            - **Release Type**: ${{ steps.calc-version.outputs.release_type }} (patch/feature/upstream_sync)
            - **Current Upstream Version**: ${{ steps.detect-upstream.outputs.upstream_version }}
            - **Is Upstream Sync**: ${{ steps.calc-version.outputs.is_upstream_sync }}
            - **Previous Upstream Version**: ${{ steps.calc-version.outputs.previous_upstream }}
            - **CARTO Version**: ${{ steps.calc-version.outputs.carto_version }}
            - **Release Tag**: ${{ steps.calc-version.outputs.release_tag }}
            - **Output File**: `release_notes.md` (create this file)

            ## Step 1: Determine Release Type

            **Release Type:** ${{ steps.calc-version.outputs.release_type }}
            **Is Upstream Sync:** ${{ steps.calc-version.outputs.is_upstream_sync }}

            ```bash
            RELEASE_TYPE="${{ steps.calc-version.outputs.release_type }}"
            if [ "$RELEASE_TYPE" = "upstream_sync" ]; then
              echo "üîÑ UPSTREAM SYNC RELEASE"
              echo "From: v${{ steps.calc-version.outputs.previous_upstream }}"
              echo "To: v${{ steps.detect-upstream.outputs.upstream_version }}"

              # Get upstream releases between versions
              echo "Fetching upstream releases..."
              gh release list --repo BerriAI/litellm --limit 50 | \
                grep "stable" | \
                head -10
            elif [ "$RELEASE_TYPE" = "feature" ]; then
              echo "‚ú® CARTO FEATURE RELEASE"
              echo "Base: LiteLLM v${{ steps.detect-upstream.outputs.upstream_version }}"
            else
              echo "üîß CARTO PATCH RELEASE"
              echo "Base: LiteLLM v${{ steps.detect-upstream.outputs.upstream_version }}"
            fi
            ```

            ## Step 2: Analyze CARTO Commits

            Find the last CARTO release tag and analyze commits since then:

            ```bash
            # Get last CARTO release tag
            LAST_TAG=$(git tag -l "v*-carto.*" | sort -V | tail -n 1)

            if [ -n "$LAST_TAG" ]; then
              echo "Analyzing CARTO commits since ${LAST_TAG}..."
              git log ${LAST_TAG}..HEAD --oneline --no-merges | \
                grep -vE "(sync:|Merge|merge upstream)"
            else
              echo "First CARTO release - analyzing recent commits..."
              git log --oneline --no-merges -30 | \
                grep -vE "(sync:|Merge|merge upstream)"
            fi
            ```

            ## Step 2: Filter Out Non-Product Commits
            **EXCLUDE these types of commits:**
            1. ‚ùå **CI/CD & Workflows**: Changes to `.github/workflows/`, GitHub Actions, CI configurations
               - Examples: "fix: workflow", "ci:", "chore(workflow)", "Add Claude conflict resolution"
            2. ‚ùå **Upstream Sync Automation**: Sync infrastructure, conflict resolution automation
               - Examples: "sync:", "upstream sync", "resolver workflow", "merge upstream"
            3. ‚ùå **Internal Documentation**: CARTO_*.md files, maintainer guides, development docs
               - Examples: "Improve CARTO_CLAUDE.md", "docs: update release process"
            4. ‚ùå **Development Tooling**: Makefile changes, linting configs, dev scripts
               - Examples: "chore: update Makefile", "refactor: improve dev scripts"

            **INCLUDE these types of commits:**
            1. ‚úÖ **Bug Fixes**: Fixes to LiteLLM core functionality, proxy, providers
               - Look for: "fix:", "bugfix:", fixes to `litellm/`, `proxy/`
            2. ‚úÖ **Features**: New LiteLLM features, provider support, API improvements
               - Look for: "feat:", "feature:", new capabilities for end-users
            3. ‚úÖ **Breaking Changes**: Changes that affect API, configuration, behavior
               - Look for: "BREAKING CHANGE:", "breaking:", changes to public APIs
            4. ‚úÖ **Cherry-picks from Upstream**: Important upstream fixes merged into CARTO
               - Look for: "cherry-pick", "[sc-XXXXX]" with LiteLLM functionality changes

            ## Step 3: Analyze Each Commit
            For each commit:
            1. Read the commit message
            2. If needed, check what files were changed: `git show --name-only <commit-hash>`
            3. Determine if it's product-relevant (affects LiteLLM functionality for users)
            4. If yes, categorize it: Feature / Bug Fix / Breaking Change / Security

            ## Step 4: Generate Markdown Release Notes

            **IF UPSTREAM SYNC DETECTED** (first release for this upstream version), use this structure:

            ```markdown
            ## üöÄ CARTO Release for LiteLLM v${{ steps.detect-upstream.outputs.upstream_version }}

            **Base Version:** LiteLLM v${{ steps.detect-upstream.outputs.upstream_version }} (synced from v{previous_version})

            ### üîÑ Upstream Sync

            This release includes a **major upstream sync** from LiteLLM v{previous} to v{current}.

            **Upstream Releases Included:**
            - [v{version}-stable](link) ({date}) - [Brief summary of key changes]
            - [v{version}-stable](link) ({date}) - [Brief summary of key changes]

            **Compare Upstream Changes:**
            - [v{previous}-stable...v{current}-stable](comparison_link)

            **Key Upstream Improvements:**
            - **Category**: Brief description of major upstream changes
            - **Category**: Another major upstream improvement
            - *For full upstream changes, see the links above*

            **Sync Strategy:**
            - ‚úÖ Preserved all CARTO customizations
            - ‚úÖ Accepted all upstream core improvements
            - ‚úÖ Resolved conflicts favoring CARTO infrastructure + upstream functionality

            ### ‚ú® CARTO-Specific Features
            - [Only CARTO-developed features, if any]
            - *Or: No CARTO-specific features in this release*

            ### üêõ CARTO-Specific Bug Fixes
            - [Only CARTO-developed fixes, if any]
            - *Or: No CARTO-specific fixes in this release*

            ### üîí Security
            - [CARTO-specific security changes, if any]
            - *Or: No CARTO-specific security changes. All upstream security fixes included.*

            ### ‚ö†Ô∏è Breaking Changes
            - [CARTO-specific breaking changes, if any]
            - *Or: No CARTO-specific breaking changes. See upstream release notes for upstream breaking changes.*

            ---
            *This release includes upstream sync + X CARTO-specific changes. Infrastructure and CI changes are not listed.*
            ```

            **IF REGULAR CARTO RELEASE** (not first release for this upstream version), use this structure:

            ```markdown
            ## üöÄ CARTO Release for LiteLLM v${{ steps.detect-upstream.outputs.upstream_version }}

            **Base Version:** LiteLLM v${{ steps.detect-upstream.outputs.upstream_version }}

            ### ‚ú® Features
            - [Brief description of feature]

            ### üêõ Bug Fixes
            - [Brief description of fix]

            ### üîí Security
            - [If any security-related changes]

            ### ‚ö†Ô∏è Breaking Changes
            - [If any breaking changes]

            ---
            *This release includes X product-relevant changes. Infrastructure and CI changes are not listed here.*
            ```

            ## Important Guidelines

            ### General Guidelines
            1. **Be concise but clear**: Each bullet should explain WHAT changed and WHY it matters to users
            2. **Group related changes**: If multiple commits fix the same issue, combine into one bullet
            3. **Skip internal details**: Don't mention workflow files, CI configs, documentation updates for maintainers
            4. **Add context**: Transform raw commit messages into user-friendly descriptions
            5. **Empty sections**: If no features/fixes, write "No changes in this category"

            ### Upstream Sync Guidelines
            6. **Separate CARTO from upstream**: Clearly distinguish CARTO-developed changes from upstream improvements
            7. **Summarize upstream changes**: Don't list every upstream commit - provide high-level categories (e.g., "New provider support", "Performance improvements")
            8. **Link to upstream releases**: Always include links to upstream release notes for full details
            9. **Highlight key upstream features**: Mention 2-3 most important upstream improvements that affect users
            10. **Cherry-picks**: If CARTO cherry-picked specific upstream fixes before the sync, mention them in CARTO-Specific section

            ## Example Transformations

            ### Upstream Sync Example:
            ‚ùå BAD: "Merged upstream v1.79.1"
            ‚úÖ GOOD:
            ```
            ### üîÑ Upstream Sync
            This release includes a major upstream sync from LiteLLM v1.75.2 to v1.79.1.

            **Upstream Releases Included:**
            - [v1.78.5-stable](link) (2025-10-26) - Performance improvements and bug fixes
            - [v1.79.0-stable](link) (2025-11-01) - New provider support for Anthropic Claude 3.5
            - [v1.79.1-stable](link) (2025-11-08) - Security updates and stability improvements

            **Key Upstream Improvements:**
            - **New Providers**: Added support for Anthropic Claude 3.5 Sonnet and Haiku models
            - **Performance**: 30% faster response times for streaming endpoints
            - **Bug Fixes**: Resolved 45+ issues including token counting accuracy and rate limiting
            ```

            ### CARTO-Specific Change Example:
            ‚ùå BAD (raw commit): "fix: cherry-pick upstream metadata None check [sc-521238]"
            ‚úÖ GOOD (user-friendly): "Fixed crash when LiteLLM proxy encounters null metadata in Vertex AI provider responses (cherry-picked from upstream)"

            ### Exclusion Example:
            ‚ùå BAD (should exclude): "feat: create separate CI fixer workflow with upstream test check"
            ‚úÖ GOOD (excluded): Not included in release notes (CI infrastructure change)

            ## Output
            Write the final release notes to `release_notes.md` and confirm it was created successfully.

            **Start now!**
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        timeout-minutes: 20

      - name: Create Git tag
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git tag -a "${{ steps.calc-version.outputs.release_tag }}" -m "Release ${{ steps.calc-version.outputs.release_tag }}"
          git push origin "${{ steps.calc-version.outputs.release_tag }}"

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v1
        with:
          tag_name: ${{ steps.calc-version.outputs.release_tag }}
          name: ${{ steps.calc-version.outputs.release_tag }}
          body_path: release_notes.md
          draft: false
          prerelease: false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Log in to Container registry
        uses: docker/login-action@65b78e6e13532edd9afa3aa52ac7964289d1a9c1
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Set up QEMU
        uses: docker/setup-qemu-action@e0e4588fad221d38ee467c0bffd91115366dc0c5

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@edfb0fe6204400c56fbfd3feba3fe9ad1adfa345

      - name: Extract metadata for Docker
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}-non_root
          tags: |
            type=raw,value=${{ steps.calc-version.outputs.release_tag }}
            type=raw,value=carto-stable
            type=raw,value=carto-v${{ steps.detect-upstream.outputs.upstream_version }}-latest

      - name: Build and push Docker image
        uses: docker/build-push-action@f2a1d5e99d037542a71f64918e516c093c6f3fc4
        with:
          context: .
          file: ./docker/Dockerfile.non_root
          push: true
          cache-from: type=gha
          cache-to: type=gha,mode=max
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          platforms: linux/amd64

      - name: Release Summary
        run: |
          echo "## üéâ Release Created Successfully!" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Upstream Version:** \`${{ steps.detect-upstream.outputs.upstream_version }}\`" >> $GITHUB_STEP_SUMMARY
          echo "**Tag:** \`${{ steps.calc-version.outputs.release_tag }}\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### üìù Release Notes" >> $GITHUB_STEP_SUMMARY
          echo "Release notes were generated using Claude Code AI analysis." >> $GITHUB_STEP_SUMMARY
          echo "Only product-relevant changes are included (CI/CD and infrastructure changes excluded)." >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### üê≥ Docker Tags" >> $GITHUB_STEP_SUMMARY
          echo "- \`ghcr.io/${{ env.IMAGE_NAME }}-non_root:${{ steps.calc-version.outputs.release_tag }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- \`ghcr.io/${{ env.IMAGE_NAME }}-non_root:carto-stable\`" >> $GITHUB_STEP_SUMMARY
          echo "- \`ghcr.io/${{ env.IMAGE_NAME }}-non_root:carto-v${{ steps.detect-upstream.outputs.upstream_version }}-latest\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### üîí Security" >> $GITHUB_STEP_SUMMARY
          echo "- ‚úÖ Actor authorization verified" >> $GITHUB_STEP_SUMMARY
          echo "- ‚úÖ Claude Code used read-only tools" >> $GITHUB_STEP_SUMMARY
          echo "- ‚úÖ Rate limited (max 50 turns, 20-min timeout)" >> $GITHUB_STEP_SUMMARY

      - name: Notify Slack of new release
        if: success()
        env:
          SLACK_CHANNEL: "C09K0M5MP7V" # cartodb-ops
        run: |
          set -eu

          echo "::group::Preparing Slack notification"

          # Check if SLACK_KEY secret is configured
          if [[ -z "${{ secrets.SLACK_KEY }}" ]]; then
            echo "::warning::SLACK_KEY secret not configured - skipping notification"
            echo "::endgroup::"
            exit 0
          fi

          # Prepare notification data
          RELEASE_TAG="${{ steps.calc-version.outputs.release_tag }}"
          CARTO_VERSION="${{ steps.calc-version.outputs.carto_version }}"
          UPSTREAM_VERSION="${{ steps.detect-upstream.outputs.upstream_version }}"
          RELEASE_TYPE="${{ steps.calc-version.outputs.release_type }}"
          PREVIOUS_UPSTREAM="${{ steps.calc-version.outputs.previous_upstream }}"
          RELEASE_URL="https://github.com/${{ github.repository }}/releases/tag/${RELEASE_TAG}"
          DOCKER_IMAGE="ghcr.io/${{ github.repository }}-non_root:carto-stable"

          # Determine release type label and emoji
          case "$RELEASE_TYPE" in
            upstream_sync)
              TYPE_LABEL="Upstream Sync"
              VERSION_CHANGE="v${PREVIOUS_UPSTREAM} ‚Üí v${UPSTREAM_VERSION}"
              EMOJI=":arrows_counterclockwise:"
              ;;
            feature)
              TYPE_LABEL="Feature Release"
              VERSION_CHANGE=""
              EMOJI=":sparkles:"
              ;;
            patch)
              TYPE_LABEL="Patch Release"
              VERSION_CHANGE=""
              EMOJI=":wrench:"
              ;;
            *)
              TYPE_LABEL="Release"
              VERSION_CHANGE=""
              EMOJI=":rocket:"
              ;;
          esac

          # Extract key highlights from release notes (first 3 bullet points from Features/Fixes sections)
          HIGHLIGHTS=""
          if [ -f "release_notes.md" ]; then
            # Get CARTO-specific features and fixes (limit to 3 most important)
            FEATURES=$(grep -A 5 "### ‚ú®" release_notes.md 2>/dev/null | grep "^-" | head -2 | sed 's/^- /‚Ä¢ /' || echo "")
            FIXES=$(grep -A 5 "### üêõ" release_notes.md 2>/dev/null | grep "^-" | head -1 | sed 's/^- /‚Ä¢ /' || echo "")

            if [ -n "$FEATURES" ] || [ -n "$FIXES" ]; then
              HIGHLIGHTS=$'\n\n*Key Highlights:*\n'
              [ -n "$FEATURES" ] && HIGHLIGHTS+="${FEATURES}"$'\n'
              [ -n "$FIXES" ] && HIGHLIGHTS+="${FIXES}"
            fi
          fi

          # Build concise Slack message
          MESSAGE="‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
          ${EMOJI} *LiteLLM CARTO Release* \`${RELEASE_TAG}\`
          ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

          :label: *Type:* ${TYPE_LABEL}${VERSION_CHANGE:+ ($VERSION_CHANGE)}
          :package: *CARTO Version:* ${CARTO_VERSION}
          :gear: *Upstream Base:* LiteLLM v${UPSTREAM_VERSION}${HIGHLIGHTS}

          :link: <${RELEASE_URL}|View Release Notes>
          :whale: \`${DOCKER_IMAGE}\`"

          echo "[Slack] Sending notification to channel ${SLACK_CHANNEL}"
          echo "::endgroup::"

          echo "::group::Posting to Slack"

          # Retry logic (up to 3 attempts)
          SUCCESS=false
          for attempt in 1 2 3; do
            echo "[Slack] Attempt ${attempt}/3..."

            # Send to Slack API
            RESPONSE=$(curl -s -w "\n%{http_code}" \
              -F "text=${MESSAGE}" \
              -F "channel=${SLACK_CHANNEL}" \
              -H "Authorization: Bearer ${{ secrets.SLACK_KEY }}" \
              -X POST https://slack.com/api/chat.postMessage)

            # Extract HTTP code and body
            HTTP_CODE=$(echo "$RESPONSE" | tail -n1)
            BODY=$(echo "$RESPONSE" | head -n-1)

            echo "[Slack] HTTP ${HTTP_CODE}"
            echo "[Slack] Response: ${BODY}"

            # Check if successful
            if [ "$HTTP_CODE" = "200" ]; then
              # Check Slack API response
              if echo "$BODY" | grep -q '"ok":true'; then
                echo "‚úÖ [Slack] Release notification sent successfully"
                SUCCESS=true
                break
              else
                ERROR=$(echo "$BODY" | grep -o '"error":"[^"]*"' || echo "unknown error")
                echo "‚ö†Ô∏è [Slack] Slack API error: ${ERROR}"
              fi
            else
              echo "‚ö†Ô∏è [Slack] HTTP error: ${HTTP_CODE}"
            fi

            # Wait before retry
            if [ $attempt -lt 3 ]; then
              echo "[Slack] Retrying in 5 seconds..."
              sleep 5
            fi
          done

          if [ "$SUCCESS" = "false" ]; then
            echo "::error::Failed to send Slack notification after 3 attempts"
            echo "::notice::Check SLACK_KEY secret and channel permissions"
          fi

          echo "::endgroup::"
