################################################################################
# CARTO - Upstream Sync
################################################################################

# This workflow automatically syncs CARTO's LiteLLM fork with upstream stable
# releases from BerriAI/litellm.
#
# Branch Strategy:
#   1. BerriAI/litellm:main -> CartoDB/litellm:main (direct push with PAT)
#   2. CartoDB/litellm:main -> CartoDB/litellm:carto/main (PR for manual review)
#
# The workflow runs every Monday at noon and performs two checks:
#   - Detects new stable releases (tagged with -stable suffix) and syncs main
#   - Creates PR to carto/main if carto/main is behind main (regardless of upstream sync)
#
# Uses X_GITHUB_SUPERCARTOFANTE token to allow workflow file modifications.

name: CARTO - Upstream Sync # do not change the name since is referenced in the ci-fixer workflow

permissions:
  contents: write        # Allow push to main branch and modify files (including workflows)
  pull-requests: write   # Allow PR creation and management

on:
  schedule:
    - cron: "0 12 * * 1"  # Every Monday at noon (12:00 UTC)

  workflow_dispatch:  # Manual trigger for testing

jobs:
  ##############################################################################
  # Check for New Release
  ##############################################################################

  check-new-release:
    runs-on: ubuntu-latest
    name: "Check for new upstream release"
    outputs:
      has-new-release: ${{ steps.detect-release.outputs.has-new-release }}
      new-version: ${{ steps.detect-release.outputs.new-version }}
      current-version: ${{ steps.detect-release.outputs.current-version }}
    steps:
      # Checkout carto/main to check what version we currently have in production
      # NOT main (which has unstable upstream dev code that's always ahead of stable)
      - name: Checkout carto/main branch
        uses: actions/checkout@v4
        with:
          ref: carto/main
          fetch-depth: 0

      - name: Add upstream remote
        run: |
          set -eu
          git remote add upstream https://github.com/BerriAI/litellm.git || true
          git fetch upstream --tags

      - name: Detect new stable release (bash + gh CLI)
        id: detect-release
        env:
          GH_TOKEN: ${{ secrets.X_GITHUB_SUPERCARTOFANTE }}
        run: |
          set -eu

          echo "::group::Detecting new stable releases"
          echo "[Sync] Using gh CLI to fetch releases from BerriAI/litellm..."

          # Get current version from carto/main's pyproject.toml
          # This is the version currently deployed in production
          CURRENT_VERSION=$(grep -E "^version\s*=" pyproject.toml | head -1 | sed -E 's/.*"([^"]+)".*/\1/')
          echo "[Sync] Current version in carto/main pyproject.toml: ${CURRENT_VERSION}"

          # Get latest stable release tag (ends with -stable, not a prerelease)
          LATEST_STABLE=$(gh release list --repo BerriAI/litellm --limit 50 --json tagName,isPrerelease,isDraft | \
            jq -r '.[] | select(.isPrerelease == false and .isDraft == false and (.tagName | endswith("-stable"))) | .tagName' | \
            sort -V | tail -1)

          if [[ -z "${LATEST_STABLE}" ]]; then
            echo "[Sync] No stable releases found in upstream"
            echo "has-new-release=false" >> $GITHUB_OUTPUT
            echo "::endgroup::"
            exit 0
          fi

          echo "[Sync] Latest upstream stable release: ${LATEST_STABLE}"

          # Extract version from tag (remove 'v' prefix and '-stable' suffix)
          # e.g., v1.78.5-stable -> 1.78.5
          LATEST_VERSION=$(echo "${LATEST_STABLE}" | sed -E 's/^v//; s/-stable$//')

          echo "[Sync] Latest version: ${LATEST_VERSION}"
          echo "[Sync] Current version: ${CURRENT_VERSION}"

          # Compare versions (simple string comparison works for semver)
          if [[ "${LATEST_VERSION}" > "${CURRENT_VERSION}" ]]; then
            echo "[Sync] ‚úÖ New stable release available: ${LATEST_STABLE}"
            echo "has-new-release=true" >> $GITHUB_OUTPUT
            echo "new-version=${LATEST_STABLE}" >> $GITHUB_OUTPUT
            echo "current-version=${CURRENT_VERSION}" >> $GITHUB_OUTPUT
            echo "::notice title=New Release Detected::${LATEST_STABLE} (current: ${CURRENT_VERSION})"
          else
            echo "[Sync] ‚úÖ Already on latest stable: ${CURRENT_VERSION}"
            echo "has-new-release=false" >> $GITHUB_OUTPUT
          fi

          echo "::endgroup::"

  ##############################################################################
  # Sync main branch with upstream
  ##############################################################################

  sync-main-branch:
    runs-on: ubuntu-latest
    name: "Sync main with upstream"
    needs:
      - check-new-release
    if: needs.check-new-release.outputs.has-new-release == 'true'
    steps:
      - name: Checkout main branch
        uses: actions/checkout@v4
        with:
          ref: main
          fetch-depth: 0
          token: ${{ secrets.X_GITHUB_SUPERCARTOFANTE }}

      - name: Configure Git
        run: |
          set -eu
          git config --global user.email "cartofante@carto.com"
          git config --global user.name "Cartofante"

      - name: Sync main with upstream/main
        env:
          NEW_VERSION: ${{ needs.check-new-release.outputs.new-version }}
        run: |
          set -eu

          echo "::group::Syncing main branch with upstream"
          echo "[Sync] main should be a mirror of upstream - merging with proper history preservation"

          # Add upstream remote
          git remote add upstream https://github.com/BerriAI/litellm.git || true
          git fetch upstream --tags

          # Merge upstream/main while preserving upstream commit history
          echo "[Sync] Merging upstream/main with -X theirs strategy (preserves commit history)..."

          # Use merge strategy that accepts all upstream changes on conflict
          # This preserves the full commit history with original SHAs
          git merge upstream/main --no-edit -X theirs -m "sync: merge upstream/main for ${NEW_VERSION}

          Automatic sync from upstream BerriAI/litellm
          Preparing for ${NEW_VERSION} release

          Strategy: Merge with history preservation (main mirrors upstream)"

          if [ $? -eq 0 ]; then
            echo "[Sync] ‚úÖ Merge successful with preserved history"
          else
            # If -X theirs still has conflicts, use more aggressive approach
            echo "[Sync] ‚ö†Ô∏è Conflicts detected, resolving by accepting all upstream changes..."

            # Get list of conflicted files
            CONFLICTS=$(git diff --name-only --diff-filter=U)

            if [ -n "$CONFLICTS" ]; then
              echo "[Sync] Resolving conflicts in files:"
              echo "$CONFLICTS"

              # For each conflicted file, accept upstream version
              echo "$CONFLICTS" | while read -r file; do
                echo "  - Accepting upstream version of: $file"
                git checkout --theirs "$file"
                git add "$file"
              done

              # Complete the merge commit
              git commit --no-edit -m "sync: merge upstream/main for ${NEW_VERSION}

          Automatic sync from upstream BerriAI/litellm
          Preparing for ${NEW_VERSION} release

          Strategy: Merge with manual conflict resolution (accepted all upstream changes)"

              echo "[Sync] ‚úÖ Conflicts resolved, merge completed with preserved history"
            else
              echo "[Sync] ‚ùå Merge failed with no conflicts detected - manual intervention needed"
              exit 1
            fi
          fi

          # Push to origin/main (should always be fast-forward with proper merge)
          echo "[Sync] Pushing updated main branch to origin..."
          git push origin main

          echo "[Sync] ‚úÖ main branch synced successfully with preserved upstream commit history"
          echo "::endgroup::"

  ##############################################################################
  # Check if carto/main needs sync from main
  ##############################################################################

  check-carto-main-sync:
    runs-on: ubuntu-latest
    name: "Check if carto/main needs sync"
    needs:
      - sync-main-branch
    if: always() && (needs.sync-main-branch.result == 'success' || needs.sync-main-branch.result == 'skipped')
    outputs:
      needs-sync: ${{ steps.check-sync.outputs.needs-sync }}
      commits-behind: ${{ steps.check-sync.outputs.commits-behind }}
      pr-exists: ${{ steps.check-pr.outputs.pr-exists }}
      pr-url: ${{ steps.check-pr.outputs.pr-url }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Check if carto/main is behind main
        id: check-sync
        run: |
          set -eu

          echo "::group::Checking if carto/main needs sync from main"

          # Fetch both branches
          git fetch origin main
          git fetch origin carto/main

          # Count commits that carto/main is behind main
          COMMITS_BEHIND=$(git rev-list --count origin/carto/main..origin/main 2>/dev/null || echo "0")

          echo "[Sync] carto/main is ${COMMITS_BEHIND} commits behind main"

          if [[ "${COMMITS_BEHIND}" -gt 0 ]]; then
            echo "[Sync] ‚úÖ carto/main needs sync (${COMMITS_BEHIND} commits behind)"
            echo "needs-sync=true" >> $GITHUB_OUTPUT
            echo "commits-behind=${COMMITS_BEHIND}" >> $GITHUB_OUTPUT
            echo "::notice title=Sync Needed::carto/main is ${COMMITS_BEHIND} commits behind main"
          else
            echo "[Sync] ‚úÖ carto/main is up to date with main"
            echo "needs-sync=false" >> $GITHUB_OUTPUT
            echo "commits-behind=0" >> $GITHUB_OUTPUT
          fi

          echo "::endgroup::"

      - name: Check for existing PR from upstream-sync branch to carto/main
        id: check-pr
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -eu

          echo "::group::Checking for existing PR"
          echo "[Sync] Looking for open upstream-sync PR to carto/main..."

          # Check if PR exists with upstream-sync label targeting carto/main
          # Head branch pattern: upstream-sync/* (e.g., upstream-sync/v1.79.3-stable)
          PR_URL=$(gh pr list \
            --repo CartoDB/litellm \
            --base carto/main \
            --label upstream-sync \
            --state open \
            --json url,headRefName \
            --jq '.[] | select(.headRefName | startswith("upstream-sync/")) | .url' 2>/dev/null | head -1 || echo "")

          if [[ -n "${PR_URL}" ]]; then
            echo "[Sync] PR already exists: ${PR_URL}"
            echo "pr-exists=true" >> $GITHUB_OUTPUT
            echo "pr-url=${PR_URL}" >> $GITHUB_OUTPUT
            echo "::notice title=PR Already Exists::${PR_URL}"
          else
            echo "[Sync] No existing PR found"
            echo "pr-exists=false" >> $GITHUB_OUTPUT
          fi

          echo "::endgroup::"

  ##############################################################################
  # Create Sync PR (main -> carto/main)
  ##############################################################################

  create-sync-pr:
    runs-on: ubuntu-latest
    name: "Create sync PR to carto/main"
    needs:
      - check-new-release
      - check-carto-main-sync
    if: needs.check-carto-main-sync.outputs.needs-sync == 'true' && needs.check-carto-main-sync.outputs.pr-exists == 'false'
    outputs:
      pr-url: ${{ steps.create-pr.outputs.pr-url }}
      sync-branch: ${{ steps.create-sync-branch.outputs.branch-name }}
    steps:
      - name: Checkout main branch
        uses: actions/checkout@v4
        with:
          ref: main
          fetch-depth: 0
          token: ${{ secrets.X_GITHUB_SUPERCARTOFANTE }}

      - name: Configure Git
        run: |
          git config --global user.email "cartofante@carto.com"
          git config --global user.name "Cartofante"

      - name: Create sync branch from main
        id: create-sync-branch
        env:
          NEW_VERSION: ${{ needs.check-new-release.outputs.new-version }}
        run: |
          set -eu

          echo "::group::Creating sync branch from main"

          # Create a dedicated sync branch that we can push conflict resolutions to
          # Format: upstream-sync/vX.Y.Z-stable (e.g., upstream-sync/v1.79.3-stable)
          BRANCH_NAME="upstream-sync/${NEW_VERSION}"

          echo "[Sync] Creating branch: ${BRANCH_NAME}"
          git checkout -b "${BRANCH_NAME}"

          # Push the branch to origin
          git push -u origin "${BRANCH_NAME}"

          echo "branch-name=${BRANCH_NAME}" >> $GITHUB_OUTPUT
          echo "[Sync] ‚úÖ Created and pushed branch: ${BRANCH_NAME}"
          echo "::endgroup::"

      - name: Generate PR body
        id: generate-pr-body
        env:
          NEW_VERSION: ${{ needs.check-new-release.outputs.new-version }}
          CURRENT_VERSION: ${{ needs.check-new-release.outputs.current-version }}
        run: |
          set -eu

          echo "::group::[Sync] Generating PR body"

          PR_BODY_FILE="sync-pr-body.md"

          # Extract version without v prefix and -stable suffix for comparison
          NEW_VERSION_CLEAN=$(echo "${NEW_VERSION}" | sed -E 's/^v//; s/-stable$//')

          # Count commits between current and new version
          git fetch origin carto/main
          COMMITS_COUNT=$(git rev-list --count origin/carto/main..main 2>/dev/null || echo "unknown")
          FILES_CHANGED=$(git diff --name-only origin/carto/main..main | wc -l | tr -d ' ')

          # Create PR body
          cat > ${PR_BODY_FILE} << EOF
          ## üîÑ Upstream Sync: LiteLLM ${NEW_VERSION}

          Syncs CARTO's LiteLLM fork with upstream stable release **${NEW_VERSION}**.

          | Metric | Value |
          |--------|-------|
          | **Version** | \`${CURRENT_VERSION}\` ‚Üí \`${NEW_VERSION}\` |
          | **Commits** | ${COMMITS_COUNT} |
          | **Files Changed** | ${FILES_CHANGED} |
          | **Upstream Release** | [${NEW_VERSION}](https://github.com/BerriAI/litellm/releases/tag/${NEW_VERSION}) |

          > [!CAUTION]
          > **‚ö†Ô∏è DO NOT SQUASH MERGE THIS PR**
          >
          > Use **"Create a merge commit"** only. Squashing destroys upstream history and breaks future syncs.

          ---

          ### üß™ Pre-Merge Checklist

          - [ ] CI checks pass (lint, tests, Docker build)
          - [ ] CARTO customizations preserved
          - [ ] \`pyproject.toml\` version matches upstream

          ---

          <details>
          <summary>üìä Release Information (click to expand)</summary>

          - **Upstream Version:** \`${NEW_VERSION}\`
          - **Current Version:** \`${CURRENT_VERSION}\`
          - **Commits Ahead:** ${COMMITS_COUNT}
          - **Files Changed:** ${FILES_CHANGED}
          - **Upstream Repo:** [BerriAI/litellm](https://github.com/BerriAI/litellm)
          - **Compare Changes:** [v${CURRENT_VERSION}-stable...${NEW_VERSION}](https://github.com/BerriAI/litellm/compare/v${CURRENT_VERSION}-stable...${NEW_VERSION})

          </details>

          <details>
          <summary>üîÄ Branch Flow (click to expand)</summary>

          1. ‚úÖ \`BerriAI/litellm:main\` merged into \`CartoDB/litellm:main\`
          2. ‚úÖ Created dedicated sync branch: \`upstream-sync/${NEW_VERSION}\`
          3. üìù This PR: \`upstream-sync/${NEW_VERSION}\` ‚Üí \`carto/main\`

          > [!NOTE]
          > **Why a dedicated branch?** Allows pushing conflict resolution commits directly to this PR.

          </details>

          <details>
          <summary>üìù CARTO-Specific File Guidelines (click to expand)</summary>

          When reviewing or resolving conflicts:

          #### ‚úÖ Keep CARTO Versions (Ours)
          - \`.github/workflows/carto_*.yaml\` - CARTO workflows
          - \`.github/workflows/carto-*.yml\` - CARTO workflows
          - \`CARTO_*.md\`, \`docs/CARTO_*.md\` - CARTO documentation

          #### üîÑ Accept Upstream (Theirs)
          - \`pyproject.toml\` - Version field
          - \`litellm/\` - Core library code
          - \`tests/\` - Upstream tests
          - \`requirements.txt\` - Dependencies

          #### ‚ö†Ô∏è Manual Review Required
          - \`Dockerfile\`, \`docker/Dockerfile.non_root\` - CARTO customizations
          - \`Makefile\` - Check \`# CARTO:\` sections

          </details>

          <details>
          <summary>üîß Conflict Resolution (click to expand)</summary>

          **If this PR has conflicts:**

          #### Option 1: Automated (Recommended)

          The [carto-upstream-sync-resolver](https://github.com/CartoDB/litellm/actions/workflows/carto-upstream-sync-resolver.yml) workflow triggers automatically.

          **What it does:**
          1. ü§ñ Detects conflicts ‚Üí üîÄ Merges \`carto/main\` ‚Üí ‚úèÔ∏è Resolves conflicts ‚Üí üß™ Runs tests ‚Üí üìå Pushes to this PR

          **You just need to:** Wait for resolution commits, verify CARTO customizations, merge.

          > [!TIP]
          > **Single PR workflow!** No separate resolution PR needed.

          #### Option 2: Manual Resolution

          \`\`\`bash
          git fetch origin
          git checkout upstream-sync/${NEW_VERSION}
          git merge origin/carto/main  # Creates conflicts
          # ... resolve conflicts ...
          make lint && make test-unit
          git push origin upstream-sync/${NEW_VERSION}
          \`\`\`

          </details>

          <details>
          <summary>üìö Documentation Links (click to expand)</summary>

          - [CARTO Release Process](./docs/CARTO_RELEASE_PROCESS.md)
          - [CARTO Customizations](./CARTO_CLAUDE.md)

          </details>

          ---

          *ü§ñ This PR was automatically created by the [carto-upstream-sync workflow](https://github.com/CartoDB/litellm/actions/workflows/carto-upstream-sync.yml).*
          EOF

          echo "[Sync] PR body generated successfully"
          echo "::endgroup::"

      - name: Create Pull Request
        id: create-pr
        env:
          NEW_VERSION: ${{ needs.check-new-release.outputs.new-version }}
          SYNC_BRANCH: ${{ steps.create-sync-branch.outputs.branch-name }}
          GH_TOKEN: ${{ secrets.X_GITHUB_SUPERCARTOFANTE }}
        run: |
          set -eu

          echo "::group::Creating Pull Request"

          PR_BODY_FILE="sync-pr-body.md"

          # Create PR from sync branch to carto/main
          # Using dedicated branch (not main) allows pushing conflict resolution commits
          PR_URL=$(gh pr create \
            --repo CartoDB/litellm \
            --base carto/main \
            --head "${SYNC_BRANCH}" \
            --title "üîÑ Upstream Sync: LiteLLM ${NEW_VERSION}" \
            --body-file ${PR_BODY_FILE} \
            --label "upstream-sync" \
            --label "automated")

          echo "[Sync] Pull Request created: ${PR_URL}"
          echo "pr-url=${PR_URL}" >> $GITHUB_OUTPUT
          echo "::notice title=PR Created::${PR_URL}"

          echo "::endgroup::"

          # GitHub Actions summary
          echo "::group::Workflow Summary"
          cat >> $GITHUB_STEP_SUMMARY << EOF
          ## üéâ Upstream Sync PR Created Successfully

          - **PR URL:** ${PR_URL}
          - **Version:** ${NEW_VERSION}
          - **Branch Flow:** main ‚Üí carto/main

          ### Next Steps
          1. Review the PR for any conflicts or issues
          2. Run tests: \`make lint && make test-unit\`
          3. Approve and merge when ready
          EOF
          echo "::endgroup::"

      - name: Check conflicts and trigger resolver
        if: steps.create-pr.outputs.pr-url != ''
        env:
          GH_TOKEN: ${{ secrets.X_GITHUB_SUPERCARTOFANTE }}
        run: |
          set -eu

          echo "::group::Checking PR for conflicts"

          # Wait for GitHub to compute mergeable status
          sleep 15

          PR_NUMBER=$(echo "${{ steps.create-pr.outputs.pr-url }}" | grep -oE '[0-9]+$')
          echo "[Sync] Checking PR #${PR_NUMBER} for conflicts..."

          # Get mergeable status (may need retries as GitHub computes it)
          for i in {1..3}; do
            MERGEABLE=$(gh pr view ${PR_NUMBER} --repo ${{ github.repository }} --json mergeable --jq '.mergeable')
            if [[ "${MERGEABLE}" != "UNKNOWN" ]]; then
              break
            fi
            echo "[Sync] Waiting for mergeable status (attempt ${i}/3)..."
            sleep 10
          done

          echo "[Sync] Mergeable status: ${MERGEABLE}"

          if [[ "${MERGEABLE}" == "CONFLICTING" ]]; then
            echo "[Sync] ‚ö†Ô∏è PR has conflicts - triggering resolver workflow"
            gh workflow run carto-upstream-sync-resolver.yml \
              --repo ${{ github.repository }} \
              -f pr-number=${PR_NUMBER}
            echo "[Sync] ‚úÖ Resolver workflow dispatched for PR #${PR_NUMBER}"
            echo "::notice title=Resolver Triggered::Conflicts detected, resolver workflow started"
          else
            echo "[Sync] ‚úÖ PR is clean (status: ${MERGEABLE}) - no resolver needed"
          fi

          echo "::endgroup::"

  ##############################################################################
  # Notify Slack
  ##############################################################################

  notify-slack:
    runs-on: ubuntu-latest
    name: "Notify Slack"
    if: always()
    needs:
      - check-new-release
      - sync-main-branch
      - check-carto-main-sync
      - create-sync-pr
    steps:
      - name: Send Slack notification
        env:
          SLACK_CHANNEL: "C09K0M5MP7V" # cartodb-ops
          HAS_NEW_RELEASE: ${{ needs.check-new-release.outputs.has-new-release }}
          NEW_VERSION: ${{ needs.check-new-release.outputs.new-version }}
          NEEDS_SYNC: ${{ needs.check-carto-main-sync.outputs.needs-sync }}
          COMMITS_BEHIND: ${{ needs.check-carto-main-sync.outputs.commits-behind }}
          PR_EXISTS: ${{ needs.check-carto-main-sync.outputs.pr-exists }}
          EXISTING_PR_URL: ${{ needs.check-carto-main-sync.outputs.pr-url }}
          NEW_PR_URL: ${{ needs.create-sync-pr.outputs.pr-url }}
          SYNC_STATUS: ${{ needs.sync-main-branch.result }}
        run: |
          set -eu

          echo "::group::Determining Slack notification"

          # Skip if channel not configured
          if [[ -z "${SLACK_CHANNEL}" ]]; then
            echo "[Slack] SLACK_CHANNEL not configured, skipping notification"
            echo "::endgroup::"
            exit 0
          fi

          # Determine message based on workflow results
          WORKFLOW_RUN_URL="https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}"

          # Build message based on what happened
          # Using bash $'...' syntax to properly interpret \n as newlines
          case "${NEEDS_SYNC}:${PR_EXISTS}" in
            true:false)
              if [[ -n "${NEW_PR_URL}" ]]; then
                if [[ "${HAS_NEW_RELEASE}" == "true" ]]; then
                  # Extract clean version from NEW_VERSION (remove v prefix and -stable suffix)
                  NEW_VERSION_CLEAN=$(echo "${NEW_VERSION}" | sed -E 's/^v//; s/-stable$//')
                  MESSAGE=$':white_check_mark: *LiteLLM Upstream Sync*\n\n*Version Upgrade:* `v'"${CURRENT_VERSION}"$'` ‚Üí `v'"${NEW_VERSION_CLEAN}"$'`\n\n*Action Required:* Review and merge sync PR\n\n‚Ä¢ PR: '"${NEW_PR_URL}"$'\n\n_LiteLLM is the unified LLM proxy for 100+ providers used by CARTO for all AI features_'
                else
                  MESSAGE=$':white_check_mark: *LiteLLM Upstream Sync*\n\n*PR Created*\n\n*Action Required:* Review and merge sync PR\n\n‚Ä¢ PR: '"${NEW_PR_URL}"$'\n‚Ä¢ Commits: '"${COMMITS_BEHIND}"$' behind\n\n_LiteLLM is the unified LLM proxy for 100+ providers used by CARTO for all AI features_'
                fi
              else
                MESSAGE=$':x: *LiteLLM Upstream Sync*\n\n*Workflow Error:* PR URL missing\n\n<'"${WORKFLOW_RUN_URL}"$'|View workflow run>'
              fi
              ;;
            true:true)
              # Extract clean version from NEW_VERSION
              NEW_VERSION_CLEAN=$(echo "${NEW_VERSION}" | sed -E 's/^v//; s/-stable$//')
              MESSAGE=$':information_source: *LiteLLM Upstream Sync*\n\n*PR Already Exists*\n\n*Version:* `v'"${CURRENT_VERSION}"$'` ‚Üí `v'"${NEW_VERSION_CLEAN}"$'`\n\n‚Ä¢ PR: '"${EXISTING_PR_URL}"$'\n\n_LiteLLM is the unified LLM proxy for 100+ providers used by CARTO for all AI features_'
              ;;
            false:*)
              MESSAGE=$':white_check_mark: *LiteLLM Upstream Sync*\n\n*Status:* Up to date\n\n`carto/main` is fully synced with upstream\n\n_LiteLLM is the unified LLM proxy for 100+ providers used by CARTO for all AI features_'
              ;;
            *)
              if [[ "${SYNC_STATUS}" == "failure" ]]; then
                MESSAGE=$':x: *LiteLLM Upstream Sync*\n\n*Sync Failed*\n\n*Action Required:* Check workflow logs\n\n<'"${WORKFLOW_RUN_URL}"$'|View workflow run>'
              else
                MESSAGE=$':x: *LiteLLM Upstream Sync*\n\n*Workflow Error*\n\n*Action Required:* Check workflow logs\n\n<'"${WORKFLOW_RUN_URL}"$'|View workflow run>'
              fi
              ;;
          esac

          echo "[Slack] Sending notification to channel ${SLACK_CHANNEL}"
          echo "::endgroup::"

          echo "::group::Posting to Slack"

          # Check if SLACK_KEY secret is configured
          if [[ -z "${{ secrets.SLACK_KEY }}" ]]; then
            echo "::warning::SLACK_KEY secret not configured - skipping notification"
            echo "::endgroup::"
            exit 0
          fi

          # Retry logic (up to 3 attempts)
          SUCCESS=false
          for attempt in 1 2 3; do
            echo "[Slack] Attempt ${attempt}/3..."

            # Send to Slack API
            RESPONSE=$(curl -s -w "\n%{http_code}" \
              -F "text=${MESSAGE}" \
              -F "channel=${SLACK_CHANNEL}" \
              -H "Authorization: Bearer ${{ secrets.SLACK_KEY }}" \
              -X POST https://slack.com/api/chat.postMessage)

            # Extract HTTP code and body
            HTTP_CODE=$(echo "$RESPONSE" | tail -n1)
            BODY=$(echo "$RESPONSE" | head -n-1)

            echo "[Slack] HTTP ${HTTP_CODE}"
            echo "[Slack] Response: ${BODY}"

            # Check if successful
            if [ "$HTTP_CODE" = "200" ]; then
              # Check Slack API response
              if echo "$BODY" | grep -q '"ok":true'; then
                echo "‚úÖ [Slack] Notification sent successfully"
                SUCCESS=true
                break
              else
                ERROR=$(echo "$BODY" | grep -o '"error":"[^"]*"' || echo "unknown error")
                echo "‚ö†Ô∏è [Slack] Slack API error: ${ERROR}"
              fi
            else
              echo "‚ö†Ô∏è [Slack] HTTP error: ${HTTP_CODE}"
            fi

            # Wait before retry
            if [ $attempt -lt 3 ]; then
              echo "[Slack] Retrying in 5 seconds..."
              sleep 5
            fi
          done

          if [ "$SUCCESS" = "false" ]; then
            echo "::error::Failed to send Slack notification after 3 attempts"
            echo "::notice::Check SLACK_KEY secret and channel permissions"
          fi

          echo "::endgroup::"
