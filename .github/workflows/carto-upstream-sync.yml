################################################################################
# CARTO - Upstream Sync
################################################################################

# This workflow automatically syncs CARTO's LiteLLM fork with upstream stable
# releases from BerriAI/litellm.
#
# Branch Strategy:
#   1. BerriAI/litellm:main -> CartoDB/litellm:main (direct push with PAT)
#   2. CartoDB/litellm:main -> CartoDB/litellm:carto/main (PR for manual review)
#
# The workflow runs every 8 hours and performs two checks:
#   - Detects new stable releases (tagged with -stable suffix) and syncs main
#   - Creates PR to carto/main if carto/main is behind main (regardless of upstream sync)
#
# Uses X_GITHUB_SUPERCARTOFANTE token to allow workflow file modifications.

name: CARTO - Upstream Sync

permissions:
  contents: write        # Allow push to main branch and modify files (including workflows)
  pull-requests: write   # Allow PR creation and management

on:
  # Automatic sync disabled for initial testing phase
  # Uncomment after successful manual testing
  # schedule:
  #   - cron: "0 */8 * * *"  # Every 8 hours

  workflow_dispatch:  # Manual trigger for testing

jobs:
  ##############################################################################
  # Check for New Release
  ##############################################################################

  check-new-release:
    runs-on: ubuntu-latest
    name: "Check for new upstream release"
    outputs:
      has-new-release: ${{ steps.detect-release.outputs.has-new-release }}
      new-version: ${{ steps.detect-release.outputs.new-version }}
      current-version: ${{ steps.detect-release.outputs.current-version }}
    steps:
      - name: Checkout main branch
        uses: actions/checkout@v4
        with:
          ref: main
          fetch-depth: 0

      - name: Add upstream remote
        run: |
          set -eu
          git remote add upstream https://github.com/BerriAI/litellm.git || true
          git fetch upstream --tags

      - name: Detect new stable release (bash + gh CLI)
        id: detect-release
        env:
          GH_TOKEN: ${{ secrets.X_GITHUB_SUPERCARTOFANTE }}
        run: |
          set -eu

          echo "::group::Detecting new stable releases"
          echo "[Sync] Using gh CLI to fetch releases from BerriAI/litellm..."

          # Get current version from pyproject.toml
          CURRENT_VERSION=$(grep -E "^version\s*=" pyproject.toml | head -1 | sed -E 's/.*"([^"]+)".*/\1/')
          echo "[Sync] Current version in pyproject.toml: ${CURRENT_VERSION}"

          # Get latest stable release tag (ends with -stable, not a prerelease)
          LATEST_STABLE=$(gh release list --repo BerriAI/litellm --limit 50 --json tagName,isPrerelease,isDraft | \
            jq -r '.[] | select(.isPrerelease == false and .isDraft == false and (.tagName | endswith("-stable"))) | .tagName' | \
            sort -V | tail -1)

          if [[ -z "${LATEST_STABLE}" ]]; then
            echo "[Sync] No stable releases found in upstream"
            echo "has-new-release=false" >> $GITHUB_OUTPUT
            echo "::endgroup::"
            exit 0
          fi

          echo "[Sync] Latest upstream stable release: ${LATEST_STABLE}"

          # Extract version from tag (remove 'v' prefix and '-stable' suffix)
          # e.g., v1.78.5-stable -> 1.78.5
          LATEST_VERSION=$(echo "${LATEST_STABLE}" | sed -E 's/^v//; s/-stable$//')

          echo "[Sync] Latest version: ${LATEST_VERSION}"
          echo "[Sync] Current version: ${CURRENT_VERSION}"

          # Compare versions (simple string comparison works for semver)
          if [[ "${LATEST_VERSION}" > "${CURRENT_VERSION}" ]]; then
            echo "[Sync] âœ… New stable release available: ${LATEST_STABLE}"
            echo "has-new-release=true" >> $GITHUB_OUTPUT
            echo "new-version=${LATEST_STABLE}" >> $GITHUB_OUTPUT
            echo "current-version=${CURRENT_VERSION}" >> $GITHUB_OUTPUT
            echo "::notice title=New Release Detected::${LATEST_STABLE} (current: ${CURRENT_VERSION})"
          else
            echo "[Sync] âœ… Already on latest stable: ${CURRENT_VERSION}"
            echo "has-new-release=false" >> $GITHUB_OUTPUT
          fi

          echo "::endgroup::"

  ##############################################################################
  # Sync main branch with upstream
  ##############################################################################

  sync-main-branch:
    runs-on: ubuntu-latest
    name: "Sync main with upstream"
    needs:
      - check-new-release
    if: needs.check-new-release.outputs.has-new-release == 'true'
    steps:
      - name: Checkout main branch
        uses: actions/checkout@v4
        with:
          ref: main
          fetch-depth: 0
          token: ${{ secrets.X_GITHUB_SUPERCARTOFANTE }}

      - name: Configure Git
        run: |
          set -eu
          git config --global user.email "cartofante@carto.com"
          git config --global user.name "Cartofante"

      - name: Sync main with upstream/main
        env:
          NEW_VERSION: ${{ needs.check-new-release.outputs.new-version }}
        run: |
          set -eu

          echo "::group::Syncing main branch with upstream"
          echo "[Sync] main should be a mirror of upstream - attempting merge with conflict resolution"

          # Add upstream remote
          git remote add upstream https://github.com/BerriAI/litellm.git || true
          git fetch upstream --tags

          # Try merge first (git-friendly approach)
          echo "[Sync] Attempting merge with -X theirs strategy..."
          if git merge upstream/main --no-edit -X theirs -m "sync: merge upstream/main for ${NEW_VERSION}

          Automatic sync from upstream BerriAI/litellm
          Preparing for ${NEW_VERSION} release

          Strategy: Accept all upstream changes (main is a mirror)"; then
            echo "[Sync] âœ… Merge successful"
          else
            # Merge failed - abort and use reset as fallback
            echo "[Sync] âš ï¸ Merge failed, using reset fallback (main is a mirror)"
            git merge --abort || true

            # Store old commit for reference
            OLD_COMMIT=$(git rev-parse HEAD)
            echo "[Sync] Old HEAD: ${OLD_COMMIT}"

            # Reset to upstream (mirror strategy)
            git reset --hard upstream/main

            # Create merge commit for history
            git commit --allow-empty -m "sync: merge upstream/main for ${NEW_VERSION}

          Automatic sync from upstream BerriAI/litellm
          Preparing for ${NEW_VERSION} release

          Strategy: Reset to upstream (merge conflicts required mirror reset)
          Previous HEAD: ${OLD_COMMIT}"
          fi

          # Push to origin/main
          echo "[Sync] Pushing updated main branch to origin..."

          # Check if we need force push
          if git merge-base --is-ancestor origin/main HEAD; then
            # Fast-forward possible, normal push
            git push origin main
          else
            # Force push needed (from reset fallback)
            echo "[Sync] Using force-with-lease (reset was used)"
            git push origin main --force-with-lease
          fi

          echo "[Sync] âœ… main branch synced successfully"
          echo "::endgroup::"

  ##############################################################################
  # Check if carto/main needs sync from main
  ##############################################################################

  check-carto-main-sync:
    runs-on: ubuntu-latest
    name: "Check if carto/main needs sync"
    needs:
      - sync-main-branch
    if: always() && (needs.sync-main-branch.result == 'success' || needs.sync-main-branch.result == 'skipped')
    outputs:
      needs-sync: ${{ steps.check-sync.outputs.needs-sync }}
      commits-behind: ${{ steps.check-sync.outputs.commits-behind }}
      pr-exists: ${{ steps.check-pr.outputs.pr-exists }}
      pr-url: ${{ steps.check-pr.outputs.pr-url }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Check if carto/main is behind main
        id: check-sync
        run: |
          set -eu

          echo "::group::Checking if carto/main needs sync from main"

          # Fetch both branches
          git fetch origin main
          git fetch origin carto/main

          # Count commits that carto/main is behind main
          COMMITS_BEHIND=$(git rev-list --count origin/carto/main..origin/main 2>/dev/null || echo "0")

          echo "[Sync] carto/main is ${COMMITS_BEHIND} commits behind main"

          if [[ "${COMMITS_BEHIND}" -gt 0 ]]; then
            echo "[Sync] âœ… carto/main needs sync (${COMMITS_BEHIND} commits behind)"
            echo "needs-sync=true" >> $GITHUB_OUTPUT
            echo "commits-behind=${COMMITS_BEHIND}" >> $GITHUB_OUTPUT
            echo "::notice title=Sync Needed::carto/main is ${COMMITS_BEHIND} commits behind main"
          else
            echo "[Sync] âœ… carto/main is up to date with main"
            echo "needs-sync=false" >> $GITHUB_OUTPUT
            echo "commits-behind=0" >> $GITHUB_OUTPUT
          fi

          echo "::endgroup::"

      - name: Check for existing PR from main to carto/main
        id: check-pr
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -eu

          echo "::group::Checking for existing PR"
          echo "[Sync] Looking for open PR from main to carto/main..."

          # Check if PR exists from main to carto/main with upstream-sync label
          PR_URL=$(gh pr list \
            --repo CartoDB/litellm \
            --base carto/main \
            --head main \
            --label upstream-sync \
            --state open \
            --json url \
            --jq ".[0].url" 2>/dev/null || echo "")

          if [[ -n "${PR_URL}" ]]; then
            echo "[Sync] PR already exists: ${PR_URL}"
            echo "pr-exists=true" >> $GITHUB_OUTPUT
            echo "pr-url=${PR_URL}" >> $GITHUB_OUTPUT
            echo "::notice title=PR Already Exists::${PR_URL}"
          else
            echo "[Sync] No existing PR found"
            echo "pr-exists=false" >> $GITHUB_OUTPUT
          fi

          echo "::endgroup::"

  ##############################################################################
  # Create Sync PR (main -> carto/main)
  ##############################################################################

  create-sync-pr:
    runs-on: ubuntu-latest
    name: "Create sync PR to carto/main"
    needs:
      - check-new-release
      - check-carto-main-sync
    if: needs.check-carto-main-sync.outputs.needs-sync == 'true' && needs.check-carto-main-sync.outputs.pr-exists == 'false'
    outputs:
      pr-url: ${{ steps.create-pr.outputs.pr-url }}
    steps:
      - name: Checkout main branch
        uses: actions/checkout@v4
        with:
          ref: main
          fetch-depth: 0

      - name: Generate PR body
        id: generate-pr-body
        env:
          NEW_VERSION: ${{ needs.check-new-release.outputs.new-version }}
          CURRENT_VERSION: ${{ needs.check-new-release.outputs.current-version }}
        run: |
          set -eu

          echo "::group::[Sync] Generating PR body"

          PR_BODY_FILE="sync-pr-body.md"

          # Extract version without v prefix and -stable suffix for comparison
          NEW_VERSION_CLEAN=$(echo "${NEW_VERSION}" | sed -E 's/^v//; s/-stable$//')

          # Count commits between current and new version
          git fetch origin carto/main
          COMMITS_COUNT=$(git rev-list --count origin/carto/main..main 2>/dev/null || echo "unknown")
          FILES_CHANGED=$(git diff --name-only origin/carto/main..main | wc -l | tr -d ' ')

          # Create PR body
          cat > ${PR_BODY_FILE} << EOF
          ## ðŸ”„ Upstream Sync: ${NEW_VERSION}

          This PR syncs CARTO's LiteLLM fork with the latest stable upstream release.

          ### ðŸ“Š Release Information

          - **Upstream Version:** \`${NEW_VERSION}\`
          - **Current Version:** \`${CURRENT_VERSION}\`
          - **Commits Ahead:** ${COMMITS_COUNT}
          - **Files Changed:** ${FILES_CHANGED}
          - **Upstream Repo:** [BerriAI/litellm](https://github.com/BerriAI/litellm)
          - **Upstream Release:** [${NEW_VERSION}](https://github.com/BerriAI/litellm/releases/tag/${NEW_VERSION})
          - **Compare Changes:** [v${CURRENT_VERSION}-stable...${NEW_VERSION}](https://github.com/BerriAI/litellm/compare/v${CURRENT_VERSION}-stable...${NEW_VERSION})

          ### ðŸ”€ Branch Flow

          1. âœ… \`BerriAI/litellm:main\` merged into \`CartoDB/litellm:main\`
          2. ðŸ“ This PR: \`CartoDB/litellm:main\` â†’ \`CartoDB/litellm:carto/main\`

          ### ðŸ“ CARTO-Specific File Guidelines

          When reviewing or resolving conflicts, follow these guidelines:

          #### âœ… Keep CARTO Versions (Ours)
          - \`.github/workflows/carto_*.yaml\` - All CARTO-specific workflows
          - \`.github/workflows/carto-*.yml\` - CARTO workflows
          - \`CARTO_*.md\` - CARTO documentation files
          - \`docs/CARTO_*.md\` - CARTO documentation in docs/

          #### ðŸ”„ Accept Upstream (Theirs)
          - \`pyproject.toml\` - Version field (should match upstream)
          - \`litellm/\` - Core LiteLLM library code
          - \`tests/\` - Upstream test files
          - \`requirements.txt\` - Upstream dependencies

          #### âš ï¸ Manual Review Required
          - \`Dockerfile\` - Check sections marked with \`# CARTO:\` comments
          - \`docker/Dockerfile.non_root\` - Contains CARTO customizations
          - \`Makefile\` - Check sections marked with \`# CARTO:\` comments
          - \`db_scripts/\` - CARTO may have custom scripts

          ### ðŸ§ª Testing Checklist

          Before merging, ensure the following tests pass:

          - [ ] \`make lint\` - Linting passes
          - [ ] \`make test-unit\` - Unit tests pass
          - [ ] Docker build succeeds: \`docker build -f docker/Dockerfile.non_root .\`
          - [ ] CARTO workflows still work (check \`carto_*.yaml\` files)
          - [ ] Review \`pyproject.toml\` version matches upstream

          ### ðŸ“š Documentation

          - [CARTO Release Process](./docs/CARTO_RELEASE_PROCESS.md) - Full sync and release process
          - [CARTO Customizations](./CARTO_CLAUDE.md) - CARTO-specific modifications

          ### ðŸ”§ Conflict Resolution

          **If this PR has conflicts, there are two options:**

          #### Option 1: Automated Claude Code Resolution (Recommended)

          The [carto-upstream-sync-resolver](https://github.com/CartoDB/litellm/actions/workflows/carto-upstream-sync-resolver.yml) workflow will automatically trigger when conflicts are detected.

          **It will:**
          1. ðŸ¤– Detect conflicts in this PR
          2. ðŸ”€ Checkout \`carto/main\` and merge \`main\` into it
          3. âœï¸ Resolve conflicts following CARTO priority rules
          4. âœ… Run all tests (\`make lint\`, \`make lint-mypy\`, \`make test-unit\`)
          5. ðŸ“ Create a resolution PR: \`upstream-sync-resolver/<PR-number> â†’ carto/main\`

          **What you need to do:**
          1. Review the resolution PR created by Claude Code
          2. Verify CARTO customizations are preserved
          3. Merge the resolution PR into \`carto/main\`
          4. **Close this PR** (changes already merged via resolution PR)

          #### Option 2: Manual Resolution

          If you prefer manual resolution or Claude fails:

          1. **Checkout and merge locally:**
            \`\`\`bash
            git fetch origin
            git checkout carto/main
            git pull origin carto/main
            git merge main  # Creates conflicts
            \`\`\`

          2. **Resolve conflicts following guidelines above**

          3. **Test your changes:**
            \`\`\`bash
            make lint
            make lint-mypy
            make test-unit
            \`\`\`

          4. **Push resolved changes:**
            \`\`\`bash
            git push origin carto/main
            \`\`\`

          5. **Close this PR** (changes already in carto/main)

          ---

          *ðŸ¤– This PR was automatically created by the [carto-upstream-sync workflow](https://github.com/CartoDB/litellm/actions/workflows/carto-upstream-sync.yml).*
          EOF

          echo "[Sync] PR body generated successfully"
          echo "::endgroup::"

      - name: Create Pull Request
        id: create-pr
        env:
          NEW_VERSION: ${{ needs.check-new-release.outputs.new-version }}
          GH_TOKEN: ${{ secrets.X_GITHUB_SUPERCARTOFANTE }}
        run: |
          set -eu

          echo "::group::Creating Pull Request"

          PR_BODY_FILE="sync-pr-body.md"

          # Create PR from main to carto/main
          PR_URL=$(gh pr create \
            --repo CartoDB/litellm \
            --base carto/main \
            --head main \
            --title "ðŸ”„ sync: upstream ${NEW_VERSION}" \
            --body-file ${PR_BODY_FILE} \
            --label "upstream-sync" \
            --label "automated")

          echo "[Sync] Pull Request created: ${PR_URL}"
          echo "pr-url=${PR_URL}" >> $GITHUB_OUTPUT
          echo "::notice title=PR Created::${PR_URL}"

          echo "::endgroup::"

          # GitHub Actions summary
          echo "::group::Workflow Summary"
          cat >> $GITHUB_STEP_SUMMARY << EOF
          ## ðŸŽ‰ Upstream Sync PR Created Successfully

          - **PR URL:** ${PR_URL}
          - **Version:** ${NEW_VERSION}
          - **Branch Flow:** main â†’ carto/main

          ### Next Steps
          1. Review the PR for any conflicts or issues
          2. Run tests: \`make lint && make test-unit\`
          3. Approve and merge when ready
          EOF
          echo "::endgroup::"

  ##############################################################################
  # Notify Slack
  ##############################################################################

  notify-slack:
    runs-on: ubuntu-latest
    name: "Notify Slack"
    if: always()
    needs:
      - check-new-release
      - sync-main-branch
      - check-carto-main-sync
      - create-sync-pr
    steps:
      - name: Send Slack notification
        env:
          SLACK_CHANNEL: "C3W6342EN" # infrastructure-dev
          HAS_NEW_RELEASE: ${{ needs.check-new-release.outputs.has-new-release }}
          NEW_VERSION: ${{ needs.check-new-release.outputs.new-version }}
          NEEDS_SYNC: ${{ needs.check-carto-main-sync.outputs.needs-sync }}
          COMMITS_BEHIND: ${{ needs.check-carto-main-sync.outputs.commits-behind }}
          PR_EXISTS: ${{ needs.check-carto-main-sync.outputs.pr-exists }}
          EXISTING_PR_URL: ${{ needs.check-carto-main-sync.outputs.pr-url }}
          NEW_PR_URL: ${{ needs.create-sync-pr.outputs.pr-url }}
          SYNC_STATUS: ${{ needs.sync-main-branch.result }}
        run: |
          set -eu

          echo "::group::Determining Slack notification"

          # Skip if channel not configured
          if [[ -z "${SLACK_CHANNEL}" ]]; then
            echo "[Slack] SLACK_CHANNEL not configured, skipping notification"
            echo "::endgroup::"
            exit 0
          fi

          # Determine message based on workflow results
          WORKFLOW_RUN_URL="https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}"

          # Build message based on what happened
          case "${NEEDS_SYNC}:${PR_EXISTS}" in
            true:false)
              if [[ -n "${NEW_PR_URL}" ]]; then
                if [[ "${HAS_NEW_RELEASE}" == "true" ]]; then
                  MESSAGE=":white_check_mark: *LiteLLM Upstream Sync* - New release ${NEW_VERSION} detected\nâ€¢ PR created: ${NEW_PR_URL}\nâ€¢ Commits: ${COMMITS_BEHIND} behind"
                else
                  MESSAGE=":white_check_mark: *LiteLLM Upstream Sync* - PR created (carto/main was ${COMMITS_BEHIND} commits behind)\n${NEW_PR_URL}"
                fi
              else
                MESSAGE=":x: *LiteLLM Upstream Sync* - Workflow error (PR URL missing)\n<${WORKFLOW_RUN_URL}|View workflow run>"
              fi
              ;;
            true:true)
              MESSAGE=":information_source: *LiteLLM Upstream Sync* - PR already exists (${COMMITS_BEHIND} commits behind)\n${EXISTING_PR_URL}"
              ;;
            false:*)
              MESSAGE=":white_check_mark: *LiteLLM Upstream Sync* - carto/main is up to date with main"
              ;;
            *)
              if [[ "${SYNC_STATUS}" == "failure" ]]; then
                MESSAGE=":x: *LiteLLM Upstream Sync* - Failed to sync main branch with upstream\n<${WORKFLOW_RUN_URL}|View workflow run>"
              else
                MESSAGE=":x: *LiteLLM Upstream Sync* - Workflow encountered an error\n<${WORKFLOW_RUN_URL}|View workflow run>"
              fi
              ;;
          esac

          echo "[Slack] Sending notification to channel ${SLACK_CHANNEL}"
          echo "::endgroup::"

          echo "::group::Posting to Slack"
          curl -F "text=${MESSAGE}" \
            -F "channel=${SLACK_CHANNEL}" \
            -H "Authorization: Bearer ${{ secrets.SLACK_KEY }}" \
            -X POST https://slack.com/api/chat.postMessage

          echo "[Slack] Notification sent successfully"
          echo "::endgroup::"
