/**
 * LiteLLM proxy lifecycle management.
 *
 * Handles cloning the repo, creating a Python venv, installing dependencies,
 * generating config files from OpenClaw auth profiles, and starting/stopping
 * the proxy process.
 */

import { spawn, execSync, type ChildProcess } from "node:child_process";
import { existsSync, readFileSync, writeFileSync } from "node:fs";
import { join } from "node:path";
import { request } from "node:http";
import { homedir } from "node:os";
import { extractApiKeys, availableProviders } from "./keys.js";

interface ServiceOptions {
  port: number;
  masterKey: string;
  gitRepo: string;
}

interface ServiceContext {
  stateDir: string;
  logger: {
    info: (msg: string) => void;
    warn: (msg: string) => void;
    error: (msg: string) => void;
  };
}

/** Parsed models.yaml structure */
interface ModelsConfig {
  tier_candidates: Record<
    string,
    Array<{ provider: string; model: string; display: string; cost: string }>
  >;
  provider_models: Record<
    string,
    { key_env: string; models: Array<{ name: string; id: string }> }
  >;
}

let proxyProcess: ChildProcess | null = null;

/**
 * Kill any process listening on the given port.
 * This handles stale processes from previous gateway runs.
 */
function killProcessOnPort(port: number): void {
  try {
    const output = execSync(
      `lsof -ti :${port} 2>/dev/null || true`,
      { encoding: "utf-8", stdio: ["pipe", "pipe", "pipe"] },
    ).trim();
    if (output) {
      for (const pid of output.split("\n")) {
        try {
          process.kill(Number(pid), "SIGTERM");
        } catch {
          // Process already gone
        }
      }
      // Brief wait for processes to exit
      execSync("sleep 1", { stdio: "pipe" });
    }
  } catch {
    // lsof not available or failed — continue anyway
  }
}

/**
 * Find a Python 3.10-3.13 binary on the system.
 */
function findPython(): string {
  const candidates = [
    "python3.13",
    "python3.12",
    "python3.11",
    "python3.10",
    "python3",
    "python",
  ];

  for (const cmd of candidates) {
    try {
      const version = execSync(
        `${cmd} -c "import sys; v=sys.version_info; print(f'{v.major}.{v.minor}')"`,
        { encoding: "utf-8", stdio: ["pipe", "pipe", "pipe"] },
      ).trim();
      const [major, minor] = version.split(".").map(Number);
      if (major === 3 && minor >= 10 && minor <= 13) {
        return cmd;
      }
    } catch {
      // candidate not found, try next
    }
  }

  throw new Error(
    "Python 3.10-3.13 is required but not found. " +
      "Install it with: brew install python@3.12 (macOS) or apt install python3.12 (Ubuntu)",
  );
}

/**
 * Pick the best available model for a tier based on available API key providers.
 */
function pickTierModel(
  tierCandidates: ModelsConfig["tier_candidates"],
  tier: string,
  providers: Set<string>,
): string | null {
  const candidates = tierCandidates[tier] ?? [];
  for (const c of candidates) {
    if (providers.has(c.provider)) {
      return c.model;
    }
  }
  return null;
}

/**
 * Generate the .env file with extracted API keys.
 */
function writeEnvFile(envPath: string, keys: Record<string, string>): void {
  const lines = [
    "# LiteLLM API Keys — auto-generated by ClawRouter plugin",
    ...Object.entries(keys).map(([k, v]) => `${k}=${v}`),
    "",
  ];
  writeFileSync(envPath, lines.join("\n"));
}

/**
 * Generate proxy_config.yaml with model entries for available providers
 * and the auto-router entry.
 */
function writeProxyConfig(
  configPath: string,
  modelsConfig: ModelsConfig,
  providers: Set<string>,
  routingRulesPath: string,
  masterKey: string,
  defaultModel: string,
  port: number,
): void {
  const modelEntries: string[] = [];

  // Add provider model entries
  for (const [providerName, providerInfo] of Object.entries(
    modelsConfig.provider_models,
  )) {
    if (!providers.has(providerName)) continue;
    for (const m of providerInfo.models) {
      modelEntries.push(
        `  - model_name: ${m.name}`,
        `    litellm_params:`,
        `      model: ${m.id}`,
        `      api_key: os.environ/${providerInfo.key_env}`,
      );
    }
  }

  // Add auto-router entry
  modelEntries.push(
    `  - model_name: auto`,
    `    litellm_params:`,
    `      model: "auto_router/auto_router_1"`,
    `      auto_router_config_path: "${routingRulesPath}"`,
    `      auto_router_default_model: "${defaultModel}"`,
  );

  const config = [
    "model_list:",
    ...modelEntries,
    "",
    "# General Settings",
    "general_settings:",
    `  port: ${port}`,
    "  forward_client_headers_to_llm_api: true",
    "  store_model_in_db: false",
    "",
    "# Router Settings",
    "router_settings:",
    "  model_group_alias: {}",
    "",
    "litellm_settings:",
    `  master_key: ${masterKey}`,
    "  drop_params: true",
    "",
  ];

  writeFileSync(configPath, config.join("\n"));
}

/**
 * Generate routing_rules.yaml with tier models based on available providers.
 */
function writeRoutingRules(
  rulesPath: string,
  modelsConfig: ModelsConfig,
  providers: Set<string>,
): void {
  const low =
    pickTierModel(modelsConfig.tier_candidates, "low", providers) ??
    "deepseek/deepseek-chat";
  const mid =
    pickTierModel(modelsConfig.tier_candidates, "mid", providers) ??
    "anthropic/claude-sonnet-4-5-20250929";
  const top =
    pickTierModel(modelsConfig.tier_candidates, "top", providers) ??
    "anthropic/claude-opus-4-5-20251101";

  const rules = [
    "# Auto-Router Configuration",
    "# Auto-generated by ClawRouter plugin",
    "",
    "tiers:",
    "  low:",
    `    model: "${low}"`,
    "    max_cost_per_m_tokens: 1.0",
    "  mid:",
    `    model: "${mid}"`,
    "    max_cost_per_m_tokens: 5.0",
    "  top:",
    `    model: "${top}"`,
    "    max_cost_per_m_tokens: 30.0",
    "",
    "routing:",
    "  heartbeat: low",
    "  simple-chat: low",
    "  lookup: low",
    "  translation: mid",
    "  summarization: mid",
    "  coding: mid",
    "  creative: mid",
    "  reasoning: top",
    "  analysis: top",
    "",
    "custom_patterns: []",
    "",
  ];

  writeFileSync(rulesPath, rules.join("\n"));
}

/**
 * Poll the proxy health endpoint until it responds or timeout.
 */
function waitForHealth(port: number, timeoutMs: number): Promise<void> {
  const start = Date.now();
  const interval = 500;

  return new Promise((resolve, reject) => {
    const check = () => {
      if (Date.now() - start > timeoutMs) {
        reject(new Error(`Proxy health check timed out after ${timeoutMs}ms`));
        return;
      }

      const req = request(
        { hostname: "127.0.0.1", port, path: "/health/liveliness", method: "GET", timeout: 2000 },
        (res) => {
          if (res.statusCode === 200) {
            resolve();
          } else {
            setTimeout(check, interval);
          }
        },
      );
      req.on("error", () => setTimeout(check, interval));
      req.on("timeout", () => {
        req.destroy();
        setTimeout(check, interval);
      });
      req.end();
    };

    check();
  });
}

/**
 * Parse a YAML file using Python (avoids adding a JS YAML dependency).
 * Returns the parsed object.
 */
function parseYamlWithPython(filePath: string, python: string): ModelsConfig {
  const script = `
import yaml, json, sys
with open(sys.argv[1]) as f:
    print(json.dumps(yaml.safe_load(f)))
`;
  const result = execSync(`${python} -c '${script}' "${filePath}"`, {
    encoding: "utf-8",
    stdio: ["pipe", "pipe", "pipe"],
  });
  return JSON.parse(result);
}

/**
 * Patch openclaw.json to add/update the clawrouter provider entry.
 * This ensures the provider is available without requiring the user to
 * run the interactive `openclaw configure` wizard.
 */
function patchOpenClawConfig(port: number, masterKey: string): void {
  const configPath = join(homedir(), ".openclaw", "openclaw.json");
  try {
    const raw = readFileSync(configPath, "utf-8");
    const config = JSON.parse(raw);

    if (!config.models) config.models = {};
    if (!config.models.providers) config.models.providers = {};

    config.models.providers.clawrouter = {
      baseUrl: `http://127.0.0.1:${port}/v1`,
      apiKey: masterKey,
      api: "openai-completions",
      models: [
        {
          id: "auto",
          name: "ClawRouter Auto",
          reasoning: false,
          input: ["text"],
          cost: { input: 0, output: 0, cacheRead: 0, cacheWrite: 0 },
          contextWindow: 128000,
          maxTokens: 8192,
        },
      ],
    };

    writeFileSync(configPath, JSON.stringify(config, null, 2) + "\n");
  } catch {
    // Config file not found or not writable — skip
  }
}

/**
 * Creates the ClawRouter service descriptor for OpenClaw plugin registration.
 */
export function createClawRouterService(options: ServiceOptions) {
  const { port, masterKey, gitRepo } = options;

  return {
    id: "clawrouter-proxy",
    label: "ClawRouter Proxy",

    async start(ctx: ServiceContext) {
      const { stateDir, logger } = ctx;
      const repoDir = join(stateDir, "litellm");
      const venvDir = join(repoDir, ".venv");
      const envFile = join(repoDir, ".env");
      const configFile = join(repoDir, "litellm", "proxy", "proxy_config.yaml");
      const routingRulesFile = join(
        repoDir,
        "litellm",
        "router_strategy",
        "auto_router",
        "routing_rules.yaml",
      );
      const modelsFile = join(repoDir, "models.yaml");

      // 1. Clone or update repo
      if (!existsSync(join(repoDir, ".git"))) {
        logger.info(`Cloning ClawRouter repo into ${repoDir}...`);
        execSync(`git clone --depth 1 "${gitRepo}" "${repoDir}"`, {
          stdio: "pipe",
          timeout: 120_000,
        });
        logger.info("Clone complete");
      } else {
        logger.info("Updating existing ClawRouter repo...");
        try {
          execSync("git pull --ff-only", {
            cwd: repoDir,
            stdio: "pipe",
            timeout: 30_000,
          });
        } catch {
          logger.warn("git pull failed — using existing checkout");
        }
      }

      // 2. Find Python and create venv
      const python = findPython();
      logger.info(`Using ${python}`);

      if (!existsSync(join(venvDir, "bin", "python"))) {
        logger.info("Creating Python virtual environment...");
        execSync(`${python} -m venv "${venvDir}"`, {
          stdio: "pipe",
          timeout: 30_000,
        });
      }

      const pip = join(venvDir, "bin", "pip");
      const litellmBin = join(venvDir, "bin", "litellm");

      // 3. Install dependencies
      if (!existsSync(litellmBin)) {
        logger.info(
          "Installing LiteLLM with proxy extras (this may take a minute)...",
        );
        execSync(`"${pip}" install --upgrade pip`, {
          cwd: repoDir,
          stdio: "pipe",
          timeout: 60_000,
        });
        execSync(`"${pip}" install -e ".[proxy]"`, {
          cwd: repoDir,
          stdio: "pipe",
          timeout: 300_000,
        });
        logger.info("Installation complete");
      }

      // 4. Extract API keys from OpenClaw auth profiles
      const apiKeys = await extractApiKeys();
      const providers = availableProviders(apiKeys);
      logger.info(
        `Found API keys for: ${[...providers].join(", ") || "(none)"}`,
      );

      // 5. Write .env
      writeEnvFile(envFile, apiKeys);

      // 6. Parse models.yaml and generate configs
      const venvPython = join(venvDir, "bin", "python");
      const modelsConfig = parseYamlWithPython(modelsFile, venvPython);

      // Pick default model (mid tier preferred)
      const midModel = pickTierModel(
        modelsConfig.tier_candidates,
        "mid",
        providers,
      );
      const defaultModel =
        midModel ??
        pickTierModel(modelsConfig.tier_candidates, "low", providers) ??
        pickTierModel(modelsConfig.tier_candidates, "top", providers) ??
        "anthropic/claude-sonnet-4-5-20250929";

      // 7. Generate routing_rules.yaml (with tier models based on available keys)
      writeRoutingRules(routingRulesFile, modelsConfig, providers);
      logger.info("Generated routing_rules.yaml");

      // 8. Generate proxy_config.yaml
      writeProxyConfig(
        configFile,
        modelsConfig,
        providers,
        routingRulesFile,
        masterKey,
        defaultModel,
        port,
      );
      logger.info("Generated proxy_config.yaml");

      // 9. Build process environment with API keys
      const processEnv: Record<string, string> = {
        ...process.env as Record<string, string>,
        ...apiKeys,
      };

      // 10. Kill any stale proxy on the target port
      killProcessOnPort(port);

      // 11. Start proxy
      logger.info(`Starting LiteLLM proxy on port ${port}...`);
      proxyProcess = spawn(
        litellmBin,
        ["--config", configFile, "--port", String(port)],
        {
          cwd: repoDir,
          env: processEnv,
          stdio: ["ignore", "pipe", "pipe"],
        },
      );

      proxyProcess.stdout?.on("data", (data: Buffer) => {
        const line = data.toString().trim();
        if (line) logger.info(`[proxy] ${line}`);
      });

      proxyProcess.stderr?.on("data", (data: Buffer) => {
        const line = data.toString().trim();
        if (line) logger.warn(`[proxy] ${line}`);
      });

      proxyProcess.on("exit", (code) => {
        logger.info(`Proxy process exited with code ${code}`);
        proxyProcess = null;
      });

      // 11. Wait for health check
      logger.info("Waiting for proxy to become healthy...");
      await waitForHealth(port, 60_000);
      logger.info(`Proxy is healthy at http://127.0.0.1:${port}`);

      // 13. Patch openclaw.json with clawrouter provider
      patchOpenClawConfig(port, masterKey);
      logger.info("Patched openclaw.json with clawrouter provider");
    },

    async stop(ctx: ServiceContext) {
      const { logger } = ctx;

      if (!proxyProcess) {
        logger.info("No proxy process to stop");
        return;
      }

      logger.info("Stopping proxy...");
      proxyProcess.kill("SIGTERM");

      // Wait up to 5s for graceful shutdown
      await new Promise<void>((resolve) => {
        const timeout = setTimeout(() => {
          if (proxyProcess) {
            logger.warn("Proxy did not exit gracefully, sending SIGKILL");
            proxyProcess.kill("SIGKILL");
          }
          resolve();
        }, 5000);

        if (proxyProcess) {
          proxyProcess.on("exit", () => {
            clearTimeout(timeout);
            resolve();
          });
        } else {
          clearTimeout(timeout);
          resolve();
        }
      });

      proxyProcess = null;
      logger.info("Proxy stopped");
    },
  };
}
