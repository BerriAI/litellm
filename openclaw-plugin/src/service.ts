/**
 * Extracts OpenClaw API keys and runs setup.sh.
 *
 * Reads API keys from OpenClaw auth profiles, writes them to .env
 * (so setup.sh skips interactive prompts), then runs setup.sh which
 * handles everything else: Python, venv, install, config, proxy start.
 */

import { spawn, execSync, type ChildProcess } from "node:child_process";
import { existsSync, writeFileSync } from "node:fs";
import { join } from "node:path";
import { extractApiKeys } from "./keys.js";

interface ServiceOptions {
  gitRepo: string;
}

interface ServiceContext {
  stateDir: string;
  logger: {
    info: (msg: string) => void;
    warn: (msg: string) => void;
    error: (msg: string) => void;
  };
}

let setupProcess: ChildProcess | null = null;

/**
 * Creates the ClawRouter service descriptor for OpenClaw plugin registration.
 */
export function createClawRouterService(options: ServiceOptions) {
  const { gitRepo } = options;

  return {
    id: "clawrouter-proxy",
    label: "ClawRouter Proxy",

    async start(ctx: ServiceContext) {
      const { stateDir, logger } = ctx;
      const repoDir = join(stateDir, "litellm");
      const envFile = join(repoDir, ".env");
      const setupScript = join(repoDir, "setup.sh");

      // 1. Clone or update repo
      if (!existsSync(join(repoDir, ".git"))) {
        logger.info(`Cloning ClawRouter repo into ${repoDir}...`);
        execSync(`git clone --depth 1 "${gitRepo}" "${repoDir}"`, {
          stdio: "pipe",
          timeout: 120_000,
        });
        logger.info("Clone complete");
      } else {
        logger.info("Updating existing ClawRouter repo...");
        try {
          execSync("git pull --ff-only", {
            cwd: repoDir,
            stdio: "pipe",
            timeout: 30_000,
          });
        } catch {
          logger.warn("git pull failed — using existing checkout");
        }
      }

      // 2. Extract API keys from OpenClaw auth profiles
      const apiKeys = await extractApiKeys();
      logger.info(
        `Found API keys for: ${Object.keys(apiKeys).join(", ") || "(none)"}`,
      );

      // 3. Write .env so setup.sh skips interactive API key prompts
      const lines = [
        "# LiteLLM API Keys — auto-generated by ClawRouter plugin",
        ...Object.entries(apiKeys).map(([k, v]) => `${k}=${v}`),
        "",
      ];
      writeFileSync(envFile, lines.join("\n"));
      logger.info("Wrote .env with OpenClaw API keys");

      // 4. Run setup.sh
      logger.info("Running setup.sh...");
      setupProcess = spawn("bash", [setupScript], {
        cwd: repoDir,
        env: {
          ...(process.env as Record<string, string>),
          ...apiKeys,
        },
        stdio: ["ignore", "pipe", "pipe"],
      });

      setupProcess.stdout?.on("data", (data: Buffer) => {
        const line = data.toString().trim();
        if (line) logger.info(`[setup] ${line}`);
      });

      setupProcess.stderr?.on("data", (data: Buffer) => {
        const line = data.toString().trim();
        if (line) logger.warn(`[setup] ${line}`);
      });

      setupProcess.on("exit", (code) => {
        logger.info(`setup.sh exited with code ${code}`);
        setupProcess = null;
      });
    },

    async stop(ctx: ServiceContext) {
      const { logger } = ctx;

      if (!setupProcess) {
        logger.info("No process to stop");
        return;
      }

      logger.info("Stopping...");
      setupProcess.kill("SIGTERM");

      await new Promise<void>((resolve) => {
        const timeout = setTimeout(() => {
          if (setupProcess) {
            logger.warn("Process did not exit gracefully, sending SIGKILL");
            setupProcess.kill("SIGKILL");
          }
          resolve();
        }, 5000);

        if (setupProcess) {
          setupProcess.on("exit", () => {
            clearTimeout(timeout);
            resolve();
          });
        } else {
          clearTimeout(timeout);
          resolve();
        }
      });

      setupProcess = null;
      logger.info("Stopped");
    },
  };
}
